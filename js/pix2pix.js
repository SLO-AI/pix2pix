(function (f) {
    if (typeof exports === "object" && typeof module !== "undefined") {
        module.exports = f()
    } else if (typeof define === "function" && define.amd) {
        define([], f)
    } else {
        var g;
        if (typeof window !== "undefined") {
            g = window
        } else if (typeof global !== "undefined") {
            g = global
        } else if (typeof self !== "undefined") {
            g = self
        } else {
            g = this
        }
        g.deeplearn = f()
    }
})(function () {
    var define, module, exports;
    return (function e(t, n, r) {
        function s(o, u) {
            if (!n[o]) {
                if (!t[o]) {
                    var a = typeof require == "function" && require;
                    if (!u && a) return a(o, !0);
                    if (i) return i(o, !0);
                    var f = new Error("Cannot find module '" + o + "'");
                    throw f.code = "MODULE_NOT_FOUND", f
                }
                var l = n[o] = {exports: {}};
                t[o][0].call(l.exports, function (e) {
                    var n = t[o][1][e];
                    return s(n ? n : e)
                }, l, l.exports, e, t, n, r)
            }
            return n[o].exports
        }

        var i = typeof require == "function" && require;
        for (var o = 0; o < r.length; o++) s(r[o]);
        return s
    })({
        1: [function (require, module, exports) {

        }, {}],
        2: [function (require, module, exports) {
// A library of seedable RNGs implemented in Javascript.
//
// Usage:
//
// var seedrandom = require('seedrandom');
// var random = seedrandom(1); // or any seed.
// var x = random();       // 0 <= x < 1.  Every bit is random.
// var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.

// alea, a 53-bit multiply-with-carry generator by Johannes Baagøe.
// Period: ~2^116
// Reported to pass all BigCrush tests.
            var alea = require('./lib/alea');

// xor128, a pure xor-shift generator by George Marsaglia.
// Period: 2^128-1.
// Reported to fail: MatrixRank and LinearComp.
            var xor128 = require('./lib/xor128');

// xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.
// Period: 2^192-2^32
// Reported to fail: CollisionOver, SimpPoker, and LinearComp.
            var xorwow = require('./lib/xorwow');

// xorshift7, by François Panneton and Pierre L'ecuyer, takes
// a different approach: it adds robustness by allowing more shifts
// than Marsaglia's original three.  It is a 7-shift generator
// with 256 bits, that passes BigCrush with no systmatic failures.
// Period 2^256-1.
// No systematic BigCrush failures reported.
            var xorshift7 = require('./lib/xorshift7');

// xor4096, by Richard Brent, is a 4096-bit xor-shift with a
// very long period that also adds a Weyl generator. It also passes
// BigCrush with no systematic failures.  Its long period may
// be useful if you have many generators and need to avoid
// collisions.
// Period: 2^4128-2^32.
// No systematic BigCrush failures reported.
            var xor4096 = require('./lib/xor4096');

// Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random
// number generator derived from ChaCha, a modern stream cipher.
// https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
// Period: ~2^127
// No systematic BigCrush failures reported.
            var tychei = require('./lib/tychei');

// The original ARC4-based prng included in this library.
// Period: ~2^1600
            var sr = require('./seedrandom');

            sr.alea = alea;
            sr.xor128 = xor128;
            sr.xorwow = xorwow;
            sr.xorshift7 = xorshift7;
            sr.xor4096 = xor4096;
            sr.tychei = tychei;

            module.exports = sr;

        }, {
            "./lib/alea": 3,
            "./lib/tychei": 4,
            "./lib/xor128": 5,
            "./lib/xor4096": 6,
            "./lib/xorshift7": 7,
            "./lib/xorwow": 8,
            "./seedrandom": 9
        }],
        3: [function (require, module, exports) {
// A port of an algorithm by Johannes Baagøe <baagoe@baagoe.com>, 2010
// http://baagoe.com/en/RandomMusings/javascript/
// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
// Original work is under MIT license -

// Copyright (C) 2010 by Johannes Baagøe <baagoe@baagoe.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.


            (function (global, module, define) {

                function Alea(seed) {
                    var me = this, mash = Mash();

                    me.next = function () {
                        var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
                        me.s0 = me.s1;
                        me.s1 = me.s2;
                        return me.s2 = t - (me.c = t | 0);
                    };

                    // Apply the seeding algorithm from Baagoe.
                    me.c = 1;
                    me.s0 = mash(' ');
                    me.s1 = mash(' ');
                    me.s2 = mash(' ');
                    me.s0 -= mash(seed);
                    if (me.s0 < 0) {
                        me.s0 += 1;
                    }
                    me.s1 -= mash(seed);
                    if (me.s1 < 0) {
                        me.s1 += 1;
                    }
                    me.s2 -= mash(seed);
                    if (me.s2 < 0) {
                        me.s2 += 1;
                    }
                    mash = null;
                }

                function copy(f, t) {
                    t.c = f.c;
                    t.s0 = f.s0;
                    t.s1 = f.s1;
                    t.s2 = f.s2;
                    return t;
                }

                function impl(seed, opts) {
                    var xg = new Alea(seed),
                        state = opts && opts.state,
                        prng = xg.next;
                    prng.int32 = function () {
                        return (xg.next() * 0x100000000) | 0;
                    }
                    prng.double = function () {
                        return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
                    };
                    prng.quick = prng;
                    if (state) {
                        if (typeof (state) == 'object') copy(state, xg);
                        prng.state = function () {
                            return copy(xg, {});
                        }
                    }
                    return prng;
                }

                function Mash() {
                    var n = 0xefc8249d;

                    var mash = function (data) {
                        data = data.toString();
                        for (var i = 0; i < data.length; i++) {
                            n += data.charCodeAt(i);
                            var h = 0.02519603282416938 * n;
                            n = h >>> 0;
                            h -= n;
                            h *= n;
                            n = h >>> 0;
                            h -= n;
                            n += h * 0x100000000; // 2^32
                        }
                        return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
                    };

                    return mash;
                }


                if (module && module.exports) {
                    module.exports = impl;
                } else if (define && define.amd) {
                    define(function () {
                        return impl;
                    });
                } else {
                    this.alea = impl;
                }

            })(
                this,
                (typeof module) == 'object' && module,    // present in node.js
                (typeof define) == 'function' && define   // present with an AMD loader
            );


        }, {}],
        4: [function (require, module, exports) {
// A Javascript implementaion of the "Tyche-i" prng algorithm by
// Samuel Neves and Filipe Araujo.
// See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf

            (function (global, module, define) {

                function XorGen(seed) {
                    var me = this, strseed = '';

                    // Set up generator function.
                    me.next = function () {
                        var b = me.b, c = me.c, d = me.d, a = me.a;
                        b = (b << 25) ^ (b >>> 7) ^ c;
                        c = (c - d) | 0;
                        d = (d << 24) ^ (d >>> 8) ^ a;
                        a = (a - b) | 0;
                        me.b = b = (b << 20) ^ (b >>> 12) ^ c;
                        me.c = c = (c - d) | 0;
                        me.d = (d << 16) ^ (c >>> 16) ^ a;
                        return me.a = (a - b) | 0;
                    };

                    /* The following is non-inverted tyche, which has better internal
   * bit diffusion, but which is about 25% slower than tyche-i in JS.
  me.next = function() {
    var a = me.a, b = me.b, c = me.c, d = me.d;
    a = (me.a + me.b | 0) >>> 0;
    d = me.d ^ a; d = d << 16 ^ d >>> 16;
    c = me.c + d | 0;
    b = me.b ^ c; b = b << 12 ^ d >>> 20;
    me.a = a = a + b | 0;
    d = d ^ a; me.d = d = d << 8 ^ d >>> 24;
    me.c = c = c + d | 0;
    b = b ^ c;
    return me.b = (b << 7 ^ b >>> 25);
  }
  */

                    me.a = 0;
                    me.b = 0;
                    me.c = 2654435769 | 0;
                    me.d = 1367130551;

                    if (seed === Math.floor(seed)) {
                        // Integer seed.
                        me.a = (seed / 0x100000000) | 0;
                        me.b = seed | 0;
                    } else {
                        // String seed.
                        strseed += seed;
                    }

                    // Mix in string seed, then discard an initial batch of 64 values.
                    for (var k = 0; k < strseed.length + 20; k++) {
                        me.b ^= strseed.charCodeAt(k) | 0;
                        me.next();
                    }
                }

                function copy(f, t) {
                    t.a = f.a;
                    t.b = f.b;
                    t.c = f.c;
                    t.d = f.d;
                    return t;
                }

                function impl(seed, opts) {
                    var xg = new XorGen(seed),
                        state = opts && opts.state,
                        prng = function () {
                            return (xg.next() >>> 0) / 0x100000000;
                        };
                    prng.double = function () {
                        do {
                            var top = xg.next() >>> 11,
                                bot = (xg.next() >>> 0) / 0x100000000,
                                result = (top + bot) / (1 << 21);
                        } while (result === 0);
                        return result;
                    };
                    prng.int32 = xg.next;
                    prng.quick = prng;
                    if (state) {
                        if (typeof (state) == 'object') copy(state, xg);
                        prng.state = function () {
                            return copy(xg, {});
                        }
                    }
                    return prng;
                }

                if (module && module.exports) {
                    module.exports = impl;
                } else if (define && define.amd) {
                    define(function () {
                        return impl;
                    });
                } else {
                    this.tychei = impl;
                }

            })(
                this,
                (typeof module) == 'object' && module,    // present in node.js
                (typeof define) == 'function' && define   // present with an AMD loader
            );


        }, {}],
        5: [function (require, module, exports) {
// A Javascript implementaion of the "xor128" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

            (function (global, module, define) {

                function XorGen(seed) {
                    var me = this, strseed = '';

                    me.x = 0;
                    me.y = 0;
                    me.z = 0;
                    me.w = 0;

                    // Set up generator function.
                    me.next = function () {
                        var t = me.x ^ (me.x << 11);
                        me.x = me.y;
                        me.y = me.z;
                        me.z = me.w;
                        return me.w ^= (me.w >>> 19) ^ t ^ (t >>> 8);
                    };

                    if (seed === (seed | 0)) {
                        // Integer seed.
                        me.x = seed;
                    } else {
                        // String seed.
                        strseed += seed;
                    }

                    // Mix in string seed, then discard an initial batch of 64 values.
                    for (var k = 0; k < strseed.length + 64; k++) {
                        me.x ^= strseed.charCodeAt(k) | 0;
                        me.next();
                    }
                }

                function copy(f, t) {
                    t.x = f.x;
                    t.y = f.y;
                    t.z = f.z;
                    t.w = f.w;
                    return t;
                }

                function impl(seed, opts) {
                    var xg = new XorGen(seed),
                        state = opts && opts.state,
                        prng = function () {
                            return (xg.next() >>> 0) / 0x100000000;
                        };
                    prng.double = function () {
                        do {
                            var top = xg.next() >>> 11,
                                bot = (xg.next() >>> 0) / 0x100000000,
                                result = (top + bot) / (1 << 21);
                        } while (result === 0);
                        return result;
                    };
                    prng.int32 = xg.next;
                    prng.quick = prng;
                    if (state) {
                        if (typeof (state) == 'object') copy(state, xg);
                        prng.state = function () {
                            return copy(xg, {});
                        }
                    }
                    return prng;
                }

                if (module && module.exports) {
                    module.exports = impl;
                } else if (define && define.amd) {
                    define(function () {
                        return impl;
                    });
                } else {
                    this.xor128 = impl;
                }

            })(
                this,
                (typeof module) == 'object' && module,    // present in node.js
                (typeof define) == 'function' && define   // present with an AMD loader
            );


        }, {}],
        6: [function (require, module, exports) {
// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.
//
// This fast non-cryptographic random number generator is designed for
// use in Monte-Carlo algorithms. It combines a long-period xorshift
// generator with a Weyl generator, and it passes all common batteries
// of stasticial tests for randomness while consuming only a few nanoseconds
// for each prng generated.  For background on the generator, see Brent's
// paper: "Some long-period random number generators using shifts and xors."
// http://arxiv.org/pdf/1004.3115v1.pdf
//
// Usage:
//
// var xor4096 = require('xor4096');
// random = xor4096(1);                        // Seed with int32 or string.
// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.
// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.
//
// For nonzero numeric keys, this impelementation provides a sequence
// identical to that by Brent's xorgens 3 implementaion in C.  This
// implementation also provides for initalizing the generator with
// string seeds, or for saving and restoring the state of the generator.
//
// On Chrome, this prng benchmarks about 2.1 times slower than
// Javascript's built-in Math.random().

            (function (global, module, define) {

                function XorGen(seed) {
                    var me = this;

                    // Set up generator function.
                    me.next = function () {
                        var w = me.w,
                            X = me.X, i = me.i, t, v;
                        // Update Weyl generator.
                        me.w = w = (w + 0x61c88647) | 0;
                        // Update xor generator.
                        v = X[(i + 34) & 127];
                        t = X[i = ((i + 1) & 127)];
                        v ^= v << 13;
                        t ^= t << 17;
                        v ^= v >>> 15;
                        t ^= t >>> 12;
                        // Update Xor generator array state.
                        v = X[i] = v ^ t;
                        me.i = i;
                        // Result is the combination.
                        return (v + (w ^ (w >>> 16))) | 0;
                    };

                    function init(me, seed) {
                        var t, v, i, j, w, X = [], limit = 128;
                        if (seed === (seed | 0)) {
                            // Numeric seeds initialize v, which is used to generates X.
                            v = seed;
                            seed = null;
                        } else {
                            // String seeds are mixed into v and X one character at a time.
                            seed = seed + '\0';
                            v = 0;
                            limit = Math.max(limit, seed.length);
                        }
                        // Initialize circular array and weyl value.
                        for (i = 0, j = -32; j < limit; ++j) {
                            // Put the unicode characters into the array, and shuffle them.
                            if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);
                            // After 32 shuffles, take v as the starting w value.
                            if (j === 0) w = v;
                            v ^= v << 10;
                            v ^= v >>> 15;
                            v ^= v << 4;
                            v ^= v >>> 13;
                            if (j >= 0) {
                                w = (w + 0x61c88647) | 0;     // Weyl.
                                t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.
                                i = (0 == t) ? i + 1 : 0;     // Count zeroes.
                            }
                        }
                        // We have detected all zeroes; make the key nonzero.
                        if (i >= 128) {
                            X[(seed && seed.length || 0) & 127] = -1;
                        }
                        // Run the generator 512 times to further mix the state before using it.
                        // Factoring this as a function slows the main generator, so it is just
                        // unrolled here.  The weyl generator is not advanced while warming up.
                        i = 127;
                        for (j = 4 * 128; j > 0; --j) {
                            v = X[(i + 34) & 127];
                            t = X[i = ((i + 1) & 127)];
                            v ^= v << 13;
                            t ^= t << 17;
                            v ^= v >>> 15;
                            t ^= t >>> 12;
                            X[i] = v ^ t;
                        }
                        // Storing state as object members is faster than using closure variables.
                        me.w = w;
                        me.X = X;
                        me.i = i;
                    }

                    init(me, seed);
                }

                function copy(f, t) {
                    t.i = f.i;
                    t.w = f.w;
                    t.X = f.X.slice();
                    return t;
                }

                function impl(seed, opts) {
                    if (seed == null) seed = +(new Date);
                    var xg = new XorGen(seed),
                        state = opts && opts.state,
                        prng = function () {
                            return (xg.next() >>> 0) / 0x100000000;
                        };
                    prng.double = function () {
                        do {
                            var top = xg.next() >>> 11,
                                bot = (xg.next() >>> 0) / 0x100000000,
                                result = (top + bot) / (1 << 21);
                        } while (result === 0);
                        return result;
                    };
                    prng.int32 = xg.next;
                    prng.quick = prng;
                    if (state) {
                        if (state.X) copy(state, xg);
                        prng.state = function () {
                            return copy(xg, {});
                        }
                    }
                    return prng;
                }

                if (module && module.exports) {
                    module.exports = impl;
                } else if (define && define.amd) {
                    define(function () {
                        return impl;
                    });
                } else {
                    this.xor4096 = impl;
                }

            })(
                this,                                     // window object or global
                (typeof module) == 'object' && module,    // present in node.js
                (typeof define) == 'function' && define   // present with an AMD loader
            );

        }, {}],
        7: [function (require, module, exports) {
// A Javascript implementaion of the "xorshift7" algorithm by
// François Panneton and Pierre L'ecuyer:
// "On the Xorgshift Random Number Generators"
// http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf

            (function (global, module, define) {

                function XorGen(seed) {
                    var me = this;

                    // Set up generator function.
                    me.next = function () {
                        // Update xor generator.
                        var X = me.x, i = me.i, t, v, w;
                        t = X[i];
                        t ^= (t >>> 7);
                        v = t ^ (t << 24);
                        t = X[(i + 1) & 7];
                        v ^= t ^ (t >>> 10);
                        t = X[(i + 3) & 7];
                        v ^= t ^ (t >>> 3);
                        t = X[(i + 4) & 7];
                        v ^= t ^ (t << 7);
                        t = X[(i + 7) & 7];
                        t = t ^ (t << 13);
                        v ^= t ^ (t << 9);
                        X[i] = v;
                        me.i = (i + 1) & 7;
                        return v;
                    };

                    function init(me, seed) {
                        var j, w, X = [];

                        if (seed === (seed | 0)) {
                            // Seed state array using a 32-bit integer.
                            w = X[0] = seed;
                        } else {
                            // Seed state using a string.
                            seed = '' + seed;
                            for (j = 0; j < seed.length; ++j) {
                                X[j & 7] = (X[j & 7] << 15) ^
                                    (seed.charCodeAt(j) + X[(j + 1) & 7] << 13);
                            }
                        }
                        // Enforce an array length of 8, not all zeroes.
                        while (X.length < 8) X.push(0);
                        for (j = 0; j < 8 && X[j] === 0; ++j) ;
                        if (j == 8) w = X[7] = -1; else w = X[j];

                        me.x = X;
                        me.i = 0;

                        // Discard an initial 256 values.
                        for (j = 256; j > 0; --j) {
                            me.next();
                        }
                    }

                    init(me, seed);
                }

                function copy(f, t) {
                    t.x = f.x.slice();
                    t.i = f.i;
                    return t;
                }

                function impl(seed, opts) {
                    if (seed == null) seed = +(new Date);
                    var xg = new XorGen(seed),
                        state = opts && opts.state,
                        prng = function () {
                            return (xg.next() >>> 0) / 0x100000000;
                        };
                    prng.double = function () {
                        do {
                            var top = xg.next() >>> 11,
                                bot = (xg.next() >>> 0) / 0x100000000,
                                result = (top + bot) / (1 << 21);
                        } while (result === 0);
                        return result;
                    };
                    prng.int32 = xg.next;
                    prng.quick = prng;
                    if (state) {
                        if (state.x) copy(state, xg);
                        prng.state = function () {
                            return copy(xg, {});
                        }
                    }
                    return prng;
                }

                if (module && module.exports) {
                    module.exports = impl;
                } else if (define && define.amd) {
                    define(function () {
                        return impl;
                    });
                } else {
                    this.xorshift7 = impl;
                }

            })(
                this,
                (typeof module) == 'object' && module,    // present in node.js
                (typeof define) == 'function' && define   // present with an AMD loader
            );


        }, {}],
        8: [function (require, module, exports) {
// A Javascript implementaion of the "xorwow" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

            (function (global, module, define) {

                function XorGen(seed) {
                    var me = this, strseed = '';

                    // Set up generator function.
                    me.next = function () {
                        var t = (me.x ^ (me.x >>> 2));
                        me.x = me.y;
                        me.y = me.z;
                        me.z = me.w;
                        me.w = me.v;
                        return (me.d = (me.d + 362437 | 0)) +
                            (me.v = (me.v ^ (me.v << 4)) ^ (t ^ (t << 1))) | 0;
                    };

                    me.x = 0;
                    me.y = 0;
                    me.z = 0;
                    me.w = 0;
                    me.v = 0;

                    if (seed === (seed | 0)) {
                        // Integer seed.
                        me.x = seed;
                    } else {
                        // String seed.
                        strseed += seed;
                    }

                    // Mix in string seed, then discard an initial batch of 64 values.
                    for (var k = 0; k < strseed.length + 64; k++) {
                        me.x ^= strseed.charCodeAt(k) | 0;
                        if (k == strseed.length) {
                            me.d = me.x << 10 ^ me.x >>> 4;
                        }
                        me.next();
                    }
                }

                function copy(f, t) {
                    t.x = f.x;
                    t.y = f.y;
                    t.z = f.z;
                    t.w = f.w;
                    t.v = f.v;
                    t.d = f.d;
                    return t;
                }

                function impl(seed, opts) {
                    var xg = new XorGen(seed),
                        state = opts && opts.state,
                        prng = function () {
                            return (xg.next() >>> 0) / 0x100000000;
                        };
                    prng.double = function () {
                        do {
                            var top = xg.next() >>> 11,
                                bot = (xg.next() >>> 0) / 0x100000000,
                                result = (top + bot) / (1 << 21);
                        } while (result === 0);
                        return result;
                    };
                    prng.int32 = xg.next;
                    prng.quick = prng;
                    if (state) {
                        if (typeof (state) == 'object') copy(state, xg);
                        prng.state = function () {
                            return copy(xg, {});
                        }
                    }
                    return prng;
                }

                if (module && module.exports) {
                    module.exports = impl;
                } else if (define && define.amd) {
                    define(function () {
                        return impl;
                    });
                } else {
                    this.xorwow = impl;
                }

            })(
                this,
                (typeof module) == 'object' && module,    // present in node.js
                (typeof define) == 'function' && define   // present with an AMD loader
            );


        }, {}],
        9: [function (require, module, exports) {
            /*
Copyright 2014 David Bau.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

            (function (pool, math) {
//
// The following constants are related to IEEE 754 limits.
//
                var global = this,
                    width = 256,        // each RC4 output is 0 <= x < 256
                    chunks = 6,         // at least six RC4 outputs for each double
                    digits = 52,        // there are 52 significant digits in a double
                    rngname = 'random', // rngname: name for Math.random and Math.seedrandom
                    startdenom = math.pow(width, chunks),
                    significance = math.pow(2, digits),
                    overflow = significance * 2,
                    mask = width - 1,
                    nodecrypto;         // node.js crypto module, initialized at the bottom.

//
// seedrandom()
// This is the seedrandom function described above.
//
                function seedrandom(seed, options, callback) {
                    var key = [];
                    options = (options == true) ? {entropy: true} : (options || {});

                    // Flatten the seed string or build one from local entropy if needed.
                    var shortseed = mixkey(flatten(
                        options.entropy ? [seed, tostring(pool)] :
                            (seed == null) ? autoseed() : seed, 3), key);

                    // Use the seed to initialize an ARC4 generator.
                    var arc4 = new ARC4(key);

                    // This function returns a random double in [0, 1) that contains
                    // randomness in every bit of the mantissa of the IEEE 754 value.
                    var prng = function () {
                        var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
                            d = startdenom,                 //   and denominator d = 2 ^ 48.
                            x = 0;                          //   and no 'extra last byte'.
                        while (n < significance) {          // Fill up all significant digits by
                            n = (n + x) * width;              //   shifting numerator and
                            d *= width;                       //   denominator and generating a
                            x = arc4.g(1);                    //   new least-significant-byte.
                        }
                        while (n >= overflow) {             // To avoid rounding up, before adding
                            n /= 2;                           //   last byte, shift everything
                            d /= 2;                           //   right using integer math until
                            x >>>= 1;                         //   we have exactly the desired bits.
                        }
                        return (n + x) / d;                 // Form the number within [0, 1).
                    };

                    prng.int32 = function () {
                        return arc4.g(4) | 0;
                    }
                    prng.quick = function () {
                        return arc4.g(4) / 0x100000000;
                    }
                    prng.double = prng;

                    // Mix the randomness into accumulated entropy.
                    mixkey(tostring(arc4.S), pool);

                    // Calling convention: what to return as a function of prng, seed, is_math.
                    return (options.pass || callback ||
                        function (prng, seed, is_math_call, state) {
                            if (state) {
                                // Load the arc4 state from the given state if it has an S array.
                                if (state.S) {
                                    copy(state, arc4);
                                }
                                // Only provide the .state method if requested via options.state.
                                prng.state = function () {
                                    return copy(arc4, {});
                                }
                            }

                            // If called as a method of Math (Math.seedrandom()), mutate
                            // Math.random because that is how seedrandom.js has worked since v1.0.
                            if (is_math_call) {
                                math[rngname] = prng;
                                return seed;
                            }

                                // Otherwise, it is a newer calling convention, so return the
                            // prng directly.
                            else return prng;
                        })(
                        prng,
                        shortseed,
                        'global' in options ? options.global : (this == math),
                        options.state);
                }

                math['seed' + rngname] = seedrandom;

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
                function ARC4(key) {
                    var t, keylen = key.length,
                        me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

                    // The empty key [] is treated as [0].
                    if (!keylen) {
                        key = [keylen++];
                    }

                    // Set up S using the standard key scheduling algorithm.
                    while (i < width) {
                        s[i] = i++;
                    }
                    for (i = 0; i < width; i++) {
                        s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
                        s[j] = t;
                    }

                    // The "g" method returns the next (count) outputs as one number.
                    (me.g = function (count) {
                        // Using instance members instead of closure state nearly doubles speed.
                        var t, r = 0,
                            i = me.i, j = me.j, s = me.S;
                        while (count--) {
                            t = s[i = mask & (i + 1)];
                            r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
                        }
                        me.i = i;
                        me.j = j;
                        return r;
                        // For robust unpredictability, the function call below automatically
                        // discards an initial batch of values.  This is called RC4-drop[256].
                        // See http://google.com/search?q=rsa+fluhrer+response&btnI
                    })(width);
                }

//
// copy()
// Copies internal state of ARC4 to or from a plain object.
//
                function copy(f, t) {
                    t.i = f.i;
                    t.j = f.j;
                    t.S = f.S.slice();
                    return t;
                }

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
                function flatten(obj, depth) {
                    var result = [], typ = (typeof obj), prop;
                    if (depth && typ == 'object') {
                        for (prop in obj) {
                            try {
                                result.push(flatten(obj[prop], depth - 1));
                            } catch (e) {
                            }
                        }
                    }
                    return (result.length ? result : typ == 'string' ? obj : obj + '\0');
                }

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
                function mixkey(seed, key) {
                    var stringseed = seed + '', smear, j = 0;
                    while (j < stringseed.length) {
                        key[mask & j] =
                            mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
                    }
                    return tostring(key);
                }

//
// autoseed()
// Returns an object for autoseeding, using window.crypto and Node crypto
// module if available.
//
                function autoseed() {
                    try {
                        var out;
                        if (nodecrypto && (out = nodecrypto.randomBytes)) {
                            // The use of 'out' to remember randomBytes makes tight minified code.
                            out = out(width);
                        } else {
                            out = new Uint8Array(width);
                            (global.crypto || global.msCrypto).getRandomValues(out);
                        }
                        return tostring(out);
                    } catch (e) {
                        var browser = global.navigator,
                            plugins = browser && browser.plugins;
                        return [+new Date, global, plugins, global.screen, tostring(pool)];
                    }
                }

//
// tostring()
// Converts an array of charcodes to a string
//
                function tostring(a) {
                    return String.fromCharCode.apply(0, a);
                }

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to interfere with deterministic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
                mixkey(math.random(), pool);

//
// Nodejs and AMD support: export the implementation as a module using
// either convention.
//
                if ((typeof module) == 'object' && module.exports) {
                    module.exports = seedrandom;
                    // When in node.js, try using crypto package for autoseeding.
                    try {
                        nodecrypto = require('crypto');
                    } catch (ex) {
                    }
                } else if ((typeof define) == 'function' && define.amd) {
                    define(function () {
                        return seedrandom;
                    });
                }

// End anonymous scope, and pass initial values.
            })(
                [],     // pool: entropy pool starts empty
                Math    // math: package containing random, pow, and seedrandom
            );

        }, {"crypto": 1}],
        10: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var ndarray_1 = require("../math/ndarray");
            var MANIFEST_FILE = 'manifest.json';
            var CheckpointLoader = (function () {
                function CheckpointLoader(urlPath) {
                    this.urlPath = urlPath;
                    if (this.urlPath.charAt(this.urlPath.length - 1) !== '/') {
                        this.urlPath += '/';
                    }
                }

                CheckpointLoader.prototype.loadManifest = function () {
                    var _this = this;
                    return new Promise(function (resolve, reject) {
                        var xhr = new XMLHttpRequest();
                        xhr.open('GET', _this.urlPath + MANIFEST_FILE);
                        xhr.onload = function () {
                            _this.checkpointManifest = JSON.parse(xhr.responseText);
                            resolve();
                        };
                        xhr.onerror = function (error) {
                            throw new Error(MANIFEST_FILE + " not found at " + _this.urlPath + ". " + error);
                        };
                        xhr.send();
                    });
                };
                CheckpointLoader.prototype.getCheckpointManifest = function () {
                    var _this = this;
                    if (this.checkpointManifest == null) {
                        return new Promise(function (resolve, reject) {
                            _this.loadManifest().then(function () {
                                resolve(_this.checkpointManifest);
                            });
                        });
                    }
                    return new Promise(function (resolve, reject) {
                        resolve(_this.checkpointManifest);
                    });
                };
                CheckpointLoader.prototype.getAllVariables = function () {
                    var _this = this;
                    if (this.variables != null) {
                        return new Promise(function (resolve, reject) {
                            resolve(_this.variables);
                        });
                    }
                    return new Promise(function (resolve, reject) {
                        _this.getCheckpointManifest().then(function (checkpointDefinition) {
                            var variableNames = Object.keys(_this.checkpointManifest);
                            var variablePromises = [];
                            for (var i = 0; i < variableNames.length; i++) {
                                variablePromises.push(_this.getVariable(variableNames[i]));
                            }
                            Promise.all(variablePromises).then(function (variables) {
                                _this.variables = {};
                                for (var i = 0; i < variables.length; i++) {
                                    _this.variables[variableNames[i]] = variables[i];
                                }
                                resolve(_this.variables);
                            });
                        });
                    });
                };
                CheckpointLoader.prototype.getVariable = function (varName) {
                    var _this = this;
                    if (!(varName in this.checkpointManifest)) {
                        throw new Error('Cannot load non-existant variable ' + varName);
                    }
                    var variableRequestPromiseMethod = function (resolve, reject) {
                        var xhr = new XMLHttpRequest();
                        xhr.responseType = 'arraybuffer';
                        var fname = _this.checkpointManifest[varName].filename;
                        xhr.open('GET', _this.urlPath + fname);
                        xhr.onload = function () {
                            if (xhr.status === 404) {
                                throw new Error("Not found variable " + varName);
                            }
                            var values = new Float32Array(xhr.response);
                            var ndarray = ndarray_1.NDArray.make(_this.checkpointManifest[varName].shape, {values: values});
                            resolve(ndarray);
                        };
                        xhr.onerror = function (error) {
                            throw new Error("Could not fetch variable " + varName + ": " + error);
                        };
                        xhr.send();
                    };
                    if (this.checkpointManifest == null) {
                        return new Promise(function (resolve, reject) {
                            _this.loadManifest().then(function () {
                                new Promise(variableRequestPromiseMethod).then(resolve);
                            });
                        });
                    }
                    return new Promise(variableRequestPromiseMethod);
                };
                return CheckpointLoader;
            }());
            exports.CheckpointLoader = CheckpointLoader;

        }, {"../math/ndarray": 95}],
        11: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var ndarray_1 = require("../math/ndarray");
            var util = require("../util");
            var STATS_SAMPLE_PERCENTAGE = 0.1;
            var InMemoryDataset = (function () {
                function InMemoryDataset(dataShapes, math) {
                    this.dataShapes = dataShapes;
                    this.math = math;
                    this.normalizationInfo = {};
                }

                InMemoryDataset.prototype.getDataShape = function (dataIndex) {
                    return this.dataShapes[dataIndex];
                };
                InMemoryDataset.prototype.getData = function () {
                    return this.dataset;
                };
                InMemoryDataset.prototype.getStats = function () {
                    var _this = this;
                    if (this.dataset == null) {
                        throw new Error('Data is null.');
                    }
                    return this.dataset.map(function (d) {
                        return _this.getStatsForData(d);
                    });
                };
                InMemoryDataset.prototype.getStatsForData = function (data) {
                    var inputMin = Number.POSITIVE_INFINITY;
                    var inputMax = Number.NEGATIVE_INFINITY;
                    var exampleIndices = data.map(function (example, i) {
                        return i;
                    });
                    util.shuffle(exampleIndices);
                    exampleIndices =
                        exampleIndices.slice(exampleIndices.length * STATS_SAMPLE_PERCENTAGE);
                    for (var i = 0; i < exampleIndices.length; i++) {
                        var inputValues = data[exampleIndices[i]].getValues();
                        for (var j = 0; j < inputValues.length; j++) {
                            inputMin = Math.min(inputMin, inputValues[j]);
                            inputMax = Math.max(inputMax, inputValues[j]);
                        }
                    }
                    return {
                        inputMin: inputMin,
                        inputMax: inputMax,
                        exampleCount: data.length,
                        shape: data[0].shape,
                    };
                };
                InMemoryDataset.prototype.normalizeExamplesToRange = function (examples, curLowerBounds, curUpperBounds, newLowerBounds, newUpperBounds) {
                    var _this = this;
                    var curBoundsIsPerDimension = (curUpperBounds instanceof Float32Array &&
                        curLowerBounds instanceof Float32Array);
                    var newBoundsIsPerDimension = (newLowerBounds instanceof Float32Array &&
                        newUpperBounds instanceof Float32Array);
                    var inputSize = util.sizeFromShape(examples[0].shape);
                    var newExamples = [];
                    examples.forEach(function (example) {
                        var inputValues = example.getValues();
                        var normalizedValues = new Float32Array(inputSize);
                        for (var j = 0; j < inputSize; j++) {
                            var curLowerBound = curBoundsIsPerDimension ?
                                curLowerBounds[j] :
                                curLowerBounds;
                            var curUpperBound = curBoundsIsPerDimension ?
                                curUpperBounds[j] :
                                curUpperBounds;
                            var curRange = curUpperBound - curLowerBound;
                            var newLowerBound = newBoundsIsPerDimension ?
                                newLowerBounds[j] :
                                newLowerBounds;
                            var newUpperBound = newBoundsIsPerDimension ?
                                newUpperBounds[j] :
                                newUpperBounds;
                            var newRange = newUpperBound - newLowerBound;
                            if (curRange === 0) {
                                normalizedValues[j] = newLowerBound;
                            } else {
                                normalizedValues[j] = newLowerBound +
                                    newRange * (inputValues[j] - curLowerBound) / curRange;
                            }
                        }
                        newExamples.push(ndarray_1.NDArray.make(example.shape, {values: normalizedValues}, 'float32', _this.math));
                    });
                    return newExamples;
                };
                InMemoryDataset.prototype.computeBounds = function (dataIndex) {
                    var _this = this;
                    if (this.dataset == null) {
                        throw new Error('Data is null.');
                    }
                    var size = util.sizeFromShape(this.dataset[dataIndex][0].shape);
                    this.normalizationInfo[dataIndex] = {
                        isNormalized: false,
                        minValues: new Float32Array(size),
                        maxValues: new Float32Array(size)
                    };
                    for (var i = 0; i < size; i++) {
                        this.normalizationInfo[dataIndex].minValues[i] = Number.POSITIVE_INFINITY;
                        this.normalizationInfo[dataIndex].maxValues[i] = Number.NEGATIVE_INFINITY;
                    }
                    this.dataset[dataIndex].forEach(function (example) {
                        var inputValues = example.getValues();
                        for (var k = 0; k < size; k++) {
                            _this.normalizationInfo[dataIndex].minValues[k] = Math.min(_this.normalizationInfo[dataIndex].minValues[k], inputValues[k]);
                            _this.normalizationInfo[dataIndex].maxValues[k] = Math.max(_this.normalizationInfo[dataIndex].maxValues[k], inputValues[k]);
                        }
                    });
                };
                InMemoryDataset.prototype.normalizeWithinBounds = function (dataIndex, lowerBound, upperBound) {
                    if (this.dataset == null) {
                        throw new Error('Data is null.');
                    }
                    if (dataIndex >= this.dataset.length) {
                        throw new Error('dataIndex out of bounds.');
                    }
                    if (this.normalizationInfo[dataIndex] == null) {
                        this.computeBounds(dataIndex);
                    }
                    var curLowerBounds;
                    var curUpperBounds;
                    if (this.normalizationInfo[dataIndex].isNormalized) {
                        curLowerBounds = this.normalizationInfo[dataIndex].lowerBound;
                        curUpperBounds = this.normalizationInfo[dataIndex].upperBound;
                    } else {
                        curLowerBounds = this.normalizationInfo[dataIndex].minValues;
                        curUpperBounds = this.normalizationInfo[dataIndex].maxValues;
                    }
                    this.dataset[dataIndex] = this.normalizeExamplesToRange(this.dataset[dataIndex], curLowerBounds, curUpperBounds, lowerBound, upperBound);
                    this.normalizationInfo[dataIndex].isNormalized = true;
                    this.normalizationInfo[dataIndex].lowerBound = lowerBound;
                    this.normalizationInfo[dataIndex].upperBound = upperBound;
                };
                InMemoryDataset.prototype.isNormalized = function (dataIndex) {
                    return this.normalizationInfo != null &&
                        this.normalizationInfo[dataIndex].isNormalized;
                };
                InMemoryDataset.prototype.removeNormalization = function (dataIndex) {
                    if (this.dataset == null) {
                        throw new Error('Training or test data is null.');
                    }
                    if (!this.isNormalized(dataIndex)) {
                        return;
                    }
                    this.dataset[dataIndex] = this.normalizeExamplesToRange(this.dataset[dataIndex], this.normalizationInfo[dataIndex].lowerBound, this.normalizationInfo[dataIndex].upperBound, this.normalizationInfo[dataIndex].minValues, this.normalizationInfo[dataIndex].maxValues);
                    this.normalizationInfo[dataIndex].isNormalized = false;
                };
                InMemoryDataset.prototype.unnormalizeExamples = function (examples, dataIndex) {
                    if (!this.isNormalized(dataIndex)) {
                        return examples;
                    }
                    return this.normalizeExamplesToRange(examples, this.normalizationInfo[dataIndex].lowerBound, this.normalizationInfo[dataIndex].upperBound, this.normalizationInfo[dataIndex].minValues, this.normalizationInfo[dataIndex].maxValues);
                };
                InMemoryDataset.prototype.dispose = function () {
                    if (this.dataset == null) {
                        return;
                    }
                    for (var i = 0; i < this.dataset.length; i++) {
                        for (var j = 0; j < this.dataset[i].length; j++) {
                            this.dataset[i][j].dispose();
                        }
                    }
                    this.dataset = [];
                };
                return InMemoryDataset;
            }());
            exports.InMemoryDataset = InMemoryDataset;

        }, {"../math/ndarray": 95, "../util": 101}],
        12: [function (require, module, exports) {
            "use strict";
            var __extends = (this && this.__extends) || (function () {
                var extendStatics = Object.setPrototypeOf ||
                    ({__proto__: []} instanceof Array && function (d, b) {
                        d.__proto__ = b;
                    }) ||
                    function (d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                    };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d;
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            })();
            Object.defineProperty(exports, "__esModule", {value: true});
            var ndarray_1 = require("../math/ndarray");
            var util = require("../util");
            var InMemoryShuffledInputProviderBuilder = (function () {
                function InMemoryShuffledInputProviderBuilder(inputs) {
                    this.inputs = inputs;
                    this.idx = 0;
                    this.inputCounter = 0;
                    this.epoch = 0;
                    this.shuffledIndices = util.createShuffledIndices(inputs[0].length);
                    this.numInputs = inputs.length;
                    var numExamples = this.inputs[0].length;
                    for (var i = 0; i < this.numInputs; i++) {
                        util.assert(this.inputs[i].length === numExamples, 'Number of examples must match across different inputs.');
                    }
                    for (var i = 0; i < this.numInputs; i++) {
                        var inputShape = this.inputs[i][0].shape;
                        for (var j = 0; j < this.inputs[i].length; j++) {
                            util.assertShapesMatch(inputShape, this.inputs[i][j].shape);
                        }
                    }
                }

                InMemoryShuffledInputProviderBuilder.prototype.getCurrentExampleIndex = function () {
                    var returnIdx = this.idx;
                    this.inputCounter++;
                    if (this.inputCounter >= this.numInputs) {
                        this.idx++;
                        this.inputCounter = 0;
                        if (this.idx >= this.inputs[0].length) {
                            this.idx = 0;
                            this.epoch++;
                        }
                    }
                    return returnIdx;
                };
                InMemoryShuffledInputProviderBuilder.prototype.getNextInput = function (inputId) {
                    var currentExampleIndex = this.getCurrentExampleIndex();
                    return this.inputs[inputId][this.shuffledIndices[currentExampleIndex]];
                };
                InMemoryShuffledInputProviderBuilder.prototype.getEpoch = function () {
                    return this.epoch;
                };
                InMemoryShuffledInputProviderBuilder.prototype.getInputProviders = function () {
                    var inputProviders = [];
                    for (var i = 0; i < this.numInputs; i++) {
                        inputProviders.push(this.getInputProvider(i));
                    }
                    return inputProviders;
                };
                return InMemoryShuffledInputProviderBuilder;
            }());
            exports.InMemoryShuffledInputProviderBuilder = InMemoryShuffledInputProviderBuilder;
            var InCPUMemoryShuffledInputProviderBuilder = (function (_super) {
                __extends(InCPUMemoryShuffledInputProviderBuilder, _super);

                function InCPUMemoryShuffledInputProviderBuilder() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }

                InCPUMemoryShuffledInputProviderBuilder.prototype.getInputProvider = function (inputId) {
                    var shuffledInputProvider = this;
                    return {
                        getNextCopy: function (math) {
                            return ndarray_1.NDArray.like(shuffledInputProvider.getNextInput(inputId));
                        },
                        disposeCopy: function (math, copy) {
                            copy.dispose();
                        }
                    };
                };
                return InCPUMemoryShuffledInputProviderBuilder;
            }(InMemoryShuffledInputProviderBuilder));
            exports.InCPUMemoryShuffledInputProviderBuilder = InCPUMemoryShuffledInputProviderBuilder;
            var InGPUMemoryShuffledInputProviderBuilder = (function (_super) {
                __extends(InGPUMemoryShuffledInputProviderBuilder, _super);

                function InGPUMemoryShuffledInputProviderBuilder() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }

                InGPUMemoryShuffledInputProviderBuilder.prototype.getInputProvider = function (inputId) {
                    var shuffledInputProvider = this;
                    return {
                        getNextCopy: function (math) {
                            return math.clone(shuffledInputProvider.getNextInput(inputId));
                        },
                        disposeCopy: function (math, copy) {
                            copy.dispose();
                        }
                    };
                };
                return InGPUMemoryShuffledInputProviderBuilder;
            }(InMemoryShuffledInputProviderBuilder));
            exports.InGPUMemoryShuffledInputProviderBuilder = InGPUMemoryShuffledInputProviderBuilder;

        }, {"../math/ndarray": 95, "../util": 101}],
        13: [function (require, module, exports) {
            "use strict";
            var __extends = (this && this.__extends) || (function () {
                var extendStatics = Object.setPrototypeOf ||
                    ({__proto__: []} instanceof Array && function (d, b) {
                        d.__proto__ = b;
                    }) ||
                    function (d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                    };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d;
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            })();
            Object.defineProperty(exports, "__esModule", {value: true});
            var math_1 = require("../math/math");
            var ndarray_1 = require("../math/ndarray");
            var util = require("../util");
            var dataset_1 = require("./dataset");
            var PARSING_IMAGE_CANVAS_HEIGHT_PX = 1000;

            function getXhrDatasetConfig(jsonConfigPath) {
                return new Promise(function (resolve, reject) {
                    var xhr = new XMLHttpRequest();
                    xhr.open('GET', jsonConfigPath);
                    xhr.onload = function () {
                        resolve(JSON.parse(xhr.responseText));
                    };
                    xhr.onerror = function (error) {
                        reject(error);
                    };
                    xhr.send();
                });
            }

            exports.getXhrDatasetConfig = getXhrDatasetConfig;
            var XhrDataset = (function (_super) {
                __extends(XhrDataset, _super);

                function XhrDataset(xhrDatasetConfig) {
                    var _this = this;
                    var safeMode = false;
                    _this = _super.call(this, xhrDatasetConfig.data.map(function (x) {
                        return x.shape;
                    }), new math_1.NDArrayMath('cpu', safeMode)) || this;
                    _this.xhrDatasetConfig = xhrDatasetConfig;
                    return _this;
                }

                XhrDataset.prototype.getNDArray = function (info) {
                    var _this = this;
                    var dataPromise = info.dataType === 'png' ?
                        parseTypedArrayFromPng(info, info.shape) :
                        parseTypedArrayFromBinary(info);
                    var inputSize = util.sizeFromShape(info.shape);
                    return dataPromise.then(function (data) {
                        var ndarrays = [];
                        for (var i = 0; i < data.length / inputSize; i++) {
                            var values = data.subarray(i * inputSize, (i + 1) * inputSize);
                            var ndarray = ndarray_1.NDArray.make(info.shape, {values: new Float32Array(values)}, 'float32', _this.math);
                            ndarrays.push(ndarray);
                        }
                        return ndarrays;
                    });
                };
                XhrDataset.prototype.fetchData = function () {
                    var _this = this;
                    return new Promise(function (resolve, reject) {
                        var promises = _this.xhrDatasetConfig.data.map(function (x) {
                            return _this.getNDArray(x);
                        });
                        Promise.all(promises).then(function (data) {
                            _this.dataset = data;
                            resolve();
                        });
                    });
                };
                return XhrDataset;
            }(dataset_1.InMemoryDataset));
            exports.XhrDataset = XhrDataset;

            function parseTypedArrayFromBinary(info) {
                return new Promise(function (resolve, reject) {
                    var xhr = new XMLHttpRequest();
                    xhr.open('GET', info.path);
                    xhr.responseType = 'arraybuffer';
                    xhr.onload = function (event) {
                        var data = (info.dataType === 'float32') ?
                            new Float32Array(xhr.response) :
                            new Uint8Array(xhr.response);
                        resolve(data);
                    };
                    xhr.onerror = function (err) {
                        return reject(err);
                    };
                    xhr.send();
                });
            }

            function parseGrayscaleImageData(data, result, resultOffset) {
                var idx = resultOffset;
                for (var i = 0; i < data.length; i += 4) {
                    result[idx++] = data[i];
                }
            }

            function parseRGBImageData(data, result, resultOffset) {
                var idx = resultOffset;
                for (var i = 0; i < data.length; i += 4) {
                    result[idx] = data[i];
                    result[idx + 1] = data[i + 1];
                    result[idx + 2] = data[i + 2];
                    idx += 3;
                }
            }

            function parseImage(img, shape) {
                var canvas = document.createElement('canvas');
                var ctx = canvas.getContext('2d');
                var N = img.height;
                var inputSize = util.sizeFromShape(shape);
                var result = new Uint8Array(N * inputSize);
                if (img.width !== shape[0] * shape[1]) {
                    throw new Error("Image width (" + img.width + ") must be multiple of " +
                        ("rows*columns (" + shape[0] + "*" + shape[1] + ") of the ndarray"));
                }
                canvas.width = img.width;
                canvas.height = PARSING_IMAGE_CANVAS_HEIGHT_PX;
                var sx = 0;
                var sWidth = canvas.width;
                var sHeight = canvas.height;
                var dx = 0;
                var dy = 0;
                var dWidth = sWidth;
                var dHeight = sHeight;
                var depth = shape[2];
                var offset = 0;
                var numPasses = Math.ceil(N / canvas.height);
                for (var pass = 0; pass < numPasses; ++pass) {
                    var sy = pass * canvas.height;
                    if ((pass === numPasses - 1) && (N % canvas.height > 0)) {
                        canvas.height = N % canvas.height;
                        sHeight = canvas.height;
                        dHeight = sHeight;
                    }
                    ctx.drawImage(img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
                    var data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
                    (depth === 1) ? parseGrayscaleImageData(data, result, offset) :
                        parseRGBImageData(data, result, offset);
                    offset += canvas.height * inputSize;
                }
                return result;
            }

            function parseTypedArrayFromPng(info, shape) {
                return new Promise(function (resolve, reject) {
                    var img = new Image();
                    img.setAttribute('crossOrigin', '');
                    img.onload = function () {
                        var result = parseImage(img, shape);
                        img.src = '';
                        img = null;
                        resolve(result);
                    };
                    img.src = info.path;
                });
            }

        }, {"../math/math": 94, "../math/ndarray": 95, "../util": 101, "./dataset": 11}],
        14: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});

            function isMobile() {
                var a = navigator.userAgent || navigator.vendor || window.opera;
                return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i
                        .test(a) ||
                    /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i
                        .test(a.substr(0, 4));
            }

            exports.isMobile = isMobile;

        }, {}],
        15: [function (require, module, exports) {
            (function (global) {
                "use strict";
                Object.defineProperty(exports, "__esModule", {value: true});
                var device_util = require("./device_util");
                var math_1 = require("./math/math");
                var util = require("./util");
                var Type;
                (function (Type) {
                    Type[Type["NUMBER"] = 0] = "NUMBER";
                    Type[Type["BOOLEAN"] = 1] = "BOOLEAN";
                })(Type = exports.Type || (exports.Type = {}));
                exports.URL_PROPERTIES = [
                    {name: 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_ENABLED', type: Type.BOOLEAN},
                    {name: 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE', type: Type.BOOLEAN},
                    {name: 'WEBGL_VERSION', type: Type.NUMBER},
                    {name: 'WEBGL_FLOAT_TEXTURE_ENABLED', type: Type.BOOLEAN}, {
                        name: 'WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED',
                        type: Type.BOOLEAN
                    }
                ];

                function getWebGLRenderingContext(webGLVersion) {
                    if (webGLVersion === 0) {
                        throw new Error('Cannot get WebGL rendering context, WebGL is disabled.');
                    }
                    var tempCanvas = document.createElement('canvas');
                    if (webGLVersion === 1) {
                        return (tempCanvas.getContext('webgl') ||
                            tempCanvas.getContext('experimental-webgl'));
                    }
                    return tempCanvas.getContext('webgl2');
                }

                function loseContext(gl) {
                    if (gl != null) {
                        var loseContextExtension = gl.getExtension('WEBGL_lose_context');
                        if (loseContextExtension == null) {
                            throw new Error('Extension WEBGL_lose_context not supported on this browser.');
                        }
                        loseContextExtension.loseContext();
                    }
                }

                function isWebGLVersionEnabled(webGLVersion) {
                    var gl = getWebGLRenderingContext(webGLVersion);
                    if (gl != null) {
                        loseContext(gl);
                        return true;
                    }
                    return false;
                }

                function isWebGLDisjointQueryTimerEnabled(webGLVersion) {
                    var gl = getWebGLRenderingContext(webGLVersion);
                    var extensionName = webGLVersion === 1 ? 'EXT_disjoint_timer_query' :
                        'EXT_disjoint_timer_query_webgl2';
                    var ext = gl.getExtension(extensionName);
                    var isExtEnabled = ext != null;
                    if (gl != null) {
                        loseContext(gl);
                    }
                    return isExtEnabled;
                }

                function isFloatTextureReadPixelsEnabled(webGLVersion) {
                    if (webGLVersion === 0) {
                        return false;
                    }
                    var gl = getWebGLRenderingContext(webGLVersion);
                    if (webGLVersion === 1) {
                        if (gl.getExtension('OES_texture_float') == null) {
                            return false;
                        }
                    } else {
                        if (gl.getExtension('EXT_color_buffer_float') == null) {
                            return false;
                        }
                    }
                    var frameBuffer = gl.createFramebuffer();
                    var texture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    var internalFormat = webGLVersion === 2 ? gl.RGBA32F : gl.RGBA;
                    gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 1, 1, 0, gl.RGBA, gl.FLOAT, null);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
                    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
                    var frameBufferComplete = (gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE);
                    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.FLOAT, new Float32Array(4));
                    var readPixelsNoError = gl.getError() === gl.NO_ERROR;
                    loseContext(gl);
                    return frameBufferComplete && readPixelsNoError;
                }

                function isWebGLGetBufferSubDataAsyncExtensionEnabled(webGLVersion) {
                    if (webGLVersion !== 2) {
                        return false;
                    }
                    var gl = getWebGLRenderingContext(webGLVersion);
                    var ext = gl.getExtension('WEBGL_get_buffer_sub_data_async');
                    var isEnabled = ext != null;
                    loseContext(gl);
                    return isEnabled;
                }

                var Environment = (function () {
                    function Environment(features) {
                        this.features = {};
                        this.globalMath = null;
                        this.backendRegistry = {};
                        this.prevBackendRegistry = this.backendRegistry;
                        if (features != null) {
                            this.features = features;
                        }
                    }

                    Environment.prototype.get = function (feature) {
                        if (feature in this.features) {
                            return this.features[feature];
                        }
                        this.features[feature] = this.evaluateFeature(feature);
                        return this.features[feature];
                    };
                    Environment.prototype.getBestBackend = function () {
                        var orderedBackends = ['webgl', 'cpu'];
                        for (var i = 0; i < orderedBackends.length; ++i) {
                            var backendId = orderedBackends[i];
                            if (backendId in this.backendRegistry) {
                                return this.backendRegistry[backendId];
                            }
                        }
                        throw new Error('No backend found in registry.');
                    };
                    Environment.prototype.evaluateFeature = function (feature) {
                        if (feature === 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_ENABLED') {
                            var webGLVersion = this.get('WEBGL_VERSION');
                            if (webGLVersion === 0) {
                                return false;
                            }
                            return isWebGLDisjointQueryTimerEnabled(webGLVersion);
                        } else if (feature === 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') {
                            return this.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_ENABLED') &&
                                !device_util.isMobile();
                        } else if (feature === 'WEBGL_VERSION') {
                            if (isWebGLVersionEnabled(2)) {
                                return 2;
                            } else if (isWebGLVersionEnabled(1)) {
                                return 1;
                            }
                            return 0;
                        } else if (feature === 'WEBGL_FLOAT_TEXTURE_ENABLED') {
                            return isFloatTextureReadPixelsEnabled(this.get('WEBGL_VERSION'));
                        } else if (feature === 'WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED') {
                            return isWebGLGetBufferSubDataAsyncExtensionEnabled(this.get('WEBGL_VERSION'));
                        }
                        throw new Error("Unknown feature " + feature + ".");
                    };
                    Environment.prototype.setFeatures = function (features) {
                        this.empty();
                        this.features = features;
                    };
                    Environment.prototype.reset = function () {
                        this.globalMath = null;
                        this.backendRegistry = this.prevBackendRegistry;
                        this.features = getFeaturesFromURL();
                    };
                    Environment.prototype.setMath = function (math) {
                        this.globalMath = math;
                    };
                    Environment.prototype.getBackend = function (name) {
                        return this.backendRegistry[name];
                    };
                    Environment.prototype.registerBackend = function (name, factory) {
                        if (name in this.backendRegistry) {
                            throw new Error(name + " backend was already registered");
                        }
                        try {
                            var backend = factory();
                            this.backendRegistry[name] = backend;
                            return true;
                        } catch (err) {
                            return false;
                        }
                    };
                    Object.defineProperty(Environment.prototype, "math", {
                        get: function () {
                            if (this.globalMath == null) {
                                var bestBackend = this.getBestBackend();
                                var safeMode = false;
                                this.globalMath = new math_1.NDArrayMath(bestBackend, safeMode);
                            }
                            return this.globalMath;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Environment.prototype.empty = function () {
                        this.globalMath = null;
                        this.prevBackendRegistry = this.backendRegistry;
                        this.backendRegistry = {};
                        this.features = null;
                    };
                    return Environment;
                }());
                exports.Environment = Environment;
                var DEEPLEARNJS_FLAGS_PREFIX = 'dljsflags';

                function getFeaturesFromURL() {
                    var features = {};
                    if (typeof window === 'undefined') {
                        return features;
                    }
                    var urlParams = util.getQueryParams(window.location.search);
                    if (DEEPLEARNJS_FLAGS_PREFIX in urlParams) {
                        var urlFlags_1 = {};
                        var keyValues = urlParams[DEEPLEARNJS_FLAGS_PREFIX].split(',');
                        keyValues.forEach(function (keyValue) {
                            var _a = keyValue.split(':'), key = _a[0], value = _a[1];
                            urlFlags_1[key] = value;
                        });
                        exports.URL_PROPERTIES.forEach(function (urlProperty) {
                            if (urlProperty.name in urlFlags_1) {
                                console.log("Setting feature override from URL " + urlProperty.name + ": " +
                                    ("" + urlFlags_1[urlProperty.name]));
                                if (urlProperty.type === Type.NUMBER) {
                                    features[urlProperty.name] = +urlFlags_1[urlProperty.name];
                                } else if (urlProperty.type === Type.BOOLEAN) {
                                    features[urlProperty.name] = urlFlags_1[urlProperty.name] === 'true';
                                } else {
                                    console.warn("Unknown URL param: " + urlProperty.name + ".");
                                }
                            }
                        });
                    }
                    return features;
                }

                function getGlobalNamespace() {
                    var ns;
                    if (typeof (window) !== 'undefined') {
                        ns = window;
                    } else if (typeof (global) !== 'undefined') {
                        ns = global;
                    } else {
                        throw new Error('Could not find a global object');
                    }
                    return ns;
                }

                function getOrMakeEnvironment() {
                    var ns = getGlobalNamespace();
                    ns.ENV = ns.ENV || new Environment(getFeaturesFromURL());
                    return ns.ENV;
                }

                exports.ENV = getOrMakeEnvironment();

            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
        }, {"./device_util": 14, "./math/math": 94, "./util": 101}],
        16: [function (require, module, exports) {
            "use strict";
            var __extends = (this && this.__extends) || (function () {
                var extendStatics = Object.setPrototypeOf ||
                    ({__proto__: []} instanceof Array && function (d, b) {
                        d.__proto__ = b;
                    }) ||
                    function (d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                    };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d;
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            })();
            Object.defineProperty(exports, "__esModule", {value: true});
            var initializers_1 = require("../initializers");
            var concat_util = require("../math/concat_util");
            var conv_util = require("../math/conv_util");
            var ndarray_1 = require("../math/ndarray");
            var util = require("../util");
            var GraphLayers = (function () {
                function GraphLayers(g) {
                    this.g = g;
                }

                GraphLayers.prototype.dense = function (name, x, units, activation, useBias, kernelInitializer, biasInitializer) {
                    if (activation === void 0) {
                        activation = null;
                    }
                    if (useBias === void 0) {
                        useBias = true;
                    }
                    if (kernelInitializer === void 0) {
                        kernelInitializer = new initializers_1.VarianceScalingInitializer();
                    }
                    if (biasInitializer === void 0) {
                        biasInitializer = new initializers_1.ZerosInitializer();
                    }
                    var weights = this.g.variable(name + '-weights', kernelInitializer.initialize([x.shape[0], units], x.shape[0], units));
                    var out = this.g.matmul(x, weights);
                    if (useBias) {
                        var bias = this.g.variable(name + '-bias', biasInitializer.initialize([units], x.shape[0], units));
                        out = this.g.add(out, bias);
                    }
                    if (activation != null) {
                        out = activation(out);
                    }
                    return out;
                };
                return GraphLayers;
            }());
            exports.GraphLayers = GraphLayers;
            var Graph = (function () {
                function Graph() {
                    this.nodes = [];
                    this.layers = new GraphLayers(this);
                }

                Graph.prototype.variable = function (name, data) {
                    return this.addNodeAndReturnOutput(new VariableNode(this, name, data));
                };
                Graph.prototype.placeholder = function (name, shape) {
                    return this.addNodeAndReturnOutput(new PlaceholderNode(this, name, shape));
                };
                Graph.prototype.constant = function (value) {
                    var finalValue;
                    if (typeof value === 'number') {
                        finalValue = ndarray_1.Scalar.new(value);
                    } else if (value instanceof ndarray_1.NDArray) {
                        finalValue = value;
                    } else if (value instanceof Array) {
                        var flatValues = util.flatten(value);
                        var vals = new Float32Array(flatValues);
                        finalValue = ndarray_1.NDArray.make(util.inferShape(value), {values: vals});
                    } else {
                        throw new Error('unimplemented constant type.');
                    }
                    return this.addNodeAndReturnOutput(new ConstantNode(this, finalValue));
                };
                Graph.prototype.reshape = function (x, shape) {
                    return this.addNodeAndReturnOutput(new ReshapeNode(this, 'Reshape', x, shape));
                };
                Graph.prototype.fusedLinearCombination = function (x1, x2, c1, c2) {
                    return this.addNodeAndReturnOutput(new FusedLinearCombinationNode(this, x1, x2, c1, c2));
                };
                Graph.prototype.add = function (x1, x2) {
                    return this.addNodeAndReturnOutput(new AddNode(this, x1, x2));
                };
                Graph.prototype.subtract = function (x1, x2) {
                    return this.addNodeAndReturnOutput(new SubtractNode(this, x1, x2));
                };
                Graph.prototype.multiply = function (x1, x2) {
                    return this.addNodeAndReturnOutput(new MultiplyNode(this, x1, x2));
                };
                Graph.prototype.divide = function (x1, x2) {
                    return this.addNodeAndReturnOutput(new DivideNode(this, x1, x2));
                };
                Graph.prototype.reduceSum = function (x) {
                    return this.addNodeAndReturnOutput(new ReduceSumNode(this, x));
                };
                Graph.prototype.concat3d = function (x1, x2, axis) {
                    return this.addNodeAndReturnOutput(new Concat3DNode(this, x1, x2, axis));
                };
                Graph.prototype.matmul = function (x1, x2) {
                    return this.addNodeAndReturnOutput(new MatMulNode(this, x1, x2));
                };
                Graph.prototype.conv2d = function (x, w, b, fieldSize, outputDepth, stride, zeroPad) {
                    if (stride === void 0) {
                        stride = 1;
                    }
                    return this.addNodeAndReturnOutput(new Convolution2DNode(this, x, w, b, fieldSize, outputDepth, stride, zeroPad));
                };
                Graph.prototype.maxPool = function (x, fieldSize, stride, zeroPad) {
                    if (stride === void 0) {
                        stride = 1;
                    }
                    return this.addNodeAndReturnOutput(new MaxPoolNode(this, x, fieldSize, stride, zeroPad));
                };
                Graph.prototype.exp = function (x) {
                    return this.addNodeAndReturnOutput(new ExpNode(this, x));
                };
                Graph.prototype.log = function (x) {
                    return this.addNodeAndReturnOutput(new LogNode(this, x));
                };
                Graph.prototype.relu = function (x) {
                    return this.addNodeAndReturnOutput(new ReLUNode(this, x));
                };
                Graph.prototype.leakyRelu = function (x, alpha) {
                    return this.addNodeAndReturnOutput(new LeakyReLUNode(this, x, alpha));
                };
                Graph.prototype.prelu = function (x, alpha) {
                    return this.addNodeAndReturnOutput(new PReLUNode(this, x, alpha));
                };
                Graph.prototype.elu = function (x) {
                    return this.addNodeAndReturnOutput(new EluNode(this, x));
                };
                Graph.prototype.tanh = function (x) {
                    return this.addNodeAndReturnOutput(new TanHNode(this, x));
                };
                Graph.prototype.sigmoid = function (x) {
                    return this.addNodeAndReturnOutput(new SigmoidNode(this, x));
                };
                Graph.prototype.square = function (x) {
                    return this.addNodeAndReturnOutput(new SquareNode(this, x));
                };
                Graph.prototype.softmax = function (x) {
                    return this.addNodeAndReturnOutput(new SoftmaxNode(this, x));
                };
                Graph.prototype.softmaxCrossEntropyCost = function (x, target) {
                    return this.addNodeAndReturnOutput(new SoftmaxCrossEntropyCostNode(this, x, target));
                };
                Graph.prototype.meanSquaredCost = function (label, prediction) {
                    return this.addNodeAndReturnOutput(new MeanSquaredCostNode(this, label, prediction));
                };
                Graph.prototype.argmax = function (x) {
                    return this.addNodeAndReturnOutput(new ArgMaxNode(this, x));
                };
                Graph.prototype.argmaxEquals = function (x1, x2) {
                    return this.addNodeAndReturnOutput(new ArgMaxEqualsNode(this, x1, x2));
                };
                Graph.prototype.addNodeAndReturnOutput = function (node) {
                    this.nodes.push(node);
                    node.validate();
                    return node.output;
                };
                Graph.prototype.getNodes = function () {
                    return this.nodes;
                };
                return Graph;
            }());
            exports.Graph = Graph;
            var Tensor = (function () {
                function Tensor(shape) {
                    this.shape = shape;
                    this.id = Tensor.nextID++;
                }

                Tensor.nextID = 0;
                return Tensor;
            }());
            exports.Tensor = Tensor;
            var Node = (function () {
                function Node(graph, name, inputs, output) {
                    this.graph = graph;
                    this.name = name;
                    this.inputs = inputs;
                    this.output = output;
                    this.id = Node.nextID++;
                    output.node = this;
                }

                Node.nextID = 0;
                return Node;
            }());
            exports.Node = Node;
            var VariableNode = (function (_super) {
                __extends(VariableNode, _super);

                function VariableNode(graph, name, data) {
                    var _this = _super.call(this, graph, name, {}, new Tensor(data.shape)) || this;
                    _this.data = data;
                    return _this;
                }

                VariableNode.prototype.validate = function () {
                    util.assert(this.data != null, 'Error adding variable op: Data for variable \'' + this.name +
                        '\' is null or undefined');
                };
                return VariableNode;
            }(Node));
            exports.VariableNode = VariableNode;
            var PlaceholderNode = (function (_super) {
                __extends(PlaceholderNode, _super);

                function PlaceholderNode(graph, name, shape) {
                    return _super.call(this, graph, name, {}, new Tensor(shape)) || this;
                }

                PlaceholderNode.prototype.validate = function () {
                };
                return PlaceholderNode;
            }(Node));
            exports.PlaceholderNode = PlaceholderNode;
            var ConstantNode = (function (_super) {
                __extends(ConstantNode, _super);

                function ConstantNode(graph, data) {
                    var _this = _super.call(this, graph, 'Constant', {}, new Tensor(data.shape)) || this;
                    _this.data = data;
                    return _this;
                }

                ConstantNode.prototype.validate = function () {
                    util.assert(this.data != null, 'Error adding constant: data for placeholder \'' + this.name +
                        '\' is null or undefined');
                };
                return ConstantNode;
            }(Node));
            exports.ConstantNode = ConstantNode;
            var ReshapeNode = (function (_super) {
                __extends(ReshapeNode, _super);

                function ReshapeNode(graph, name, x, shape) {
                    var _this = _super.call(this, graph, name, {x: x}, new Tensor(shape)) || this;
                    _this.name = name;
                    _this.x = x;
                    _this.shape = shape;
                    return _this;
                }

                ReshapeNode.prototype.validate = function () {
                    var xSize = util.sizeFromShape(this.x.shape);
                    var shapeSize = util.sizeFromShape(this.shape);
                    util.assert(xSize === shapeSize, "Error making reshape operation: input to reshape '" + this.name + "'" +
                        (" of shape (" + this.x.shape + ") does not match size of ") +
                        ("requested shape " + this.shape + "."));
                };
                ReshapeNode.X = 'x';
                return ReshapeNode;
            }(Node));
            exports.ReshapeNode = ReshapeNode;
            var FusedLinearCombinationNode = (function (_super) {
                __extends(FusedLinearCombinationNode, _super);

                function FusedLinearCombinationNode(graph, t1, t2, c1, c2) {
                    var _this = _super.call(this, graph, 'Linear Combination', {
                        t1: t1,
                        t2: t2,
                        c1: c1,
                        c2: c2
                    }, new Tensor(t1.shape)) || this;
                    _this.t1 = t1;
                    _this.t2 = t2;
                    _this.c1 = c1;
                    _this.c2 = c2;
                    return _this;
                }

                FusedLinearCombinationNode.prototype.validate = function () {
                    util.assertShapesMatch(this.t1.shape, this.t2.shape);
                    if (!util.isScalarShape(this.c1.shape)) {
                        throw new Error('Error adding fusedLinearCombination: c1 is not a scalar, got ' +
                            ("shape: " + this.c1.shape));
                    }
                    if (!util.isScalarShape(this.c2.shape)) {
                        throw new Error('Error adding fusedLinearCombination: c2 is not a scalar, got ' +
                            ("shape: " + this.c2.shape));
                    }
                };
                FusedLinearCombinationNode.T1 = 't1';
                FusedLinearCombinationNode.T2 = 't2';
                FusedLinearCombinationNode.C1 = 'c1';
                FusedLinearCombinationNode.C2 = 'c2';
                return FusedLinearCombinationNode;
            }(Node));
            exports.FusedLinearCombinationNode = FusedLinearCombinationNode;
            var AddNode = (function (_super) {
                __extends(AddNode, _super);

                function AddNode(graph, t1, t2) {
                    var _this = _super.call(this, graph, 'Add', {
                        t1: t1,
                        t2: t2
                    }, new Tensor(util.sizeFromShape(t1.shape) === 1
                        ? t2.shape
                        : (t1.shape.length < t2.shape.length ? t2.shape : t1.shape))) || this;
                    _this.t1 = t1;
                    _this.t2 = t2;
                    return _this;
                }

                AddNode.prototype.validate = function () {
                    util.assert(util.sizeFromShape(this.t1.shape) === 1 ||
                        util.sizeFromShape(this.t2.shape) === 1 ||
                        util.arraysEqual(this.t1.shape, this.t2.shape) ||
                        (this.t1.shape.length === 2 && this.t2.shape.length === 1 &&
                            this.t1.shape[1] === this.t2.shape[0]) ||
                        (this.t1.shape.length === 1 && this.t2.shape.length === 2 &&
                            this.t1.shape[0] === this.t2.shape[1]), 'Error adding add operation op: one of inputs must be scalar, ' +
                        ("shapes " + this.t1.shape + " and " + this.t2.shape + " must match,") +
                        'or one of them can be broadcasted (2D and 1D).');
                };
                AddNode.T1 = 't1';
                AddNode.T2 = 't2';
                return AddNode;
            }(Node));
            exports.AddNode = AddNode;
            var SubtractNode = (function (_super) {
                __extends(SubtractNode, _super);

                function SubtractNode(graph, t1, t2) {
                    var _this = _super.call(this, graph, 'Subtract', {
                        t1: t1,
                        t2: t2
                    }, new Tensor(util.sizeFromShape(t1.shape) === 1 ? t2.shape : t1.shape)) || this;
                    _this.t1 = t1;
                    _this.t2 = t2;
                    return _this;
                }

                SubtractNode.prototype.validate = function () {
                    util.assert(util.sizeFromShape(this.t1.shape) === 1 ||
                        util.sizeFromShape(this.t2.shape) === 1 ||
                        util.arraysEqual(this.t1.shape, this.t2.shape), 'Error adding subtract op: one of inputs must be scalar or the ' +
                        ("shapes " + this.t1.shape + " and " + this.t2.shape + " must match."));
                };
                SubtractNode.T1 = 't1';
                SubtractNode.T2 = 't2';
                return SubtractNode;
            }(Node));
            exports.SubtractNode = SubtractNode;
            var MultiplyNode = (function (_super) {
                __extends(MultiplyNode, _super);

                function MultiplyNode(graph, t1, t2) {
                    var _this = _super.call(this, graph, 'Multiply', {
                        t1: t1,
                        t2: t2
                    }, new Tensor(util.sizeFromShape(t1.shape) === 1 ? t2.shape : t1.shape)) || this;
                    _this.t1 = t1;
                    _this.t2 = t2;
                    return _this;
                }

                MultiplyNode.prototype.validate = function () {
                    util.assert(util.sizeFromShape(this.t1.shape) === 1 ||
                        util.sizeFromShape(this.t2.shape) === 1 ||
                        util.arraysEqual(this.t1.shape, this.t2.shape), 'Error adding multiply op: one of inputs must be scalar or the ' +
                        ("shapes " + this.t1.shape + " and " + this.t2.shape + " must match."));
                };
                MultiplyNode.T1 = 't1';
                MultiplyNode.T2 = 't2';
                return MultiplyNode;
            }(Node));
            exports.MultiplyNode = MultiplyNode;
            var DivideNode = (function (_super) {
                __extends(DivideNode, _super);

                function DivideNode(graph, t1, t2) {
                    var _this = _super.call(this, graph, 'Divide', {
                        t1: t1,
                        t2: t2
                    }, new Tensor(util.sizeFromShape(t1.shape) === 1 ? t2.shape : t1.shape)) || this;
                    _this.t1 = t1;
                    _this.t2 = t2;
                    return _this;
                }

                DivideNode.prototype.validate = function () {
                    util.assert(util.sizeFromShape(this.t1.shape) === 1 ||
                        util.sizeFromShape(this.t2.shape) === 1 ||
                        util.arraysEqual(this.t1.shape, this.t2.shape), 'Error adding divide op: one of inputs must be scalar or the ' +
                        ("shapes " + this.t1.shape + " and " + this.t2.shape + " must match."));
                };
                DivideNode.T1 = 't1';
                DivideNode.T2 = 't2';
                return DivideNode;
            }(Node));
            exports.DivideNode = DivideNode;
            var ReduceSumNode = (function (_super) {
                __extends(ReduceSumNode, _super);

                function ReduceSumNode(graph, x) {
                    return _super.call(this, graph, 'ReduceSum', {x: x}, new Tensor([])) || this;
                }

                ReduceSumNode.prototype.validate = function () {
                };
                ReduceSumNode.X = 'x';
                return ReduceSumNode;
            }(Node));
            exports.ReduceSumNode = ReduceSumNode;
            var Concat3DNode = (function (_super) {
                __extends(Concat3DNode, _super);

                function Concat3DNode(graph, x1, x2, axis) {
                    var _this = _super.call(this, graph, 'Concat3D', {
                        x1: x1,
                        x2: x2
                    }, new Tensor(concat_util.computeOutShape(x1.shape, x2.shape, axis))) || this;
                    _this.x1 = x1;
                    _this.x2 = x2;
                    _this.axis = axis;
                    return _this;
                }

                Concat3DNode.prototype.validate = function () {
                    concat_util.assertParams(this.x1.shape, this.x2.shape, this.axis);
                };
                Concat3DNode.X1 = 'x1';
                Concat3DNode.X2 = 'x2';
                Concat3DNode.AXIS = 'axis';
                return Concat3DNode;
            }(Node));
            exports.Concat3DNode = Concat3DNode;

            function getMatMulOutputShape(x1Shape, x2Shape) {
                if (x1Shape.length === 1 && x2Shape.length === 1) {
                    return [1];
                } else if (x1Shape.length === 1 && x2Shape.length === 2) {
                    return [x2Shape[1]];
                } else if (x1Shape.length === 2 && x2Shape.length === 1) {
                    return [x1Shape[0]];
                }
                return [x1Shape[0], x2Shape[1]];
            }

            var MatMulNode = (function (_super) {
                __extends(MatMulNode, _super);

                function MatMulNode(graph, x1, x2) {
                    var _this = _super.call(this, graph, 'MatMul', {
                        x1: x1,
                        x2: x2
                    }, new Tensor(getMatMulOutputShape(x1.shape, x2.shape))) || this;
                    _this.x1 = x1;
                    _this.x2 = x2;
                    return _this;
                }

                MatMulNode.prototype.validate = function () {
                    if (this.x1.shape.length === 2 && this.x2.shape.length === 2) {
                        util.assert(this.x1.shape[1] === this.x2.shape[0], 'Error adding matmul op: inner shapes of matrices with shapes ' +
                            (this.x1.shape + " and " + this.x2.shape + " must match."));
                    } else if (this.x1.shape.length === 2 && this.x2.shape.length === 1) {
                        util.assert(this.x1.shape[1] === this.x2.shape[0], 'Error adding matmul op: second dimension of matrix with shape ' +
                            this.x1.shape.toString() +
                            (" must match size of vector with shape " + this.x2.shape + "."));
                    } else if (this.x1.shape.length === 1 && this.x2.shape.length === 2) {
                        util.assert(this.x1.shape[0] === this.x2.shape[0], "Error adding matmul op: size of vector with shape " + this.x1.shape +
                            " must match first dimension of matrix with " +
                            ("shape " + this.x2.shape + "."));
                    } else {
                        throw new Error('Error adding matmul op: inputs must be vectors or matrices.');
                    }
                };
                MatMulNode.X1 = 'x1';
                MatMulNode.X2 = 'x2';
                return MatMulNode;
            }(Node));
            exports.MatMulNode = MatMulNode;
            var Convolution2DNode = (function (_super) {
                __extends(Convolution2DNode, _super);

                function Convolution2DNode(graph, x, w, b, fieldSize, outputDepth, stride, zeroPad) {
                    if (stride === void 0) {
                        stride = 1;
                    }
                    var _this = _super.call(this, graph, 'Convolution 2D', {
                        x: x,
                        w: w,
                        b: b
                    }, new Tensor(conv_util.computeOutputShape3D(x.shape, fieldSize, outputDepth, stride, zeroPad))) || this;
                    _this.x = x;
                    _this.w = w;
                    _this.b = b;
                    _this.fieldSize = fieldSize;
                    _this.outputDepth = outputDepth;
                    _this.stride = stride;
                    _this.zeroPad = zeroPad;
                    return _this;
                }

                Convolution2DNode.prototype.validate = function () {
                    util.assert(this.x.shape.length === 3, 'Error adding conv2d op: input must be of rank 3, but got shape: ' +
                        (this.x.shape + "."));
                    util.assert(this.w.shape.length === 4, 'Error adding conv2d op: weights must be of rank 4, but got shape: ' +
                        (this.w.shape + "."));
                    util.assert(this.b.shape.length === 1, 'Error adding conv2d op: biases must be of rank 1, but got shape: ' +
                        (this.b.shape + "."));
                    util.assert(this.x.shape[2] === this.w.shape[2], "Error adding conv2d op: depth of input (" + this.x.shape[2] + ") " +
                        ("must match input depth for weights (" + this.w.shape[2] + ")."));
                };
                Convolution2DNode.X = 'x';
                Convolution2DNode.W = 'w';
                Convolution2DNode.B = 'b';
                return Convolution2DNode;
            }(Node));
            exports.Convolution2DNode = Convolution2DNode;
            var MaxPoolNode = (function (_super) {
                __extends(MaxPoolNode, _super);

                function MaxPoolNode(graph, x, fieldSize, stride, zeroPad) {
                    if (stride === void 0) {
                        stride = 1;
                    }
                    var _this = _super.call(this, graph, 'Max pool', {x: x}, new Tensor(conv_util.computeOutputShape3D(x.shape, fieldSize, x.shape[2], stride, zeroPad))) || this;
                    _this.x = x;
                    _this.fieldSize = fieldSize;
                    _this.stride = stride;
                    _this.zeroPad = zeroPad;
                    return _this;
                }

                MaxPoolNode.prototype.validate = function () {
                    util.assert(this.x.shape.length === 3, 'Error adding maxPool op: input must be of rank 3, but got shape: ' +
                        (this.x.shape + "."));
                };
                MaxPoolNode.X = 'x';
                return MaxPoolNode;
            }(Node));
            exports.MaxPoolNode = MaxPoolNode;
            var ReLUNode = (function (_super) {
                __extends(ReLUNode, _super);

                function ReLUNode(graph, x) {
                    return _super.call(this, graph, 'ReLU', {x: x}, new Tensor(x.shape)) || this;
                }

                ReLUNode.prototype.validate = function () {
                };
                ReLUNode.X = 'x';
                return ReLUNode;
            }(Node));
            exports.ReLUNode = ReLUNode;
            var LeakyReLUNode = (function (_super) {
                __extends(LeakyReLUNode, _super);

                function LeakyReLUNode(graph, x, alpha) {
                    var _this = _super.call(this, graph, 'LeakyReLU', {x: x}, new Tensor(x.shape)) || this;
                    _this.alpha = alpha;
                    return _this;
                }

                LeakyReLUNode.prototype.validate = function () {
                };
                LeakyReLUNode.X = 'x';
                return LeakyReLUNode;
            }(Node));
            exports.LeakyReLUNode = LeakyReLUNode;
            var PReLUNode = (function (_super) {
                __extends(PReLUNode, _super);

                function PReLUNode(graph, x, alpha) {
                    var _this = _super.call(this, graph, 'PReLU', {x: x, alpha: alpha}, new Tensor(x.shape)) || this;
                    _this.x = x;
                    _this.alpha = alpha;
                    return _this;
                }

                PReLUNode.prototype.validate = function () {
                    util.assert(util.arraysEqual(this.x.shape, this.alpha.shape), 'Error adding pRelu op: the ' +
                        ("shapes x: " + this.x.shape + " and alpha: " + this.alpha.shape + " must match."));
                };
                PReLUNode.X = 'x';
                PReLUNode.ALPHA = 'alpha';
                return PReLUNode;
            }(Node));
            exports.PReLUNode = PReLUNode;
            var EluNode = (function (_super) {
                __extends(EluNode, _super);

                function EluNode(graph, x) {
                    return _super.call(this, graph, 'Elu', {x: x}, new Tensor(x.shape)) || this;
                }

                EluNode.prototype.validate = function () {
                };
                EluNode.X = 'x';
                return EluNode;
            }(Node));
            exports.EluNode = EluNode;
            var ExpNode = (function (_super) {
                __extends(ExpNode, _super);

                function ExpNode(graph, x) {
                    return _super.call(this, graph, 'Exp', {x: x}, new Tensor(x.shape)) || this;
                }

                ExpNode.prototype.validate = function () {
                };
                ExpNode.X = 'x';
                return ExpNode;
            }(Node));
            exports.ExpNode = ExpNode;
            var LogNode = (function (_super) {
                __extends(LogNode, _super);

                function LogNode(graph, x) {
                    return _super.call(this, graph, 'Log', {x: x}, new Tensor(x.shape)) || this;
                }

                LogNode.prototype.validate = function () {
                };
                LogNode.X = 'x';
                return LogNode;
            }(Node));
            exports.LogNode = LogNode;
            var TanHNode = (function (_super) {
                __extends(TanHNode, _super);

                function TanHNode(graph, x) {
                    return _super.call(this, graph, 'TanH', {x: x}, new Tensor(x.shape)) || this;
                }

                TanHNode.prototype.validate = function () {
                };
                TanHNode.X = 'x';
                return TanHNode;
            }(Node));
            exports.TanHNode = TanHNode;
            var SigmoidNode = (function (_super) {
                __extends(SigmoidNode, _super);

                function SigmoidNode(graph, x) {
                    return _super.call(this, graph, 'Sigmoid', {x: x}, new Tensor(x.shape)) || this;
                }

                SigmoidNode.prototype.validate = function () {
                };
                SigmoidNode.X = 'x';
                return SigmoidNode;
            }(Node));
            exports.SigmoidNode = SigmoidNode;
            var SquareNode = (function (_super) {
                __extends(SquareNode, _super);

                function SquareNode(graph, x) {
                    return _super.call(this, graph, 'Square', {x: x}, new Tensor(x.shape)) || this;
                }

                SquareNode.prototype.validate = function () {
                };
                SquareNode.X = 'x';
                return SquareNode;
            }(Node));
            exports.SquareNode = SquareNode;
            var SoftmaxCrossEntropyCostNode = (function (_super) {
                __extends(SoftmaxCrossEntropyCostNode, _super);

                function SoftmaxCrossEntropyCostNode(graph, x, target) {
                    var _this = _super.call(this, graph, 'SoftmaxCrossEntropyCost', {
                        x: x,
                        target: target
                    }, new Tensor([])) || this;
                    _this.x = x;
                    _this.target = target;
                    return _this;
                }

                SoftmaxCrossEntropyCostNode.prototype.validate = function () {
                    util.assert(util.arraysEqual(this.x.shape, this.target.shape), "Error adding softmaxCrossEntropyCost op: x shape (" + this.x.shape + ") " +
                        ("must match target shape (" + this.target.shape + ")."));
                };
                SoftmaxCrossEntropyCostNode.X = 'x';
                SoftmaxCrossEntropyCostNode.TARGET = 'target';
                return SoftmaxCrossEntropyCostNode;
            }(Node));
            exports.SoftmaxCrossEntropyCostNode = SoftmaxCrossEntropyCostNode;
            var SoftmaxNode = (function (_super) {
                __extends(SoftmaxNode, _super);

                function SoftmaxNode(graph, x) {
                    var _this = _super.call(this, graph, 'Softmax', {x: x}, new Tensor(x.shape)) || this;
                    _this.x = x;
                    return _this;
                }

                SoftmaxNode.prototype.validate = function () {
                    util.assert(this.x.shape.length === 1, 'The input to a softmax must be a 1-D tensor');
                    util.assert(this.x.shape[0] >= 2, 'The input to a softmax must have at least 2 values');
                };
                SoftmaxNode.X = 'x';
                return SoftmaxNode;
            }(Node));
            exports.SoftmaxNode = SoftmaxNode;
            var MeanSquaredCostNode = (function (_super) {
                __extends(MeanSquaredCostNode, _super);

                function MeanSquaredCostNode(graph, label, prediction) {
                    var _this = _super.call(this, graph, 'Mean Squared Cost', {
                        label: label,
                        prediction: prediction
                    }, new Tensor([])) || this;
                    _this.label = label;
                    _this.prediction = prediction;
                    return _this;
                }

                MeanSquaredCostNode.prototype.validate = function () {
                    util.assert(util.arraysEqual(this.label.shape, this.prediction.shape), "Error adding meanSquaredCost op: label shape (" + this.label.shape + ") " +
                        ("must match prediction shape (" + this.prediction.shape + ")."));
                };
                MeanSquaredCostNode.LABEL = 'label';
                MeanSquaredCostNode.PREDICTION = 'prediction';
                return MeanSquaredCostNode;
            }(Node));
            exports.MeanSquaredCostNode = MeanSquaredCostNode;
            var ArgMaxNode = (function (_super) {
                __extends(ArgMaxNode, _super);

                function ArgMaxNode(graph, x) {
                    var _this = _super.call(this, graph, 'ArgMax', {x: x}, new Tensor([1])) || this;
                    _this.x = x;
                    return _this;
                }

                ArgMaxNode.prototype.validate = function () {
                    util.assert(util.sizeFromShape(this.x.shape) > 0, 'Error adding argmax op: input tensor must have at least one entry.');
                };
                ArgMaxNode.X = 'x';
                return ArgMaxNode;
            }(Node));
            exports.ArgMaxNode = ArgMaxNode;
            var ArgMaxEqualsNode = (function (_super) {
                __extends(ArgMaxEqualsNode, _super);

                function ArgMaxEqualsNode(graph, x1, x2) {
                    var _this = _super.call(this, graph, 'ArgMaxEquals', {x1: x1, x2: x2}, new Tensor([1])) || this;
                    _this.x1 = x1;
                    _this.x2 = x2;
                    return _this;
                }

                ArgMaxEqualsNode.prototype.validate = function () {
                    util.assert(util.arraysEqual(this.x1.shape, this.x2.shape), "Error adding ArgMaxEquals op: x1 shape (" + this.x1.shape + ") " +
                        ("must match x2 shape (" + this.x2.shape + ")."));
                };
                ArgMaxEqualsNode.X1 = 'x1';
                ArgMaxEqualsNode.X2 = 'x2';
                return ArgMaxEqualsNode;
            }(Node));
            exports.ArgMaxEqualsNode = ArgMaxEqualsNode;

        }, {
            "../initializers": 52,
            "../math/concat_util": 91,
            "../math/conv_util": 92,
            "../math/ndarray": 95,
            "../util": 101
        }],
        17: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var graph_1 = require("./graph");
            var priority_queue = require("./priority_queue");
            var priority_queue_1 = require("./priority_queue");

            function getUnorderedEvaluationSet(nodes, terminatingNodes) {
                var terminatingNodeMap = {};
                var seen = {};
                var set = [];
                var visit = nodes.slice();
                terminatingNodes.forEach(function (node) {
                    return terminatingNodeMap[node.id] = node;
                });
                var _loop_1 = function () {
                    var cur = visit.pop();
                    if (seen[cur.id] == null) {
                        if (terminatingNodeMap[cur.id] == null) {
                            Object.keys(cur.inputs)
                                .map(function (inputName) {
                                    return cur.inputs[inputName];
                                })
                                .forEach(function (input) {
                                    return visit.push(input.node);
                                });
                        }
                        set.push(cur);
                        seen[cur.id] = cur;
                    }
                };
                while (visit.length !== 0) {
                    _loop_1();
                }
                return set;
            }

            exports.getUnorderedEvaluationSet = getUnorderedEvaluationSet;

            function getOrderedEvaluationSet(unorderedEvaluationSet) {
                var set = [];
                var nodeIndices = {};
                var pendingDependencies = {};
                var nodeQueue = new priority_queue_1.PriorityQueue(function (a, b) {
                    return priority_queue.defaultCompare(pendingDependencies[a.id], pendingDependencies[b.id]);
                }, function (node, newIndex) {
                    return nodeIndices[node.id] = newIndex;
                });
                unorderedEvaluationSet.forEach(function (node) {
                    return pendingDependencies[node.id] = 0;
                });
                unorderedEvaluationSet.forEach(function (node) {
                    return Object.keys(node.inputs)
                        .map(function (key) {
                            return node.inputs[key];
                        })
                        .forEach(function (input) {
                            if (unorderedEvaluationSet.indexOf(input.node) !== -1) {
                                pendingDependencies[input.node.id]++;
                            }
                        });
                });
                unorderedEvaluationSet.forEach(function (node) {
                    return nodeQueue.enqueue(node);
                });
                while (!nodeQueue.empty()) {
                    set.unshift(nodeQueue.dequeue());
                    Object.keys(set[0].inputs).map(function (key) {
                        return set[0].inputs[key];
                    }).forEach(function (input) {
                        if (unorderedEvaluationSet.indexOf(input.node) === -1) {
                            return;
                        }
                        pendingDependencies[input.node.id]--;
                        nodeQueue.update(input.node, nodeIndices[input.node.id]);
                    });
                }
                return set;
            }

            exports.getOrderedEvaluationSet = getOrderedEvaluationSet;

            function isInputNode(node) {
                return Object.keys(node.inputs).length === 0;
            }

            exports.isInputNode = isInputNode;

            function shouldBackProp(t) {
                return !(t.node instanceof graph_1.ConstantNode);
            }

            exports.shouldBackProp = shouldBackProp;

            function isPassthroughNode(node, map) {
                var keys = Object.keys(node.inputs);
                for (var i = 0; i < keys.length; i++) {
                    var input = node.inputs[keys[i]];
                    if (map.get(input, true) === map.get(node.output, true)) {
                        return true;
                    }
                }
                return false;
            }

            exports.isPassthroughNode = isPassthroughNode;

        }, {"./graph": 16, "./priority_queue": 46}],
        18: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var graph_1 = require("./graph");
            var graph_util = require("./graph_util");
            var add_1 = require("./ops/add");
            var argmax_1 = require("./ops/argmax");
            var argmaxequals_1 = require("./ops/argmaxequals");
            var concat3d_1 = require("./ops/concat3d");
            var convolution_1 = require("./ops/convolution");
            var divide_1 = require("./ops/divide");
            var element_wise_activation_1 = require("./ops/element_wise_activation");
            var element_wise_cost_1 = require("./ops/element_wise_cost");
            var exp_1 = require("./ops/exp");
            var linear_combination_1 = require("./ops/linear_combination");
            var log_1 = require("./ops/log");
            var matmul_1 = require("./ops/matmul");
            var max_pool_1 = require("./ops/max_pool");
            var multiply_1 = require("./ops/multiply");
            var reduce_sum_1 = require("./ops/reduce_sum");
            var reshape_1 = require("./ops/reshape");
            var softmax_1 = require("./ops/softmax");
            var subtract_1 = require("./ops/subtract");

            function emitFromGraphNodes(nodes) {
                var ops = [];
                nodes.forEach(function (node) {
                    return Array.prototype.push.apply(ops, emitOpFromNode(node));
                });
                return ops;
            }

            exports.emitFromGraphNodes = emitFromGraphNodes;

            function emitOpFromNode(node) {
                if (node instanceof graph_1.ReshapeNode) {
                    return [new reshape_1.Reshape(node.inputs[graph_1.ReshapeNode.X], node.output)];
                } else if (node instanceof graph_1.MatMulNode) {
                    var x1 = node.inputs[graph_1.MatMulNode.X1];
                    var x2 = node.inputs[graph_1.MatMulNode.X2];
                    return [new matmul_1.MatMul(x1, x2, node.output)];
                } else if (node instanceof graph_1.Convolution2DNode) {
                    var w = node.inputs[graph_1.Convolution2DNode.W];
                    var x = node.inputs[graph_1.Convolution2DNode.X];
                    var b = node.inputs[graph_1.Convolution2DNode.B];
                    return [new convolution_1.Convolution2D(w, x, b, node.output, node.fieldSize, node.outputDepth, node.stride, node.zeroPad)];
                } else if (node instanceof graph_1.MaxPoolNode) {
                    var x = node.inputs[graph_1.MaxPoolNode.X];
                    return [new max_pool_1.MaxPool(x, node.output, node.fieldSize, node.stride, node.zeroPad)];
                } else if (node instanceof graph_1.ExpNode) {
                    return [new exp_1.Exp(node.inputs[graph_1.ExpNode.X], node.output)];
                } else if (node instanceof graph_1.LogNode) {
                    return [new log_1.Log(node.inputs[graph_1.LogNode.X], node.output)];
                } else if (node instanceof graph_1.ReLUNode) {
                    return [new element_wise_activation_1.ReLU(node.inputs[graph_1.ReLUNode.X], node.output)];
                } else if (node instanceof graph_1.LeakyReLUNode) {
                    return [new element_wise_activation_1.LeakyReLU(node.inputs[graph_1.LeakyReLUNode.X], node.output, node.alpha)];
                } else if (node instanceof graph_1.PReLUNode) {
                    return [new element_wise_activation_1.PReLU(node.inputs[graph_1.PReLUNode.X], node.inputs[graph_1.PReLUNode.ALPHA], node.output)];
                } else if (node instanceof graph_1.EluNode) {
                    return [new element_wise_activation_1.Elu(node.inputs[graph_1.EluNode.X], node.output)];
                } else if (node instanceof graph_1.TanHNode) {
                    return [new element_wise_activation_1.TanH(node.inputs[graph_1.TanHNode.X], node.output)];
                } else if (node instanceof graph_1.SigmoidNode) {
                    return [new element_wise_activation_1.Sigmoid(node.inputs[graph_1.SigmoidNode.X], node.output)];
                } else if (node instanceof graph_1.SoftmaxCrossEntropyCostNode) {
                    var x = node.inputs[graph_1.SoftmaxCrossEntropyCostNode.X];
                    var target = node.inputs[graph_1.SoftmaxCrossEntropyCostNode.TARGET];
                    return [new softmax_1.SoftmaxCrossEntropyCost(x, target, node.output)];
                } else if (node instanceof graph_1.SoftmaxNode) {
                    return [new softmax_1.Softmax(node.inputs[graph_1.SoftmaxNode.X], node.output)];
                } else if (node instanceof graph_1.MeanSquaredCostNode) {
                    var label = node.inputs[graph_1.MeanSquaredCostNode.LABEL];
                    var prediction = node.inputs[graph_1.MeanSquaredCostNode.PREDICTION];
                    return [new element_wise_cost_1.MeanSquaredCost(label, prediction, node.output)];
                } else if (node instanceof graph_1.ArgMaxEqualsNode) {
                    return [new argmaxequals_1.ArgMaxEquals(node.inputs[graph_1.ArgMaxEqualsNode.X1], node.inputs[graph_1.ArgMaxEqualsNode.X2], node.output)];
                } else if (node instanceof graph_1.ArgMaxNode) {
                    return [new argmax_1.ArgMax(node.x, node.output)];
                } else if (node instanceof graph_1.FusedLinearCombinationNode) {
                    return [new linear_combination_1.LinearCombination(node.inputs[graph_1.FusedLinearCombinationNode.T1], node.inputs[graph_1.FusedLinearCombinationNode.T2], node.inputs[graph_1.FusedLinearCombinationNode.C1], node.inputs[graph_1.FusedLinearCombinationNode.C2], node.output)];
                } else if (node instanceof graph_1.Concat3DNode) {
                    return [new concat3d_1.Concat3D(node.inputs[graph_1.Concat3DNode.X1], node.inputs[graph_1.Concat3DNode.X2], node.axis, node.output)];
                } else if (node instanceof graph_1.SquareNode) {
                    return [new element_wise_activation_1.Square(node.inputs[graph_1.SquareNode.X], node.output)];
                } else if (node instanceof graph_1.AddNode) {
                    return [new add_1.Add(node.inputs[graph_1.AddNode.T1], node.inputs[graph_1.AddNode.T2], node.output)];
                } else if (node instanceof graph_1.SubtractNode) {
                    return [new subtract_1.Subtract(node.inputs[graph_1.SubtractNode.T1], node.inputs[graph_1.SubtractNode.T2], node.output)];
                } else if (node instanceof graph_1.MultiplyNode) {
                    return [new multiply_1.Multiply(node.inputs[graph_1.MultiplyNode.T1], node.inputs[graph_1.MultiplyNode.T2], node.output)];
                } else if (node instanceof graph_1.DivideNode) {
                    return [new divide_1.Divide(node.inputs[graph_1.DivideNode.T1], node.inputs[graph_1.DivideNode.T2], node.output)];
                } else if (node instanceof graph_1.ReduceSumNode) {
                    return [new reduce_sum_1.ReduceSum(node.inputs[graph_1.ReduceSumNode.X], node.output)];
                } else if (graph_util.isInputNode(node)) {
                    return [];
                } else {
                    throw Error("Unsupported node type: " + node.constructor.name);
                }
            }

        }, {
            "./graph": 16,
            "./graph_util": 17,
            "./ops/add": 19,
            "./ops/argmax": 20,
            "./ops/argmaxequals": 21,
            "./ops/concat3d": 22,
            "./ops/convolution": 23,
            "./ops/divide": 24,
            "./ops/element_wise_activation": 25,
            "./ops/element_wise_cost": 26,
            "./ops/exp": 27,
            "./ops/linear_combination": 28,
            "./ops/log": 29,
            "./ops/matmul": 30,
            "./ops/max_pool": 31,
            "./ops/multiply": 32,
            "./ops/reduce_sum": 34,
            "./ops/reshape": 35,
            "./ops/softmax": 36,
            "./ops/subtract": 37
        }],
        19: [function (require, module, exports) {
            "use strict";
            var __extends = (this && this.__extends) || (function () {
                var extendStatics = Object.setPrototypeOf ||
                    ({__proto__: []} instanceof Array && function (d, b) {
                        d.__proto__ = b;
                    }) ||
                    function (d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                    };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d;
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            })();
            Object.defineProperty(exports, "__esModule", {value: true});
            var util = require("../../util");
            var graph_util = require("../graph_util");
            var op_1 = require("./op");
            var Add = (function (_super) {
                __extends(Add, _super);

                function Add(x1Tensor, x2Tensor, yTensor) {
                    var _this = _super.call(this) || this;
                    _this.x1Tensor = x1Tensor;
                    _this.x2Tensor = x2Tensor;
                    _this.yTensor = yTensor;
                    util.assert(util.sizeFromShape(x1Tensor.shape) === 1 ||
                        util.sizeFromShape(x2Tensor.shape) === 1 ||
                        util.arraysEqual(x1Tensor.shape, x2Tensor.shape) ||
                        (x1Tensor.shape.length === 2 && x2Tensor.shape.length === 1 &&
                            x1Tensor.shape[1] === x2Tensor.shape[0]) ||
                        (x1Tensor.shape.length === 1 && x2Tensor.shape.length === 2 &&
                            x1Tensor.shape[0] === x2Tensor.shape[1]), 'One of t1 or t2 must be a scalar, or t1 and t2 must have ' +
                        'the same shape, ' +
                        'or one of them can be broadcasted (2D and 1D).');
                    return _this;
                }

                Add.prototype.feedForward = function (math, inferenceArrays) {
                    var _this = this;
                    var x1 = inferenceArrays.get(this.x1Tensor);
                    var x2 = inferenceArrays.get(this.x2Tensor);
                    math.scope(function (keep) {
                        var result;
                        if (util.isScalarShape(x1.shape)) {
                            result = math.scalarPlusArray(x1, x2);
                        } else if (util.isScalarShape(x2.shape)) {
                            result = math.scalarPlusArray(x2, x1);
                        } else {
                            result = math.add(x1, x2);
                        }
                        inferenceArrays.set(_this.yTensor, keep(result));
                    });
                };
                Add.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
                    var _this = this;
                    var dy = gradientArrays.get(this.yTensor);
                    math.scope(function () {
                        if (graph_util.shouldBackProp(_this.x1Tensor)) {
                            if (_this.x1Tensor.shape.length === 1 &&
                                _this.x2Tensor.shape.length === 2 &&
                                _this.x1Tensor.shape[0] === _this.x2Tensor.shape[1]) {
                                var sum = math.sum(dy, 0);
                                gradientArrays.add(_this.x1Tensor, sum);
                            } else if (util.isScalarShape(_this.x1Tensor.shape)) {
                                var sum = math.sum(dy);
                                gradientArrays.add(_this.x1Tensor, sum);
                            } else {
                                gradientArrays.add(_this.x1Tensor, math.clone(dy));
                            }
                        }
                        if (graph_util.shouldBackProp(_this.x2Tensor)) {
                            if (_this.x1Tensor.shape.length === 2 &&
                                _this.x2Tensor.shape.length === 1 &&
                                _this.x1Tensor.shape[1] === _this.x2Tensor.shape[0]) {
                                var sum = math.sum(dy, 0);
                                gradientArrays.add(_this.x2Tensor, sum);
                            } else if (util.isScalarShape(_this.x2Tensor.shape)) {
                                var sum = math.sum(dy);
                                gradientArrays.add(_this.x2Tensor, sum);
                            } else {
                                gradientArrays.add(_this.x2Tensor, math.clone(dy));
                            }
                        }
                    });
                };
                Add.prototype.dispose = function () {
                    if (this.dySizeScalar != null) {
                        this.dySizeScalar.dispose();
                    }
                };
                return Add;
            }(op_1.Operation));
            exports.Add = Add;

        }, {"../../util": 101, "../graph_util": 17, "./op": 33}],
        20: [function (require, module, exports) {
            "use strict";
            var __extends = (this && this.__extends) || (function () {
                var extendStatics = Object.setPrototypeOf ||
                    ({__proto__: []} instanceof Array && function (d, b) {
                        d.__proto__ = b;
                    }) ||
                    function (d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                    };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d;
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            })();
            Object.defineProperty(exports, "__esModule", {value: true});
            var op_1 = require("./op");
            var ArgMax = (function (_super) {
                __extends(ArgMax, _super);

                function ArgMax(xTensor, yTensor) {
                    var _this = _super.call(this) || this;
                    _this.xTensor = xTensor;
                    _this.yTensor = yTensor;
                    return _this;
                }

                ArgMax.prototype.feedForward = function (math, inferenceArrays) {
                    var _this = this;
                    var x = inferenceArrays.get(this.xTensor);
                    math.scope(function (keep) {
                        inferenceArrays.set(_this.yTensor, keep(math.argMax(x)));
                    });
                };
                ArgMax.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
                    throw new Error('ArgMax backprop unimplemented');
                };
                return ArgMax;
            }(op_1.Operation));
            exports.ArgMax = ArgMax;

        }, {"./op": 33}],
        21: [function (require, module, exports) {
            "use strict";
            var __extends = (this && this.__extends) || (function () {
                var extendStatics = Object.setPrototypeOf ||
                    ({__proto__: []} instanceof Array && function (d, b) {
                        d.__proto__ = b;
                    }) ||
                    function (d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                    };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d;
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            })();
            Object.defineProperty(exports, "__esModule", {value: true});
            var op_1 = require("./op");
            var ArgMaxEquals = (function (_super) {
                __extends(ArgMaxEquals, _super);

                function ArgMaxEquals(x1Tensor, x2Tensor, yTensor) {
                    var _this = _super.call(this) || this;
                    _this.x1Tensor = x1Tensor;
                    _this.x2Tensor = x2Tensor;
                    _this.yTensor = yTensor;
                    return _this;
                }

                ArgMaxEquals.prototype.feedForward = function (math, inferenceArrays) {
                    var _this = this;
                    var x1 = inferenceArrays.get(this.x1Tensor);
                    var x2 = inferenceArrays.get(this.x2Tensor);
                    math.scope(function (keep) {
                        inferenceArrays.set(_this.yTensor, keep(math.argMaxEquals(x1, x2)));
                    });
                };
                ArgMaxEquals.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
                    throw new Error('ArgMaxEquals backprop unimplemented');
                };
                return ArgMaxEquals;
            }(op_1.Operation));
            exports.ArgMaxEquals = ArgMaxEquals;

        }, {"./op": 33}],
        22: [function (require, module, exports) {
            "use strict";
            var __extends = (this && this.__extends) || (function () {
                var extendStatics = Object.setPrototypeOf ||
                    ({__proto__: []} instanceof Array && function (d, b) {
                        d.__proto__ = b;
                    }) ||
                    function (d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                    };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d;
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            })();
            Object.defineProperty(exports, "__esModule", {value: true});
            var concat_util = require("../../math/concat_util");
            var op_1 = require("./op");
            var Concat3D = (function (_super) {
                __extends(Concat3D, _super);

                function Concat3D(x1Tensor, x2Tensor, axis, yTensor) {
                    var _this = _super.call(this) || this;
                    _this.x1Tensor = x1Tensor;
                    _this.x2Tensor = x2Tensor;
                    _this.axis = axis;
                    _this.yTensor = yTensor;
                    concat_util.assertParams(x1Tensor.shape, x2Tensor.shape, axis);
                    return _this;
                }

                Concat3D.prototype.feedForward = function (math, inferenceArrays) {
                    var _this = this;
                    var x1 = inferenceArrays.get(this.x1Tensor);
                    var x2 = inferenceArrays.get(this.x2Tensor);
                    math.scope(function (keep) {
                        var concatResult = math.concat3D(x1, x2, _this.axis);
                        inferenceArrays.set(_this.yTensor, keep(concatResult));
                    });
                };
                Concat3D.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
                    throw new Error('Concat3D backprop not implemented.');
                };
                return Concat3D;
            }(op_1.Operation));
            exports.Concat3D = Concat3D;

        }, {"../../math/concat_util": 91, "./op": 33}],
        23: [function (require, module, exports) {
            "use strict";
            var __extends = (this && this.__extends) || (function () {
                var extendStatics = Object.setPrototypeOf ||
                    ({__proto__: []} instanceof Array && function (d, b) {
                        d.__proto__ = b;
                    }) ||
                    function (d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                    };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d;
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            })();
            Object.defineProperty(exports, "__esModule", {value: true});
            var conv_util = require("../../math/conv_util");
            var util = require("../../util");
            var op_1 = require("./op");
            var Convolution2D = (function (_super) {
                __extends(Convolution2D, _super);

                function Convolution2D(wTensor, xTensor, bTensor, yTensor, fieldSize, outputDepth, stride, zeroPad) {
                    if (stride === void 0) {
                        stride = 1;
                    }
                    var _this = _super.call(this) || this;
                    _this.wTensor = wTensor;
                    _this.xTensor = xTensor;
                    _this.bTensor = bTensor;
                    _this.yTensor = yTensor;
                    _this.fieldSize = fieldSize;
                    _this.outputDepth = outputDepth;
                    _this.stride = stride;
                    _this.assertWeightsShape(wTensor.shape);
                    _this.zeroPad = zeroPad != null ?
                        zeroPad :
                        conv_util.computeDefaultPad(_this.xTensor.shape, _this.fieldSize, _this.stride);
                    util.assert(util.isInt(_this.zeroPad), "The zero padding (" + _this.zeroPad + ") must be an integer. Change the " +
                        "stride and/or zero pad parameters");
                    return _this;
                }

                Convolution2D.prototype.feedForward = function (math, inferenceArrays) {
                    var _this = this;
                    var weights = inferenceArrays.get(this.wTensor);
                    var biases = inferenceArrays.get(this.bTensor);
                    var x = inferenceArrays.get(this.xTensor);
                    math.scope(function (keep) {
                        inferenceArrays.set(_this.yTensor, keep(math.conv2d(x, weights, biases, _this.stride, _this.zeroPad)));
                    });
                };
                Convolution2D.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
                    var _this = this;
                    var filter = inferenceArrays.get(this.wTensor);
                    var x = inferenceArrays.get(this.xTensor);
                    var dy = gradientArrays.get(this.yTensor);
                    math.scope(function () {
                        var dw = math.conv2dDerFilter(x, dy, filter.shape, _this.stride, _this.zeroPad);
                        var db = math.conv2dDerBias(dy);
                        var dx = math.conv2dDerInput(x.shape, dy, filter, _this.stride, _this.zeroPad);
                        gradientArrays.add(_this.wTensor, dw);
                        gradientArrays.add(_this.bTensor, db);
                        gradientArrays.add(_this.xTensor, dx);
                    });
                };
                Convolution2D.prototype.assertWeightsShape = function (weightsShape) {
                    util.assert(weightsShape[0] === this.fieldSize &&
                        weightsShape[1] === this.fieldSize &&
                        weightsShape[2] === this.xTensor.shape[2] &&
                        weightsShape[3] === this.outputDepth, "weights must be of shape [" + this.fieldSize + "," + this.fieldSize + "," +
                        (this.xTensor.shape[2] + "," + this.outputDepth + "] but they are of") +
                        ("shape [" + weightsShape + "]"));
                };
                return Convolution2D;
            }(op_1.Operation));
            exports.Convolution2D = Convolution2D;

        }, {"../../math/conv_util": 92, "../../util": 101, "./op": 33}],
        24: [function (require, module, exports) {
            "use strict";
            var __extends = (this && this.__extends) || (function () {
                var extendStatics = Object.setPrototypeOf ||
                    ({__proto__: []} instanceof Array && function (d, b) {
                        d.__proto__ = b;
                    }) ||
                    function (d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                    };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d;
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            })();
            Object.defineProperty(exports, "__esModule", {value: true});
            var util = require("../../util");
            var graph_util = require("../graph_util");
            var op_1 = require("./op");
            var Divide = (function (_super) {
                __extends(Divide, _super);

                function Divide(x1Tensor, x2Tensor, yTensor) {
                    var _this = _super.call(this) || this;
                    _this.x1Tensor = x1Tensor;
                    _this.x2Tensor = x2Tensor;
                    _this.yTensor = yTensor;
                    util.assert(util.sizeFromShape(x1Tensor.shape) === 1 ||
                        util.sizeFromShape(x2Tensor.shape) === 1 ||
                        util.arraysEqual(x1Tensor.shape, x2Tensor.shape), 'One of t1 or t2 must be a scalar, or t1 and t2 must have ' +
                        'the same shape');
                    return _this;
                }

                Divide.prototype.feedForward = function (math, inferenceArrays) {
                    var _this = this;
                    var t1 = inferenceArrays.get(this.x1Tensor);
                    var t2 = inferenceArrays.get(this.x2Tensor);
                    math.scope(function (keep) {
                        var result;
                        if (util.isScalarShape(t1.shape)) {
                            result = math.scalarDividedByArray(t1, t2);
                        } else if (util.isScalarShape(t2.shape)) {
                            result = math.arrayDividedByScalar(t1, t2);
                        } else {
                            result = math.divide(t1, t2);
                        }
                        inferenceArrays.set(_this.yTensor, keep(result));
                    });
                };
                Divide.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
                    var _this = this;
                    var x1 = inferenceArrays.get(this.x1Tensor);
                    var x2 = inferenceArrays.get(this.x2Tensor);
                    var dy = gradientArrays.get(this.yTensor);
                    var x1IsScalar = util.isScalarShape(x1.shape);
                    var x2IsScalar = util.isScalarShape(x2.shape);
                    math.scope(function () {
                        if (graph_util.shouldBackProp(_this.x1Tensor)) {
                            if (x1IsScalar) {
                                var div = math.divide(dy, x2);
                                gradientArrays.add(_this.x1Tensor, math.sum(div));
                                div.dispose();
                            } else if (x2IsScalar) {
                                gradientArrays.add(_this.x1Tensor, math.arrayDividedByScalar(dy, x2));
                            } else {
                                gradientArrays.add(_this.x1Tensor, math.divide(dy, x2));
                            }
                        }
                        if (graph_util.shouldBackProp(_this.x2Tensor)) {
                            var x2Squared = math.elementWiseMul(x2, x2);
                            var x1OverX2Squared = void 0;
                            if (x2IsScalar) {
                                x1OverX2Squared = math.arrayDividedByScalar(x1, x2Squared);
                            } else if (x1IsScalar) {
                                x1OverX2Squared = math.scalarDividedByArray(x1, x2Squared);
                            } else {
                                x1OverX2Squared = math.divide(x1, x2Squared);
                            }
                            var dx2 = math.neg(x1OverX2Squared);
                            var dyTimesDerivative = math.elementWiseMul(dy, dx2);
                            if (x2IsScalar) {
                                gradientArrays.add(_this.x2Tensor, math.sum(dyTimesDerivative));
                            } else {
                                gradientArrays.add(_this.x2Tensor, dyTimesDerivative);
                            }
                        }
                    });
                };
                return Divide;
            }(op_1.Operation));
            exports.Divide = Divide;

        }, {"../../util": 101, "../graph_util": 17, "./op": 33}],
        25: [function (require, module, exports) {
            "use strict";
            var __extends = (this && this.__extends) || (function () {
                var extendStatics = Object.setPrototypeOf ||
                    ({__proto__: []} instanceof Array && function (d, b) {
                        d.__proto__ = b;
                    }) ||
                    function (d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                    };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d;
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            })();
            Object.defineProperty(exports, "__esModule", {value: true});
            var activation_functions_1 = require("../../math/activation_functions");
            var op_1 = require("./op");
            var ElementWiseActivation = (function (_super) {
                __extends(ElementWiseActivation, _super);

                function ElementWiseActivation(xTensor, yTensor, func) {
                    var _this = _super.call(this) || this;
                    _this.xTensor = xTensor;
                    _this.yTensor = yTensor;
                    _this.func = func;
                    return _this;
                }

                ElementWiseActivation.prototype.feedForward = function (math, inferenceArrays) {
                    var _this = this;
                    var x = inferenceArrays.get(this.xTensor);
                    math.scope(function (keep) {
                        inferenceArrays.set(_this.yTensor, keep(_this.func.output(math, x)));
                    });
                };
                ElementWiseActivation.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
                    var _this = this;
                    var x = inferenceArrays.get(this.xTensor);
                    var y = inferenceArrays.get(this.yTensor);
                    var dy = gradientArrays.get(this.yTensor);
                    math.scope(function () {
                        var dydx = _this.func.der(math, x, y);
                        gradientArrays.add(_this.xTensor, math.elementWiseMul(dy, dydx));
                        dydx.dispose();
                    });
                };
                ElementWiseActivation.prototype.dispose = function () {
                    this.func.dispose();
                };
                return ElementWiseActivation;
            }(op_1.Operation));
            exports.ElementWiseActivation = ElementWiseActivation;
            var ReLU = (function (_super) {
                __extends(ReLU, _super);

                function ReLU(xTensor, yTensor) {
                    return _super.call(this, xTensor, yTensor, new activation_functions_1.ReLUFunc()) || this;
                }

                return ReLU;
            }(ElementWiseActivation));
            exports.ReLU = ReLU;
            var LeakyReLU = (function (_super) {
                __extends(LeakyReLU, _super);

                function LeakyReLU(xTensor, yTensor, alpha) {
                    return _super.call(this, xTensor, yTensor, new activation_functions_1.LeakyReluFunc(alpha)) || this;
                }

                return LeakyReLU;
            }(ElementWiseActivation));
            exports.LeakyReLU = LeakyReLU;
            var TanH = (function (_super) {
                __extends(TanH, _super);

                function TanH(xTensor, yTensor) {
                    return _super.call(this, xTensor, yTensor, new activation_functions_1.TanHFunc()) || this;
                }

                return TanH;
            }(ElementWiseActivation));
            exports.TanH = TanH;
            var Sigmoid = (function (_super) {
                __extends(Sigmoid, _super);

                function Sigmoid(xTensor, yTensor) {
                    return _super.call(this, xTensor, yTensor, new activation_functions_1.SigmoidFunc()) || this;
                }

                return Sigmoid;
            }(ElementWiseActivation));
            exports.Sigmoid = Sigmoid;
            var Square = (function (_super) {
                __extends(Square, _super);

                function Square(xTensor, yTensor) {
                    return _super.call(this, xTensor, yTensor, new activation_functions_1.SquareFunc()) || this;
                }

                return Square;
            }(ElementWiseActivation));
            exports.Square = Square;
            var Elu = (function (_super) {
                __extends(Elu, _super);

                function Elu(xTensor, yTensor) {
                    return _super.call(this, xTensor, yTensor, new activation_functions_1.EluFunc()) || this;
                }

                return Elu;
            }(ElementWiseActivation));
            exports.Elu = Elu;
            var PReLU = (function (_super) {
                __extends(PReLU, _super);

                function PReLU(xTensor, alphaTensor, yTensor) {
                    var _this = _super.call(this) || this;
                    _this.xTensor = xTensor;
                    _this.alphaTensor = alphaTensor;
                    _this.yTensor = yTensor;
                    return _this;
                }

                PReLU.prototype.feedForward = function (math, inferenceArrays) {
                    var _this = this;
                    var x = inferenceArrays.get(this.xTensor);
                    var alpha = inferenceArrays.get(this.alphaTensor);
                    math.scope(function (keep) {
                        inferenceArrays.set(_this.yTensor, keep(math.prelu(x, alpha)));
                    });
                };
                PReLU.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
                    var _this = this;
                    var x = inferenceArrays.get(this.xTensor);
                    var alpha = inferenceArrays.get(this.alphaTensor);
                    var dy = gradientArrays.get(this.yTensor);
                    math.scope(function () {
                        var dydx = math.preluDer(x, alpha);
                        gradientArrays.add(_this.xTensor, math.elementWiseMul(dy, dydx));
                    });
                };
                return PReLU;
            }(op_1.Operation));
            exports.PReLU = PReLU;

        }, {"../../math/activation_functions": 53, "./op": 33}],
        26: [function (require, module, exports) {
            "use strict";
            var __extends = (this && this.__extends) || (function () {
                var extendStatics = Object.setPrototypeOf ||
                    ({__proto__: []} instanceof Array && function (d, b) {
                        d.__proto__ = b;
                    }) ||
                    function (d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                    };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d;
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            })();
            Object.defineProperty(exports, "__esModule", {value: true});
            var environment_1 = require("../../environment");
            var cost_functions_1 = require("../../math/cost_functions");
            var ndarray_1 = require("../../math/ndarray");
            var util = require("../../util");
            var graph_util = require("../graph_util");
            var op_1 = require("./op");
            var ElementWiseCost = (function (_super) {
                __extends(ElementWiseCost, _super);

                function ElementWiseCost(x1Tensor, x2Tensor, yTensor, func) {
                    var _this = _super.call(this) || this;
                    _this.x1Tensor = x1Tensor;
                    _this.x2Tensor = x2Tensor;
                    _this.yTensor = yTensor;
                    _this.func = func;
                    _this.oneOverNScalar =
                        environment_1.ENV.math.keep(ndarray_1.Scalar.new(1 / util.sizeFromShape(x1Tensor.shape)));
                    return _this;
                }

                ElementWiseCost.prototype.feedForward = function (math, inferenceArrays) {
                    var _this = this;
                    var x1 = inferenceArrays.get(this.x1Tensor);
                    var x2 = inferenceArrays.get(this.x2Tensor);
                    math.scope(function (keep) {
                        var elementWiseCost = _this.func.cost(math, x1, x2);
                        var sum = math.sum(elementWiseCost);
                        var result = math.scalarTimesArray(_this.oneOverNScalar, sum);
                        inferenceArrays.set(_this.yTensor, keep(result));
                    });
                };
                ElementWiseCost.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
                    var _this = this;
                    var x1 = inferenceArrays.get(this.x1Tensor);
                    var x2 = inferenceArrays.get(this.x2Tensor);
                    math.scope(function () {
                        if (graph_util.shouldBackProp(_this.x1Tensor)) {
                            gradientArrays.add(_this.x1Tensor, _this.func.der(math, x1, x2));
                        }
                        if (graph_util.shouldBackProp(_this.x2Tensor)) {
                            gradientArrays.add(_this.x2Tensor, _this.func.der(math, x2, x1));
                        }
                    });
                };
                ElementWiseCost.prototype.dispose = function () {
                    this.func.dispose();
                    this.oneOverNScalar.dispose();
                };
                return ElementWiseCost;
            }(op_1.Operation));
            exports.ElementWiseCost = ElementWiseCost;
            var MeanSquaredCost = (function (_super) {
                __extends(MeanSquaredCost, _super);

                function MeanSquaredCost(x1Tensor, x2Tensor, yTensor) {
                    return _super.call(this, x1Tensor, x2Tensor, yTensor, new cost_functions_1.SquareCostFunc()) || this;
                }

                return MeanSquaredCost;
            }(ElementWiseCost));
            exports.MeanSquaredCost = MeanSquaredCost;

        }, {
            "../../environment": 15,
            "../../math/cost_functions": 93,
            "../../math/ndarray": 95,
            "../../util": 101,
            "../graph_util": 17,
            "./op": 33
        }],
        27: [function (require, module, exports) {
            "use strict";
            var __extends = (this && this.__extends) || (function () {
                var extendStatics = Object.setPrototypeOf ||
                    ({__proto__: []} instanceof Array && function (d, b) {
                        d.__proto__ = b;
                    }) ||
                    function (d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                    };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d;
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            })();
            Object.defineProperty(exports, "__esModule", {value: true});
            var graph_util = require("../graph_util");
            var op_1 = require("./op");
            var Exp = (function (_super) {
                __extends(Exp, _super);

                function Exp(xTensor, yTensor) {
                    var _this = _super.call(this) || this;
                    _this.xTensor = xTensor;
                    _this.yTensor = yTensor;
                    return _this;
                }

                Exp.prototype.feedForward = function (math, inferenceArrays) {
                    var _this = this;
                    var x = inferenceArrays.get(this.xTensor);
                    math.scope(function (keep) {
                        inferenceArrays.set(_this.yTensor, keep(math.exp(x)));
                    });
                };
                Exp.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
                    var _this = this;
                    var y = inferenceArrays.get(this.yTensor);
                    var dy = gradientArrays.get(this.yTensor);
                    math.scope(function () {
                        if (graph_util.shouldBackProp(_this.xTensor)) {
                            gradientArrays.add(_this.xTensor, math.elementWiseMul(y, dy));
                        }
                    });
                };
                return Exp;
            }(op_1.Operation));
            exports.Exp = Exp;

        }, {"../graph_util": 17, "./op": 33}],
        28: [function (require, module, exports) {
            "use strict";
            var __extends = (this && this.__extends) || (function () {
                var extendStatics = Object.setPrototypeOf ||
                    ({__proto__: []} instanceof Array && function (d, b) {
                        d.__proto__ = b;
                    }) ||
                    function (d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                    };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d;
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            })();
            Object.defineProperty(exports, "__esModule", {value: true});
            var graph_util = require("../graph_util");
            var op_1 = require("./op");
            var LinearCombination = (function (_super) {
                __extends(LinearCombination, _super);

                function LinearCombination(x1Tensor, x2Tensor, c1Tensor, c2Tensor, outTensor) {
                    var _this = _super.call(this) || this;
                    _this.x1Tensor = x1Tensor;
                    _this.x2Tensor = x2Tensor;
                    _this.c1Tensor = c1Tensor;
                    _this.c2Tensor = c2Tensor;
                    _this.outTensor = outTensor;
                    return _this;
                }

                LinearCombination.prototype.feedForward = function (math, inferenceArrays) {
                    var _this = this;
                    var x1 = inferenceArrays.get(this.x1Tensor);
                    var x2 = inferenceArrays.get(this.x2Tensor);
                    var c1 = inferenceArrays.get(this.c1Tensor).asScalar();
                    var c2 = inferenceArrays.get(this.c2Tensor).asScalar();
                    math.scope(function (keep) {
                        inferenceArrays.set(_this.outTensor, keep(math.scaledArrayAdd(c1, x1, c2, x2)));
                    });
                };
                LinearCombination.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
                    var _this = this;
                    var x1 = inferenceArrays.get(this.x1Tensor);
                    var x2 = inferenceArrays.get(this.x2Tensor);
                    var c1 = inferenceArrays.get(this.c1Tensor);
                    var c2 = inferenceArrays.get(this.c2Tensor);
                    var dy = gradientArrays.get(this.outTensor);
                    math.scope(function () {
                        if (graph_util.shouldBackProp(_this.x1Tensor)) {
                            gradientArrays.add(_this.x1Tensor, math.scalarTimesArray(c1, dy));
                        }
                        if (graph_util.shouldBackProp(_this.x2Tensor)) {
                            gradientArrays.add(_this.x2Tensor, math.scalarTimesArray(c2, dy));
                        }
                        if (graph_util.shouldBackProp(_this.c1Tensor)) {
                            var dotProduct1 = math.elementWiseMul(x1, dy);
                            gradientArrays.add(_this.c1Tensor, math.sum(dotProduct1));
                        }
                        if (graph_util.shouldBackProp(_this.c2Tensor)) {
                            var dotProduct2 = math.elementWiseMul(x2, dy);
                            gradientArrays.add(_this.c2Tensor, math.sum(dotProduct2));
                        }
                    });
                };
                return LinearCombination;
            }(op_1.Operation));
            exports.LinearCombination = LinearCombination;

        }, {"../graph_util": 17, "./op": 33}],
        29: [function (require, module, exports) {
            "use strict";
            var __extends = (this && this.__extends) || (function () {
                var extendStatics = Object.setPrototypeOf ||
                    ({__proto__: []} instanceof Array && function (d, b) {
                        d.__proto__ = b;
                    }) ||
                    function (d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                    };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d;
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            })();
            Object.defineProperty(exports, "__esModule", {value: true});
            var graph_util = require("../graph_util");
            var op_1 = require("./op");
            var Log = (function (_super) {
                __extends(Log, _super);

                function Log(xTensor, yTensor) {
                    var _this = _super.call(this) || this;
                    _this.xTensor = xTensor;
                    _this.yTensor = yTensor;
                    return _this;
                }

                Log.prototype.feedForward = function (math, inferenceArrays) {
                    var _this = this;
                    var x = inferenceArrays.get(this.xTensor);
                    math.scope(function (keep) {
                        inferenceArrays.set(_this.yTensor, keep(math.log(x)));
                    });
                };
                Log.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
                    var _this = this;
                    var x = inferenceArrays.get(this.xTensor);
                    var dy = gradientArrays.get(this.yTensor);
                    math.scope(function () {
                        if (graph_util.shouldBackProp(_this.xTensor)) {
                            gradientArrays.add(_this.xTensor, math.divide(dy, x));
                        }
                    });
                };
                return Log;
            }(op_1.Operation));
            exports.Log = Log;

        }, {"../graph_util": 17, "./op": 33}],
        30: [function (require, module, exports) {
            "use strict";
            var __extends = (this && this.__extends) || (function () {
                var extendStatics = Object.setPrototypeOf ||
                    ({__proto__: []} instanceof Array && function (d, b) {
                        d.__proto__ = b;
                    }) ||
                    function (d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                    };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d;
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            })();
            Object.defineProperty(exports, "__esModule", {value: true});
            var matmul_1 = require("../../math/backends/types/matmul");
            var graph_util = require("../graph_util");
            var op_1 = require("./op");
            var MatMul = (function (_super) {
                __extends(MatMul, _super);

                function MatMul(x1Tensor, x2Tensor, yTensor) {
                    var _this = _super.call(this) || this;
                    _this.x1Tensor = x1Tensor;
                    _this.x2Tensor = x2Tensor;
                    _this.yTensor = yTensor;
                    return _this;
                }

                MatMul.prototype.feedForward = function (math, inferenceArrays) {
                    var _this = this;
                    var x1 = inferenceArrays.get(this.x1Tensor);
                    var x2 = inferenceArrays.get(this.x2Tensor);
                    math.scope(function (keep) {
                        if (x1.shape.length === 2 && x2.shape.length === 2) {
                            inferenceArrays.set(_this.yTensor, keep(math.matMul(x1, x2)));
                        } else if (x1.shape.length === 2 && x2.shape.length === 1) {
                            inferenceArrays.set(_this.yTensor, keep(math.matrixTimesVector(x1, x2)));
                        } else if (x1.shape.length === 1 && x2.shape.length === 2) {
                            inferenceArrays.set(_this.yTensor, keep(math.vectorTimesMatrix(x1, x2)));
                        }
                    });
                };
                MatMul.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
                    var _this = this;
                    var x1 = inferenceArrays.get(this.x1Tensor);
                    var x2 = inferenceArrays.get(this.x2Tensor);
                    var dy = gradientArrays.get(this.yTensor);
                    if (x1.shape.length === 1) {
                        x1 = x1.reshape([1, x1.size]);
                        dy = dy.reshape([1, dy.size]);
                    }
                    if (x2.shape.length === 1) {
                        x2 = x2.reshape([x2.size, 1]);
                        dy = dy.reshape([dy.size, 1]);
                    }
                    math.scope(function () {
                        if (graph_util.shouldBackProp(_this.x1Tensor)) {
                            var dx1 = math.matMul(dy, x2, matmul_1.MatrixOrientation.REGULAR, matmul_1.MatrixOrientation.TRANSPOSED);
                            gradientArrays.add(_this.x1Tensor, _this.x1Tensor.shape.length === 1 ? dx1.as1D() : dx1);
                        }
                        if (graph_util.shouldBackProp(_this.x2Tensor)) {
                            var dx2 = math.matMul(x1, dy, matmul_1.MatrixOrientation.TRANSPOSED, matmul_1.MatrixOrientation.REGULAR);
                            gradientArrays.add(_this.x2Tensor, _this.x2Tensor.shape.length === 1 ? dx2.as1D() : dx2);
                        }
                    });
                };
                return MatMul;
            }(op_1.Operation));
            exports.MatMul = MatMul;

        }, {"../../math/backends/types/matmul": 61, "../graph_util": 17, "./op": 33}],
        31: [function (require, module, exports) {
            "use strict";
            var __extends = (this && this.__extends) || (function () {
                var extendStatics = Object.setPrototypeOf ||
                    ({__proto__: []} instanceof Array && function (d, b) {
                        d.__proto__ = b;
                    }) ||
                    function (d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                    };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d;
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            })();
            Object.defineProperty(exports, "__esModule", {value: true});
            var conv_util = require("../../math/conv_util");
            var util = require("../../util");
            var op_1 = require("./op");
            var MaxPool = (function (_super) {
                __extends(MaxPool, _super);

                function MaxPool(xTensor, yTensor, fieldSize, stride, pad) {
                    if (stride === void 0) {
                        stride = 1;
                    }
                    var _this = _super.call(this) || this;
                    _this.xTensor = xTensor;
                    _this.yTensor = yTensor;
                    _this.fieldSize = fieldSize;
                    _this.stride = stride;
                    if (pad != null) {
                        _this.pad = pad;
                    } else {
                        _this.pad = conv_util.computeDefaultPad(xTensor.shape, _this.fieldSize, _this.stride);
                    }
                    util.assert(util.isInt(_this.pad), "The zero padding (" + _this.pad + ") must be an integer. Change the " +
                        "stride and/or zero pad parameters");
                    return _this;
                }

                MaxPool.prototype.feedForward = function (math, inferenceArrays) {
                    var _this = this;
                    var x = inferenceArrays.get(this.xTensor);
                    math.scope(function (keep) {
                        inferenceArrays.set(_this.yTensor, keep(math.maxPool(x, _this.fieldSize, _this.stride, _this.pad)));
                    });
                };
                MaxPool.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
                    var _this = this;
                    var x = inferenceArrays.get(this.xTensor);
                    var dy = gradientArrays.get(this.yTensor);
                    math.scope(function () {
                        gradientArrays.add(_this.xTensor, math.maxPoolBackprop(dy, x, _this.fieldSize, _this.stride, _this.pad));
                    });
                };
                return MaxPool;
            }(op_1.Operation));
            exports.MaxPool = MaxPool;

        }, {"../../math/conv_util": 92, "../../util": 101, "./op": 33}],
        32: [function (require, module, exports) {
            "use strict";
            var __extends = (this && this.__extends) || (function () {
                var extendStatics = Object.setPrototypeOf ||
                    ({__proto__: []} instanceof Array && function (d, b) {
                        d.__proto__ = b;
                    }) ||
                    function (d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                    };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d;
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            })();
            Object.defineProperty(exports, "__esModule", {value: true});
            var util = require("../../util");
            var graph_util = require("../graph_util");
            var op_1 = require("./op");
            var Multiply = (function (_super) {
                __extends(Multiply, _super);

                function Multiply(x1Tensor, x2Tensor, yTensor) {
                    var _this = _super.call(this) || this;
                    _this.x1Tensor = x1Tensor;
                    _this.x2Tensor = x2Tensor;
                    _this.yTensor = yTensor;
                    util.assert(util.sizeFromShape(x1Tensor.shape) === 1 ||
                        util.sizeFromShape(x2Tensor.shape) === 1 ||
                        util.arraysEqual(x1Tensor.shape, x2Tensor.shape), 'One of t1 or t2 must be a scalar, or t1 and t2 must have ' +
                        'the same shape');
                    return _this;
                }

                Multiply.prototype.feedForward = function (math, inferenceArrays) {
                    var _this = this;
                    var t1 = inferenceArrays.get(this.x1Tensor);
                    var t2 = inferenceArrays.get(this.x2Tensor);
                    math.scope(function (keep) {
                        var result;
                        if (util.isScalarShape(t1.shape)) {
                            result = math.scalarTimesArray(t1, t2);
                        } else if (util.isScalarShape(t2.shape)) {
                            result = math.scalarTimesArray(t2, t1);
                        } else {
                            result = math.elementWiseMul(t1, t2);
                        }
                        inferenceArrays.set(_this.yTensor, keep(result));
                    });
                };
                Multiply.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
                    var _this = this;
                    var x1 = inferenceArrays.get(this.x1Tensor);
                    var x2 = inferenceArrays.get(this.x2Tensor);
                    var dy = gradientArrays.get(this.yTensor);
                    math.scope(function () {
                        if (graph_util.shouldBackProp(_this.x1Tensor)) {
                            if (util.isScalarShape(_this.x1Tensor.shape)) {
                                var mul = math.elementWiseMul(dy, x2);
                                gradientArrays.add(_this.x1Tensor, math.sum(mul));
                            } else if (util.isScalarShape(x2.shape)) {
                                gradientArrays.add(_this.x1Tensor, math.scalarTimesArray(x2, dy));
                            } else {
                                gradientArrays.add(_this.x1Tensor, math.elementWiseMul(x2, dy));
                            }
                        }
                        if (graph_util.shouldBackProp(_this.x2Tensor)) {
                            if (util.isScalarShape(_this.x2Tensor.shape)) {
                                var mul = math.elementWiseMul(dy, x1);
                                gradientArrays.add(_this.x2Tensor, math.sum(mul));
                            } else if (util.isScalarShape(x1.shape)) {
                                gradientArrays.add(_this.x2Tensor, math.scalarTimesArray(x1, dy));
                            } else {
                                gradientArrays.add(_this.x2Tensor, math.elementWiseMul(x1, dy));
                            }
                        }
                    });
                };
                return Multiply;
            }(op_1.Operation));
            exports.Multiply = Multiply;

        }, {"../../util": 101, "../graph_util": 17, "./op": 33}],
        33: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var Operation = (function () {
                function Operation() {
                }

                Operation.prototype.disposeTransientArrays = function (inferenceArrays, gradientArrays) {
                };
                Operation.prototype.dispose = function () {
                };
                return Operation;
            }());
            exports.Operation = Operation;

        }, {}],
        34: [function (require, module, exports) {
            "use strict";
            var __extends = (this && this.__extends) || (function () {
                var extendStatics = Object.setPrototypeOf ||
                    ({__proto__: []} instanceof Array && function (d, b) {
                        d.__proto__ = b;
                    }) ||
                    function (d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                    };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d;
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            })();
            Object.defineProperty(exports, "__esModule", {value: true});
            var environment_1 = require("../../environment");
            var ndarray_1 = require("../../math/ndarray");
            var util = require("../../util");
            var graph_util = require("../graph_util");
            var op_1 = require("./op");
            var ReduceSum = (function (_super) {
                __extends(ReduceSum, _super);

                function ReduceSum(x, outTensor) {
                    var _this = _super.call(this) || this;
                    _this.x = x;
                    _this.outTensor = outTensor;
                    util.assertShapesMatch(outTensor.shape, []);
                    _this.ones = environment_1.ENV.math.keep(ndarray_1.NDArray.ones(x.shape));
                    return _this;
                }

                ReduceSum.prototype.feedForward = function (math, inferenceArrays) {
                    var _this = this;
                    var x = inferenceArrays.get(this.x);
                    math.scope(function (keep) {
                        inferenceArrays.set(_this.outTensor, keep(math.sum(x)));
                    });
                };
                ReduceSum.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
                    var _this = this;
                    if (!graph_util.shouldBackProp(this.x)) {
                        return;
                    }
                    math.scope(function () {
                        var dy = gradientArrays.get(_this.outTensor);
                        gradientArrays.add(_this.x, math.scalarTimesArray(dy, _this.ones));
                    });
                };
                ReduceSum.prototype.dispose = function () {
                    this.ones.dispose();
                };
                return ReduceSum;
            }(op_1.Operation));
            exports.ReduceSum = ReduceSum;

        }, {"../../environment": 15, "../../math/ndarray": 95, "../../util": 101, "../graph_util": 17, "./op": 33}],
        35: [function (require, module, exports) {
            "use strict";
            var __extends = (this && this.__extends) || (function () {
                var extendStatics = Object.setPrototypeOf ||
                    ({__proto__: []} instanceof Array && function (d, b) {
                        d.__proto__ = b;
                    }) ||
                    function (d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                    };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d;
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            })();
            Object.defineProperty(exports, "__esModule", {value: true});
            var util = require("../../util");
            var op_1 = require("./op");
            var Reshape = (function (_super) {
                __extends(Reshape, _super);

                function Reshape(xTensor, yTensor) {
                    var _this = _super.call(this) || this;
                    _this.xTensor = xTensor;
                    _this.yTensor = yTensor;
                    var xSize = util.sizeFromShape(xTensor.shape);
                    var ySize = util.sizeFromShape(yTensor.shape);
                    util.assert(xSize === ySize, "The input size (" + xSize + ") and output size (" + ySize + ") must match");
                    return _this;
                }

                Reshape.prototype.feedForward = function (math, inferenceArrays) {
                    var _this = this;
                    var x = inferenceArrays.get(this.xTensor);
                    var clone = math.clone(x);
                    math.scope(function (keep) {
                        inferenceArrays.set(_this.yTensor, keep(clone.reshape(_this.yTensor.shape)));
                    });
                };
                Reshape.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
                    var _this = this;
                    var dy = gradientArrays.get(this.yTensor);
                    var clone = math.clone(dy);
                    math.scope(function () {
                        gradientArrays.add(_this.xTensor, clone.reshape(_this.xTensor.shape));
                    });
                };
                return Reshape;
            }(op_1.Operation));
            exports.Reshape = Reshape;

        }, {"../../util": 101, "./op": 33}],
        36: [function (require, module, exports) {
            "use strict";
            var __extends = (this && this.__extends) || (function () {
                var extendStatics = Object.setPrototypeOf ||
                    ({__proto__: []} instanceof Array && function (d, b) {
                        d.__proto__ = b;
                    }) ||
                    function (d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                    };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d;
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            })();
            Object.defineProperty(exports, "__esModule", {value: true});
            var environment_1 = require("../../environment");
            var ndarray_1 = require("../../math/ndarray");
            var util = require("../../util");
            var graph_1 = require("../graph");
            var op_1 = require("./op");
            var Softmax = (function (_super) {
                __extends(Softmax, _super);

                function Softmax(logitsTensor, output) {
                    var _this = _super.call(this) || this;
                    _this.logitsTensor = logitsTensor;
                    _this.output = output;
                    return _this;
                }

                Softmax.prototype.feedForward = function (math, inferenceArrays) {
                    var _this = this;
                    var logits = inferenceArrays.get(this.logitsTensor);
                    return math.scope(function (keep) {
                        inferenceArrays.set(_this.output, keep(math.softmax(logits)));
                    });
                };
                Softmax.prototype.backProp = function () {
                    throw Error('Softmax backprop is not yet implemented');
                };
                return Softmax;
            }(op_1.Operation));
            exports.Softmax = Softmax;
            var SoftmaxCrossEntropyCost = (function (_super) {
                __extends(SoftmaxCrossEntropyCost, _super);

                function SoftmaxCrossEntropyCost(logitsTensor, labelTensor, yTensor) {
                    var _this = _super.call(this) || this;
                    _this.logitsTensor = logitsTensor;
                    _this.labelTensor = labelTensor;
                    _this.yTensor = yTensor;
                    _this.softmaxTensor = new graph_1.Tensor(logitsTensor.shape);
                    _this.epsilon = environment_1.ENV.math.keep(ndarray_1.Scalar.new(1e-5));
                    return _this;
                }

                SoftmaxCrossEntropyCost.prototype.feedForward = function (math, inferenceArrays) {
                    var _this = this;
                    var logits = inferenceArrays.get(this.logitsTensor);
                    var label = inferenceArrays.get(this.labelTensor);
                    math.scope(function (keep) {
                        var softmaxResult = math.softmax(logits);
                        inferenceArrays.set(_this.softmaxTensor, keep(softmaxResult));
                        inferenceArrays.set(_this.yTensor, keep(crossEntropyCost(math, softmaxResult, label, _this.epsilon)));
                    });
                };
                SoftmaxCrossEntropyCost.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
                    var _this = this;
                    var softmax = inferenceArrays.get(this.softmaxTensor);
                    var label = inferenceArrays.get(this.labelTensor);
                    math.scope(function () {
                        gradientArrays.add(_this.logitsTensor, math.subtract(softmax, label));
                    });
                };
                SoftmaxCrossEntropyCost.prototype.disposeTransientArrays = function (inferenceArrays, gradientArrays) {
                    inferenceArrays.disposeArray(this.softmaxTensor);
                };
                SoftmaxCrossEntropyCost.prototype.dispose = function () {
                    this.epsilon.dispose();
                };
                return SoftmaxCrossEntropyCost;
            }(op_1.Operation));
            exports.SoftmaxCrossEntropyCost = SoftmaxCrossEntropyCost;

            function crossEntropyCost(math, y, target, epsilon) {
                util.assert(y.size === target.size, 'The output and target must be the same size');
                return math.scope(function () {
                    var yPlusEps = math.scalarPlusArray(epsilon, y);
                    var logOutput = math.log(yPlusEps);
                    var tarLogOutput = math.elementWiseMul(target, logOutput);
                    var costVector = math.neg(tarLogOutput);
                    return math.sum(costVector);
                });
            }

            exports.crossEntropyCost = crossEntropyCost;

        }, {"../../environment": 15, "../../math/ndarray": 95, "../../util": 101, "../graph": 16, "./op": 33}],
        37: [function (require, module, exports) {
            "use strict";
            var __extends = (this && this.__extends) || (function () {
                var extendStatics = Object.setPrototypeOf ||
                    ({__proto__: []} instanceof Array && function (d, b) {
                        d.__proto__ = b;
                    }) ||
                    function (d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                    };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d;
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            })();
            Object.defineProperty(exports, "__esModule", {value: true});
            var util = require("../../util");
            var graph_util = require("../graph_util");
            var op_1 = require("./op");
            var Subtract = (function (_super) {
                __extends(Subtract, _super);

                function Subtract(t1, t2, outTensor) {
                    var _this = _super.call(this) || this;
                    _this.t1 = t1;
                    _this.t2 = t2;
                    _this.outTensor = outTensor;
                    util.assert(util.sizeFromShape(t1.shape) === 1 ||
                        util.sizeFromShape(t2.shape) === 1 ||
                        util.arraysEqual(t1.shape, t2.shape), 'One of t1 or t2 must be a scalar, or t1 and t2 must have ' +
                        'the same shape');
                    return _this;
                }

                Subtract.prototype.feedForward = function (math, inferenceArrays) {
                    var _this = this;
                    var t1 = inferenceArrays.get(this.t1);
                    var t2 = inferenceArrays.get(this.t2);
                    math.scope(function (keep) {
                        var result;
                        if (util.isScalarShape(t1.shape)) {
                            result = math.scalarMinusArray(t1, t2);
                        } else if (util.isScalarShape(t2.shape)) {
                            result = math.arrayMinusScalar(t1, t2);
                        } else {
                            result = math.subtract(t1, t2);
                        }
                        inferenceArrays.set(_this.outTensor, keep(result));
                    });
                };
                Subtract.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
                    var _this = this;
                    var dy = gradientArrays.get(this.outTensor);
                    math.scope(function () {
                        if (graph_util.shouldBackProp(_this.t1)) {
                            if (util.isScalarShape(_this.t1.shape)) {
                                var sum = math.sum(dy);
                                gradientArrays.add(_this.t1, sum);
                            } else {
                                gradientArrays.add(_this.t1, math.clone(dy));
                            }
                        }
                        if (graph_util.shouldBackProp(_this.t2)) {
                            if (util.isScalarShape(_this.t2.shape)) {
                                var sum = math.sum(dy);
                                var negSum = math.neg(sum);
                                gradientArrays.add(_this.t2, negSum);
                            } else {
                                gradientArrays.add(_this.t2, math.neg(dy));
                            }
                        }
                    });
                };
                Subtract.prototype.dispose = function () {
                    if (this.dySizeScalar != null) {
                        this.dySizeScalar.dispose();
                    }
                };
                return Subtract;
            }(op_1.Operation));
            exports.Subtract = Subtract;

        }, {"../../util": 101, "../graph_util": 17, "./op": 33}],
        38: [function (require, module, exports) {
            "use strict";
            var __extends = (this && this.__extends) || (function () {
                var extendStatics = Object.setPrototypeOf ||
                    ({__proto__: []} instanceof Array && function (d, b) {
                        d.__proto__ = b;
                    }) ||
                    function (d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                    };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d;
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            })();
            Object.defineProperty(exports, "__esModule", {value: true});
            var ndarray_1 = require("../../math/ndarray");
            var tensor_array_map_1 = require("../tensor_array_map");
            var optimizer_1 = require("./optimizer");
            var AdadeltaOptimizer = (function (_super) {
                __extends(AdadeltaOptimizer, _super);

                function AdadeltaOptimizer(learningRate, gamma, specifiedVariableList) {
                    var _this = _super.call(this, learningRate, specifiedVariableList) || this;
                    _this.learningRate = learningRate;
                    _this.gamma = gamma;
                    _this.accumulatedSquaredGradients = new tensor_array_map_1.TensorArrayMap();
                    _this.accumulatedUpdates = new tensor_array_map_1.TensorArrayMap();
                    _this.eps = ndarray_1.Scalar.new(1e-6);
                    _this.g = ndarray_1.Scalar.new(_this.gamma);
                    return _this;
                }

                AdadeltaOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
                    var _this = this;
                    _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);
                    if (this.accumulatedSquaredGradients.size() === 0) {
                        this.variableNodes.forEach(function (node) {
                            _this.accumulatedSquaredGradients.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
                            _this.accumulatedUpdates.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
                        });
                    }
                };
                AdadeltaOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
                    var _this = this;
                    math.scope(function (keep) {
                        _this.variableNodes.forEach(function (node) {
                            var oldVariable = activationArrayMap.get(node.output);
                            var gradient = _this.variableGradients.get(node.output);
                            var oldCache = _this.accumulatedSquaredGradients.get(node.output);
                            var oldUpdates = _this.accumulatedUpdates.get(node.output);
                            var gradientSquare = math.multiply(gradient, gradient);
                            var cache = math.scaledArrayAdd(_this.g, oldCache, math.subtract(_this.one, _this.g), gradientSquare);
                            var updates = math.multiply(math.divide(math.sqrt(math.add(oldUpdates, _this.eps)), math.sqrt(math.add(oldCache, _this.eps))), gradient);
                            var variable = math.scaledArrayAdd(_this.c, updates, _this.one, oldVariable);
                            var updateSquare = math.multiply(updates, updates);
                            var newUpdates = math.scaledArrayAdd(_this.g, oldUpdates, math.subtract(_this.one, _this.g), updateSquare);
                            _this.accumulatedSquaredGradients.set(node.output, keep(cache));
                            _this.accumulatedUpdates.set(node.output, keep(newUpdates));
                            activationArrayMap.set(node.output, keep(variable));
                            node.data = variable;
                            oldVariable.dispose();
                            oldCache.dispose();
                            oldUpdates.dispose();
                        });
                    });
                    this.variableGradients.dispose();
                    this.variableGradients = new tensor_array_map_1.TensorArrayMap();
                };
                AdadeltaOptimizer.prototype.dispose = function () {
                    _super.prototype.dispose.call(this);
                    this.eps.dispose();
                    this.g.dispose();
                    this.accumulatedSquaredGradients.dispose();
                    this.accumulatedUpdates.dispose();
                };
                return AdadeltaOptimizer;
            }(optimizer_1.Optimizer));
            exports.AdadeltaOptimizer = AdadeltaOptimizer;

        }, {"../../math/ndarray": 95, "../tensor_array_map": 49, "./optimizer": 43}],
        39: [function (require, module, exports) {
            "use strict";
            var __extends = (this && this.__extends) || (function () {
                var extendStatics = Object.setPrototypeOf ||
                    ({__proto__: []} instanceof Array && function (d, b) {
                        d.__proto__ = b;
                    }) ||
                    function (d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                    };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d;
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            })();
            Object.defineProperty(exports, "__esModule", {value: true});
            var ndarray_1 = require("../../math/ndarray");
            var tensor_array_map_1 = require("../tensor_array_map");
            var optimizer_1 = require("./optimizer");
            var AdagradOptimizer = (function (_super) {
                __extends(AdagradOptimizer, _super);

                function AdagradOptimizer(learningRate, specifiedVariableList) {
                    var _this = _super.call(this, learningRate, specifiedVariableList) || this;
                    _this.learningRate = learningRate;
                    _this.accumulatedSquaredGradients = new tensor_array_map_1.TensorArrayMap();
                    _this.eps = ndarray_1.Scalar.new(1e-6);
                    return _this;
                }

                AdagradOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
                    var _this = this;
                    _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);
                    if (this.accumulatedSquaredGradients.size() === 0) {
                        this.variableNodes.forEach(function (node) {
                            _this.accumulatedSquaredGradients.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
                        });
                    }
                };
                AdagradOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
                    var _this = this;
                    math.scope(function (keep) {
                        _this.variableNodes.forEach(function (node) {
                            var oldVariable = activationArrayMap.get(node.output);
                            var gradient = _this.variableGradients.get(node.output);
                            var oldCache = _this.accumulatedSquaredGradients.get(node.output);
                            var gradientSquare = math.multiply(gradient, gradient);
                            var cache = math.add(oldCache, gradientSquare);
                            var variable = math.scaledArrayAdd(_this.c, math.divide(gradient, math.add(math.sqrt(cache), _this.eps)), _this.one, oldVariable);
                            _this.accumulatedSquaredGradients.set(node.output, keep(cache));
                            activationArrayMap.set(node.output, keep(variable));
                            node.data = variable;
                            oldVariable.dispose();
                            oldCache.dispose();
                        });
                    });
                    this.variableGradients.dispose();
                    this.variableGradients = new tensor_array_map_1.TensorArrayMap();
                };
                AdagradOptimizer.prototype.dispose = function () {
                    _super.prototype.dispose.call(this);
                    this.eps.dispose();
                    this.accumulatedSquaredGradients.dispose();
                };
                return AdagradOptimizer;
            }(optimizer_1.Optimizer));
            exports.AdagradOptimizer = AdagradOptimizer;

        }, {"../../math/ndarray": 95, "../tensor_array_map": 49, "./optimizer": 43}],
        40: [function (require, module, exports) {
            "use strict";
            var __extends = (this && this.__extends) || (function () {
                var extendStatics = Object.setPrototypeOf ||
                    ({__proto__: []} instanceof Array && function (d, b) {
                        d.__proto__ = b;
                    }) ||
                    function (d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                    };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d;
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            })();
            Object.defineProperty(exports, "__esModule", {value: true});
            var ndarray_1 = require("../../math/ndarray");
            var tensor_array_map_1 = require("../tensor_array_map");
            var optimizer_1 = require("./optimizer");
            var AdamOptimizer = (function (_super) {
                __extends(AdamOptimizer, _super);

                function AdamOptimizer(learningRate, beta1, beta2, specifiedVariableList) {
                    var _this = _super.call(this, learningRate, specifiedVariableList) || this;
                    _this.learningRate = learningRate;
                    _this.beta1 = beta1;
                    _this.beta2 = beta2;
                    _this.firstMoment = new tensor_array_map_1.TensorArrayMap();
                    _this.secondMoment = new tensor_array_map_1.TensorArrayMap();
                    _this.eps = ndarray_1.Scalar.new(1e-8);
                    _this.b1 = ndarray_1.Scalar.new(_this.beta1);
                    _this.b2 = ndarray_1.Scalar.new(_this.beta2);
                    _this.accB1 = ndarray_1.Scalar.new(_this.beta1);
                    _this.accB2 = ndarray_1.Scalar.new(_this.beta2);
                    return _this;
                }

                AdamOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
                    var _this = this;
                    _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);
                    if (this.firstMoment.size() === 0) {
                        this.variableNodes.forEach(function (node) {
                            _this.firstMoment.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
                        });
                    }
                    if (this.secondMoment.size() === 0) {
                        this.variableNodes.forEach(function (node) {
                            _this.secondMoment.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
                        });
                    }
                };
                AdamOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
                    var _this = this;
                    math.scope(function (keep) {
                        _this.variableNodes.forEach(function (node) {
                            var oldVariable = activationArrayMap.get(node.output);
                            var gradient = _this.variableGradients.get(node.output);
                            var oldFirstMoment = _this.firstMoment.get(node.output);
                            var oldSecondMoment = _this.secondMoment.get(node.output);
                            var newFirstMoment = math.scaledArrayAdd(_this.b1, oldFirstMoment, math.subtract(_this.one, _this.b1), gradient);
                            var gradientSquare = math.multiply(gradient, gradient);
                            var newSecondMoment = math.scaledArrayAdd(_this.b2, oldSecondMoment, math.subtract(_this.one, _this.b2), gradientSquare);
                            var biasCorrectedFirstMoment = math.divide(newFirstMoment, math.subtract(_this.one, _this.accB1));
                            var biasCorrectedSecondMoment = math.divide(newSecondMoment, math.subtract(_this.one, _this.accB2));
                            var variable = math.scaledArrayAdd(_this.c, math.divide(biasCorrectedFirstMoment, math.add(math.sqrt(biasCorrectedSecondMoment), _this.eps)), _this.one, oldVariable);
                            activationArrayMap.set(node.output, keep(variable));
                            node.data = variable;
                            _this.firstMoment.set(node.output, keep(newFirstMoment));
                            _this.secondMoment.set(node.output, keep(newSecondMoment));
                            oldVariable.dispose();
                            gradient.dispose();
                            oldFirstMoment.dispose();
                            oldSecondMoment.dispose();
                        });
                        var oldAccB1 = _this.accB1;
                        var oldAccB2 = _this.accB2;
                        _this.accB1 = keep(math.multiply(_this.accB1, _this.b1));
                        _this.accB2 = keep(math.multiply(_this.accB2, _this.b2));
                        oldAccB1.dispose();
                        oldAccB2.dispose();
                    });
                    this.variableGradients.dispose();
                    this.variableGradients = new tensor_array_map_1.TensorArrayMap();
                };
                AdamOptimizer.prototype.dispose = function () {
                    _super.prototype.dispose.call(this);
                    this.firstMoment.dispose();
                    this.secondMoment.dispose();
                    this.eps.dispose();
                    this.b1.dispose();
                    this.b2.dispose();
                    this.accB1.dispose();
                    this.accB2.dispose();
                };
                return AdamOptimizer;
            }(optimizer_1.Optimizer));
            exports.AdamOptimizer = AdamOptimizer;

        }, {"../../math/ndarray": 95, "../tensor_array_map": 49, "./optimizer": 43}],
        41: [function (require, module, exports) {
            "use strict";
            var __extends = (this && this.__extends) || (function () {
                var extendStatics = Object.setPrototypeOf ||
                    ({__proto__: []} instanceof Array && function (d, b) {
                        d.__proto__ = b;
                    }) ||
                    function (d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                    };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d;
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            })();
            Object.defineProperty(exports, "__esModule", {value: true});
            var ndarray_1 = require("../../math/ndarray");
            var tensor_array_map_1 = require("../tensor_array_map");
            var optimizer_1 = require("./optimizer");
            var AdamaxOptimizer = (function (_super) {
                __extends(AdamaxOptimizer, _super);

                function AdamaxOptimizer(learningRate, beta1, beta2, specifiedVariableList) {
                    var _this = _super.call(this, learningRate, specifiedVariableList) || this;
                    _this.learningRate = learningRate;
                    _this.beta1 = beta1;
                    _this.beta2 = beta2;
                    _this.firstMoment = new tensor_array_map_1.TensorArrayMap();
                    _this.weightedInfNorm = new tensor_array_map_1.TensorArrayMap();
                    _this.eps = ndarray_1.Scalar.new(1e-8);
                    _this.b1 = ndarray_1.Scalar.new(_this.beta1);
                    _this.b2 = ndarray_1.Scalar.new(_this.beta2);
                    _this.accB1 = ndarray_1.Scalar.new(_this.beta1);
                    return _this;
                }

                AdamaxOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
                    var _this = this;
                    _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);
                    if (this.firstMoment.size() === 0) {
                        this.variableNodes.forEach(function (node) {
                            _this.firstMoment.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
                        });
                    }
                    if (this.weightedInfNorm.size() === 0) {
                        this.variableNodes.forEach(function (node) {
                            _this.weightedInfNorm.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
                        });
                    }
                };
                AdamaxOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
                    var _this = this;
                    math.scope(function (keep) {
                        _this.variableNodes.forEach(function (node) {
                            var oldVariable = activationArrayMap.get(node.output);
                            var gradient = _this.variableGradients.get(node.output);
                            var oldFirstMoment = _this.firstMoment.get(node.output);
                            var oldWeightedInfNorm = _this.weightedInfNorm.get(node.output);
                            var newFirstMoment = math.scaledArrayAdd(_this.b1, oldFirstMoment, math.subtract(_this.one, _this.b1), gradient);
                            var ut0 = math.multiply(_this.b2, oldWeightedInfNorm);
                            var ut1 = math.abs(gradient);
                            var newWeightedInfNorm = math.add(math.relu(math.subtract(ut0, ut1)), ut1);
                            var variable = math.scaledArrayAdd(_this.one, oldVariable, math.divide(_this.c, math.subtract(_this.one, _this.accB1)), math.divide(newFirstMoment, math.add(_this.eps, newWeightedInfNorm)));
                            activationArrayMap.set(node.output, keep(variable));
                            node.data = variable;
                            _this.firstMoment.set(node.output, keep(newFirstMoment));
                            _this.weightedInfNorm.set(node.output, keep(newWeightedInfNorm));
                            oldVariable.dispose();
                            gradient.dispose();
                            oldFirstMoment.dispose();
                            oldWeightedInfNorm.dispose();
                        });
                        var oldAccB1 = _this.accB1;
                        _this.accB1 = keep(math.multiply(_this.accB1, _this.b1));
                        oldAccB1.dispose();
                    });
                    this.variableGradients.dispose();
                    this.variableGradients = new tensor_array_map_1.TensorArrayMap();
                };
                AdamaxOptimizer.prototype.dispose = function () {
                    _super.prototype.dispose.call(this);
                    this.firstMoment.dispose();
                    this.weightedInfNorm.dispose();
                    this.eps.dispose();
                    this.accB1.dispose();
                    this.b1.dispose();
                    this.b2.dispose();
                };
                return AdamaxOptimizer;
            }(optimizer_1.Optimizer));
            exports.AdamaxOptimizer = AdamaxOptimizer;

        }, {"../../math/ndarray": 95, "../tensor_array_map": 49, "./optimizer": 43}],
        42: [function (require, module, exports) {
            "use strict";
            var __extends = (this && this.__extends) || (function () {
                var extendStatics = Object.setPrototypeOf ||
                    ({__proto__: []} instanceof Array && function (d, b) {
                        d.__proto__ = b;
                    }) ||
                    function (d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                    };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d;
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            })();
            Object.defineProperty(exports, "__esModule", {value: true});
            var ndarray_1 = require("../../math/ndarray");
            var tensor_array_map_1 = require("../tensor_array_map");
            var sgd_optimizer_1 = require("./sgd_optimizer");
            var MomentumOptimizer = (function (_super) {
                __extends(MomentumOptimizer, _super);

                function MomentumOptimizer(learningRate, momentum, specifiedVariableList) {
                    var _this = _super.call(this, learningRate, specifiedVariableList) || this;
                    _this.learningRate = learningRate;
                    _this.momentum = momentum;
                    _this.variableVelocities = new tensor_array_map_1.TensorArrayMap();
                    _this.m = ndarray_1.Scalar.new(_this.momentum);
                    return _this;
                }

                MomentumOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
                    var _this = this;
                    _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);
                    if (this.variableVelocities.size() === 0) {
                        this.variableNodes.forEach(function (node) {
                            _this.variableVelocities.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
                        });
                    }
                };
                MomentumOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
                    var _this = this;
                    math.scope(function (keep) {
                        _this.variableNodes.forEach(function (node) {
                            var oldVariable = activationArrayMap.get(node.output);
                            var gradient = _this.variableGradients.get(node.output);
                            var oldVelocity = _this.variableVelocities.get(node.output);
                            var velocity = math.scaledArrayAdd(_this.m, oldVelocity, _this.one, gradient);
                            var variable = math.scaledArrayAdd(_this.c, velocity, _this.one, oldVariable);
                            _this.variableVelocities.set(node.output, keep(velocity));
                            activationArrayMap.set(node.output, keep(variable));
                            node.data = variable;
                            oldVariable.dispose();
                            oldVelocity.dispose();
                        });
                    });
                    this.variableGradients.dispose();
                    this.variableGradients = new tensor_array_map_1.TensorArrayMap();
                };
                MomentumOptimizer.prototype.dispose = function () {
                    _super.prototype.dispose.call(this);
                    this.m.dispose();
                    this.variableVelocities.dispose();
                };
                MomentumOptimizer.prototype.setMomentum = function (momentum) {
                    this.momentum = momentum;
                };
                return MomentumOptimizer;
            }(sgd_optimizer_1.SGDOptimizer));
            exports.MomentumOptimizer = MomentumOptimizer;

        }, {"../../math/ndarray": 95, "../tensor_array_map": 49, "./sgd_optimizer": 45}],
        43: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var environment_1 = require("../../environment");
            var ndarray_1 = require("../../math/ndarray");
            var session_util = require("../session_util");
            var tensor_array_map_1 = require("../tensor_array_map");
            var Optimizer = (function () {
                function Optimizer(learningRate, specifiedVariableList) {
                    this.learningRate = learningRate;
                    this.variableGradients = new tensor_array_map_1.TensorArrayMap();
                    if (specifiedVariableList != null) {
                        this.specifiedVariableNodes = specifiedVariableList;
                    }
                    this.one = environment_1.ENV.math.keep(ndarray_1.Scalar.new(1));
                }

                Optimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
                    var _this = this;
                    this.variableNodes = this.specifiedVariableNodes == null ?
                        session_util.getVariableNodesFromEvaluationSet(runtime.nodes) :
                        this.specifiedVariableNodes;
                    if (batchSize !== this.prevBatchSize) {
                        if (this.c != null) {
                            this.c.dispose();
                        }
                        this.prevBatchSize = batchSize;
                        this.c = math.keep(ndarray_1.Scalar.new(-this.learningRate / batchSize));
                    }
                    this.variableNodes.forEach(function (node) {
                        return _this.variableGradients.set(node.output, math.keep(ndarray_1.NDArray.zeros(node.output.shape)));
                    });
                };
                Optimizer.prototype.afterExample = function (math, runtime, activationArrayMap, gradientArrayMap) {
                    var _this = this;
                    math.scope(function (keep) {
                        _this.variableNodes.forEach(function (node) {
                            var gradient = gradientArrayMap.get(node.output);
                            var accumulatedGradient = _this.variableGradients.get(node.output);
                            _this.variableGradients.set(node.output, keep(math.add(gradient, accumulatedGradient)));
                            accumulatedGradient.dispose();
                        });
                    });
                };
                Optimizer.prototype.dispose = function () {
                    if (this.c != null) {
                        this.c.dispose();
                    }
                    this.one.dispose();
                    this.variableNodes.forEach(function (node) {
                        node.data.dispose();
                    });
                    this.specifiedVariableNodes.forEach(function (node) {
                        node.data.dispose();
                    });
                };
                return Optimizer;
            }());
            exports.Optimizer = Optimizer;

        }, {"../../environment": 15, "../../math/ndarray": 95, "../session_util": 48, "../tensor_array_map": 49}],
        44: [function (require, module, exports) {
            "use strict";
            var __extends = (this && this.__extends) || (function () {
                var extendStatics = Object.setPrototypeOf ||
                    ({__proto__: []} instanceof Array && function (d, b) {
                        d.__proto__ = b;
                    }) ||
                    function (d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                    };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d;
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            })();
            Object.defineProperty(exports, "__esModule", {value: true});
            var ndarray_1 = require("../../math/ndarray");
            var tensor_array_map_1 = require("../tensor_array_map");
            var optimizer_1 = require("./optimizer");
            var RMSPropOptimizer = (function (_super) {
                __extends(RMSPropOptimizer, _super);

                function RMSPropOptimizer(learningRate, gamma, specifiedVariableList) {
                    var _this = _super.call(this, learningRate, specifiedVariableList) || this;
                    _this.learningRate = learningRate;
                    _this.gamma = gamma;
                    _this.accumulatedSquaredGradients = new tensor_array_map_1.TensorArrayMap();
                    _this.eps = ndarray_1.Scalar.new(1e-6);
                    _this.g = ndarray_1.Scalar.new(_this.gamma);
                    return _this;
                }

                RMSPropOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
                    var _this = this;
                    _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);
                    if (this.accumulatedSquaredGradients.size() === 0) {
                        this.variableNodes.forEach(function (node) {
                            _this.accumulatedSquaredGradients.set(node.output, ndarray_1.NDArray.zeros(node.output.shape));
                        });
                    }
                };
                RMSPropOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
                    var _this = this;
                    math.scope(function (keep) {
                        _this.variableNodes.forEach(function (node) {
                            var oldVariable = activationArrayMap.get(node.output);
                            var gradient = _this.variableGradients.get(node.output);
                            var oldCache = _this.accumulatedSquaredGradients.get(node.output);
                            var gradientSquare = math.multiply(gradient, gradient);
                            var cache = math.scaledArrayAdd(_this.g, oldCache, math.subtract(_this.one, _this.g), gradientSquare);
                            var variable = math.scaledArrayAdd(_this.c, math.divide(gradient, math.add(math.sqrt(cache), _this.eps)), _this.one, oldVariable);
                            _this.accumulatedSquaredGradients.set(node.output, keep(cache));
                            activationArrayMap.set(node.output, keep(variable));
                            node.data = variable;
                            oldVariable.dispose();
                            oldCache.dispose();
                        });
                    });
                    this.variableGradients.dispose();
                    this.variableGradients = new tensor_array_map_1.TensorArrayMap();
                };
                RMSPropOptimizer.prototype.dispose = function () {
                    _super.prototype.dispose.call(this);
                    this.eps.dispose();
                    this.g.dispose();
                    this.accumulatedSquaredGradients.dispose();
                };
                return RMSPropOptimizer;
            }(optimizer_1.Optimizer));
            exports.RMSPropOptimizer = RMSPropOptimizer;

        }, {"../../math/ndarray": 95, "../tensor_array_map": 49, "./optimizer": 43}],
        45: [function (require, module, exports) {
            "use strict";
            var __extends = (this && this.__extends) || (function () {
                var extendStatics = Object.setPrototypeOf ||
                    ({__proto__: []} instanceof Array && function (d, b) {
                        d.__proto__ = b;
                    }) ||
                    function (d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                    };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d;
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            })();
            Object.defineProperty(exports, "__esModule", {value: true});
            var tensor_array_map_1 = require("../tensor_array_map");
            var optimizer_1 = require("./optimizer");
            var SGDOptimizer = (function (_super) {
                __extends(SGDOptimizer, _super);

                function SGDOptimizer(learningRate, specifiedVariableList) {
                    var _this = _super.call(this, learningRate, specifiedVariableList) || this;
                    _this.learningRate = learningRate;
                    return _this;
                }

                SGDOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
                    var _this = this;
                    math.scope(function (keep) {
                        _this.variableNodes.forEach(function (node) {
                            var oldVariable = activationArrayMap.get(node.output);
                            var gradient = _this.variableGradients.get(node.output);
                            var variable = math.scaledArrayAdd(_this.c, gradient, _this.one, oldVariable);
                            activationArrayMap.set(node.output, keep(variable));
                            node.data = variable;
                            oldVariable.dispose();
                        });
                    });
                    this.variableGradients.dispose();
                    this.variableGradients = new tensor_array_map_1.TensorArrayMap();
                };
                SGDOptimizer.prototype.dispose = function () {
                    _super.prototype.dispose.call(this);
                };
                SGDOptimizer.prototype.setLearningRate = function (learningRate) {
                    this.learningRate = learningRate;
                };
                return SGDOptimizer;
            }(optimizer_1.Optimizer));
            exports.SGDOptimizer = SGDOptimizer;

        }, {"../tensor_array_map": 49, "./optimizer": 43}],
        46: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});

            function defaultCompare(a, b) {
                if (a === b) {
                    return 0;
                } else if (a < b) {
                    return -1;
                } else {
                    return 1;
                }
            }

            exports.defaultCompare = defaultCompare;
            var PriorityQueue = (function () {
                function PriorityQueue(comparator, indexObserver) {
                    this.comparator = comparator;
                    this.indexObserver = indexObserver;
                    this.heap = [];
                }

                PriorityQueue.prototype.enqueue = function (t) {
                    this.heap.push(t);
                    this.onIndexChanged(t, this.heap.length - 1);
                    this.siftUp(this.heap.length - 1);
                };
                PriorityQueue.prototype.dequeue = function () {
                    if (this.empty()) {
                        throw new Error('dequeue called on empty priority queue.');
                    }
                    var t = this.heap[0];
                    this.swap(0, this.heap.length - 1);
                    this.heap.pop();
                    this.siftDown(0);
                    return t;
                };
                PriorityQueue.prototype.update = function (newT, index) {
                    var last = (index === this.heap.length - 1);
                    if (!last) {
                        this.swap(index, this.heap.length - 1);
                    }
                    this.heap.pop();
                    if (!last) {
                        if (this.siftUpIndex(index) !== -1) {
                            this.siftUp(index);
                        } else if (this.siftDownIndex(index) !== -1) {
                            this.siftDown(index);
                        }
                    }
                    this.enqueue(newT);
                };
                PriorityQueue.prototype.empty = function () {
                    return this.heap.length === 0;
                };
                PriorityQueue.prototype.onIndexChanged = function (t, newIndex) {
                    if (this.indexObserver) {
                        this.indexObserver(t, newIndex);
                    }
                };
                PriorityQueue.prototype.getParentIndex = function (index) {
                    if (index === 0) {
                        return -1;
                    }
                    return Math.floor((index - 1) / 2);
                };
                PriorityQueue.prototype.getLeftChildIndex = function (index) {
                    var candidate = index * 2 + 1;
                    return candidate < this.heap.length ? candidate : -1;
                };
                PriorityQueue.prototype.getRightChildIndex = function (index) {
                    var candidate = index * 2 + 2;
                    return candidate < this.heap.length ? candidate : -1;
                };
                PriorityQueue.prototype.siftUpIndex = function (index) {
                    var parentIndex = this.getParentIndex(index);
                    if (parentIndex === -1) {
                        return -1;
                    }
                    if (this.compare(parentIndex, index) > 0) {
                        return parentIndex;
                    }
                    return -1;
                };
                PriorityQueue.prototype.siftUp = function (index) {
                    var siftIndex = this.siftUpIndex(index);
                    while (siftIndex !== -1) {
                        this.swap(index, siftIndex);
                        index = siftIndex;
                        siftIndex = this.siftUpIndex(index);
                    }
                };
                PriorityQueue.prototype.siftDownIndex = function (index) {
                    if (index >= this.heap.length) {
                        return -1;
                    }
                    var largestChildIndex = index;
                    var leftChildIndex = this.getLeftChildIndex(index);
                    if ((leftChildIndex !== -1) &&
                        (this.compare(leftChildIndex, largestChildIndex) < 0)) {
                        largestChildIndex = leftChildIndex;
                    }
                    var rightChildIndex = this.getRightChildIndex(index);
                    if ((rightChildIndex !== -1) &&
                        (this.compare(rightChildIndex, largestChildIndex) < 0)) {
                        largestChildIndex = rightChildIndex;
                    }
                    return (largestChildIndex === index) ? -1 : largestChildIndex;
                };
                PriorityQueue.prototype.siftDown = function (index) {
                    var siftIndex = this.siftDownIndex(index);
                    while (siftIndex !== -1) {
                        this.swap(index, siftIndex);
                        index = siftIndex;
                        siftIndex = this.siftDownIndex(index);
                    }
                };
                PriorityQueue.prototype.compare = function (aIndex, bIndex) {
                    return this.comparator(this.heap[aIndex], this.heap[bIndex]);
                };
                PriorityQueue.prototype.swap = function (a, b) {
                    var temp = this.heap[a];
                    this.heap[a] = this.heap[b];
                    this.heap[b] = temp;
                    this.onIndexChanged(this.heap[a], a);
                    this.onIndexChanged(this.heap[b], b);
                };
                return PriorityQueue;
            }());
            exports.PriorityQueue = PriorityQueue;

        }, {}],
        47: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var ndarray_1 = require("../math/ndarray");
            var util = require("../util");
            var operation_emitter = require("./operation_emitter");
            var session_util = require("./session_util");
            var tensor_array_map_1 = require("./tensor_array_map");
            var FeedDictionary = (function () {
                function FeedDictionary(feedEntries) {
                    var _this = this;
                    this.dict = {};
                    if (feedEntries) {
                        feedEntries.forEach(function (entry) {
                            return _this.dict[entry.tensor.id] = entry;
                        });
                    }
                }

                return FeedDictionary;
            }());
            exports.FeedDictionary = FeedDictionary;
            var CostReduction;
            (function (CostReduction) {
                CostReduction[CostReduction["NONE"] = 0] = "NONE";
                CostReduction[CostReduction["SUM"] = 1] = "SUM";
                CostReduction[CostReduction["MEAN"] = 2] = "MEAN";
            })(CostReduction = exports.CostReduction || (exports.CostReduction = {}));
            var Session = (function () {
                function Session(graph, math) {
                    this.math = math;
                    this.activationArrayMap = new tensor_array_map_1.TensorArrayMap();
                    this.runtimeCache = {};
                    this.oneScalar = ndarray_1.Scalar.new(1);
                    this.gradientArrayMap = new tensor_array_map_1.SummedTensorArrayMap(this.math);
                }

                Session.prototype.dispose = function () {
                    var _this = this;
                    this.activationArrayMap.dispose();
                    Object.keys(this.runtimeCache).forEach(function (key) {
                        var runtime = _this.runtimeCache[key];
                        if (runtime.operations) {
                            runtime.operations.forEach(function (op) {
                                return op.dispose();
                            });
                        }
                    });
                    this.runtimeCache = {};
                    if (this.batchSizeScalar != null) {
                        this.batchSizeScalar.dispose();
                    }
                    this.oneScalar.dispose();
                };
                Session.prototype.evalAll = function (tensors, feedEntries) {
                    var _this = this;
                    return this.math.scope(function () {
                        var feed = new FeedDictionary(feedEntries);
                        var runtime = _this.getOrCreateRuntime(tensors, feed);
                        var activations = _this.activationArrayMap;
                        session_util.disposeAndInitializeOperationOutputs(runtime.nodes, activations);
                        session_util.disposeTransientOperationArrays(runtime.operations, _this.activationArrayMap, _this.gradientArrayMap);
                        session_util.addPersistentArraysToTensorArrayMap(runtime.nodes, activations);
                        session_util.loadInputsFromFeedDictionaryToTensorArrayMap(feed, activations, _this.math);
                        runtime.operations.forEach(function (op) {
                            return op.feedForward(_this.math, activations);
                        });
                        var results = tensors.map(function (x) {
                            return activations.get(x);
                        });
                        tensors.forEach(function (x) {
                            return activations.delete(x);
                        });
                        session_util.releaseFeedDictionaryInputsFromTensorArrayMap(feed, activations, _this.math);
                        return results;
                    });
                };
                Session.prototype.eval = function (tensor, feedEntries) {
                    return this.evalAll([tensor], feedEntries)[0];
                };
                Session.prototype.train = function (costTensor, feedEntries, batchSize, optimizer, costReduction) {
                    var _this = this;
                    if (costReduction === void 0) {
                        costReduction = CostReduction.NONE;
                    }
                    util.assert(util.isScalarShape(costTensor.shape), 'Cost tensor for training must be a scalar value.');
                    if (this.prevBatchSize !== batchSize) {
                        this.prevBatchSize = batchSize;
                        if (this.batchSizeScalar != null) {
                            this.batchSizeScalar.dispose();
                        }
                        this.batchSizeScalar = this.math.keep(ndarray_1.Scalar.new(batchSize));
                    }
                    var feed = new FeedDictionary(feedEntries);
                    session_util.throwIfFeedDictionaryContainsNDArrays(feed);
                    var runtime = this.getOrCreateRuntime([costTensor], feed);
                    var inferenceOperations = runtime.operations;
                    var backPropOperations = runtime.operations.slice().reverse();
                    var activations = this.activationArrayMap;
                    var gradients = this.gradientArrayMap;
                    gradients.nullify(costTensor);
                    gradients.add(costTensor, this.oneScalar);
                    session_util.addPersistentArraysToTensorArrayMap(runtime.nodes, activations);
                    optimizer.beforeBatch(this.math, batchSize, runtime, activations, gradients);
                    return this.math.scope(function () {
                        var cost = ndarray_1.Scalar.new(0);
                        for (var i = 0; i < batchSize; ++i) {
                            session_util.disposeAndInitializeOperationOutputs(runtime.nodes, activations);
                            session_util.disposeAndInitializeOperationInputGradients(runtime.nodes, gradients);
                            session_util.disposeTransientOperationArrays(runtime.operations, activations, gradients);
                            session_util.loadInputsFromFeedDictionaryToTensorArrayMap(feed, activations, _this.math);
                            inferenceOperations.forEach(function (op) {
                                return op.feedForward(_this.math, activations);
                            });
                            backPropOperations.forEach(function (op) {
                                return op.backProp(_this.math, activations, gradients);
                            });
                            optimizer.afterExample(_this.math, runtime, activations, gradients);
                            session_util.releaseFeedDictionaryInputsFromTensorArrayMap(feed, activations, _this.math);
                            cost = _this.updateCostForExample(cost, activations.get(costTensor), costReduction);
                        }
                        optimizer.afterBatch(_this.math, batchSize, runtime, activations, gradients);
                        return _this.updateCostForBatch(cost, costReduction);
                    });
                };
                Session.prototype.updateCostForExample = function (totalCost, currCost, costReduction) {
                    if (costReduction === CostReduction.MEAN ||
                        costReduction === CostReduction.SUM) {
                        return this.math.add(totalCost, currCost);
                    }
                    return totalCost;
                };
                Session.prototype.updateCostForBatch = function (totalCost, costReduction) {
                    if (costReduction === CostReduction.MEAN) {
                        return this.math.divide(totalCost, this.batchSizeScalar);
                    }
                    return totalCost;
                };
                Session.prototype.getOrCreateRuntime = function (tensors, feed) {
                    var key = this.makeRuntimeCacheKey(tensors, feed);
                    var runtime = this.runtimeCache[key];
                    if (runtime === undefined) {
                        var nodes = session_util.getOrderedEvaluationSetFromEvalTensor(tensors, feed);
                        session_util.removeFeedDictionaryNodesFromEvaluationSet(feed, nodes);
                        session_util.throwErrorIfEvaluationSetContainsPlaceholderNodes(nodes);
                        var operations = operation_emitter.emitFromGraphNodes(nodes);
                        runtime = {nodes: nodes, operations: operations};
                        this.runtimeCache[key] = runtime;
                    }
                    return runtime;
                };
                Session.prototype.makeRuntimeCacheKey = function (tensors, feed) {
                    return tensors.map(function (x) {
                            return x.id;
                        }).sort().join('_') + '__' +
                        Object.keys(feed.dict).sort().join('_');
                };
                return Session;
            }());
            exports.Session = Session;

        }, {
            "../math/ndarray": 95,
            "../util": 101,
            "./operation_emitter": 18,
            "./session_util": 48,
            "./tensor_array_map": 49
        }],
        48: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var ndarray_1 = require("../math/ndarray");
            var util = require("../util");
            var graph_1 = require("./graph");
            var graph_util = require("./graph_util");

            function getTerminatingNodesFromFeedDictionary(feedDictionary) {
                return Object.keys(feedDictionary.dict)
                    .map(function (tensorID) {
                        return feedDictionary.dict[+tensorID].tensor.node;
                    });
            }

            exports.getTerminatingNodesFromFeedDictionary = getTerminatingNodesFromFeedDictionary;

            function getOrderedEvaluationSetFromEvalTensor(evalTensors, feedDictionary) {
                var terminatingNodes = getTerminatingNodesFromFeedDictionary(feedDictionary);
                var evalNodes = evalTensors.map(function (x) {
                    return x.node;
                });
                var unorderedEvaluationSet = graph_util.getUnorderedEvaluationSet(evalNodes, terminatingNodes);
                var orderedEvaluationSet = graph_util.getOrderedEvaluationSet(unorderedEvaluationSet);
                return orderedEvaluationSet;
            }

            exports.getOrderedEvaluationSetFromEvalTensor = getOrderedEvaluationSetFromEvalTensor;

            function addPersistentArraysToTensorArrayMap(evaluationSet, tensorArrayMap) {
                evaluationSet.forEach(function (node) {
                    if (node instanceof graph_1.VariableNode || node instanceof graph_1.ConstantNode) {
                        tensorArrayMap.set(node.output, node.data);
                    }
                });
            }

            exports.addPersistentArraysToTensorArrayMap = addPersistentArraysToTensorArrayMap;

            function getVariableNodesFromEvaluationSet(evaluationSet) {
                var nodes = [];
                evaluationSet.forEach(function (node) {
                    if (node instanceof graph_1.VariableNode) {
                        nodes.push(node);
                    }
                });
                return nodes;
            }

            exports.getVariableNodesFromEvaluationSet = getVariableNodesFromEvaluationSet;

            function throwIfFeedDictionaryContainsNDArrays(feedDictionary) {
                Object.keys(feedDictionary.dict).forEach(function (tensorID) {
                    if (feedDictionary.dict[+tensorID].data instanceof ndarray_1.NDArray) {
                        throw new Error('training requires FeedDictionary entries to be InputProviders' +
                            'and not NDArrays.');
                    }
                });
            }

            exports.throwIfFeedDictionaryContainsNDArrays = throwIfFeedDictionaryContainsNDArrays;

            function loadInputsFromFeedDictionaryToTensorArrayMap(batchFeed, activations, math) {
                Object.keys(batchFeed.dict).forEach(function (tensorID) {
                    var feedEntry = batchFeed.dict[+tensorID];
                    var data;
                    if (feedEntry.data instanceof ndarray_1.NDArray) {
                        data = feedEntry.data;
                    } else {
                        var provider = feedEntry.data;
                        data = provider.getNextCopy(math);
                    }
                    util.assert(util.arraysEqual(feedEntry.tensor.shape, data.shape), "Error loading FeedEntry: feeding NDArray of shape " + data.shape + " " +
                        ("does not match Tensor (id: " + feedEntry.tensor.id + ") shape: ") +
                        (feedEntry.tensor.shape + "."));
                    activations.set(feedEntry.tensor, data);
                });
            }

            exports.loadInputsFromFeedDictionaryToTensorArrayMap = loadInputsFromFeedDictionaryToTensorArrayMap;

            function releaseFeedDictionaryInputsFromTensorArrayMap(batchFeed, activations, math) {
                Object.keys(batchFeed.dict).forEach(function (tensorID) {
                    var feedEntry = batchFeed.dict[+tensorID];
                    if (!(feedEntry.data instanceof ndarray_1.NDArray)) {
                        var provider = feedEntry.data;
                        var feedEntryArray = activations.get(feedEntry.tensor);
                        provider.disposeCopy(math, feedEntryArray);
                    }
                    activations.delete(feedEntry.tensor);
                });
            }

            exports.releaseFeedDictionaryInputsFromTensorArrayMap = releaseFeedDictionaryInputsFromTensorArrayMap;

            function removeFeedDictionaryNodesFromEvaluationSet(feedDictionary, evaluationSet) {
                var i = 0;
                while (i < evaluationSet.length) {
                    var node = evaluationSet[i];
                    if (feedDictionary.dict[node.output.id] != null) {
                        evaluationSet.splice(i, 1);
                    } else {
                        ++i;
                    }
                }
            }

            exports.removeFeedDictionaryNodesFromEvaluationSet = removeFeedDictionaryNodesFromEvaluationSet;

            function disposeAndInitializeOperationOutputs(evaluationSet, tensorArrayMap) {
                evaluationSet.forEach(function (node) {
                    if (!graph_util.isInputNode(node)) {
                        if (!graph_util.isPassthroughNode(node, tensorArrayMap)) {
                            tensorArrayMap.disposeArray(node.output);
                        }
                        tensorArrayMap.set(node.output, null);
                    }
                });
            }

            exports.disposeAndInitializeOperationOutputs = disposeAndInitializeOperationOutputs;

            function disposeAndInitializeOperationInputGradients(evaluationSet, gradients) {
                evaluationSet.forEach(function (node) {
                    Object.keys(node.inputs).forEach(function (inputName) {
                        var input = node.inputs[inputName];
                        if (gradients.get(input, true) !== gradients.get(node.output, true)) {
                            gradients.disposeArray(input);
                        }
                        gradients.nullify(input);
                    });
                });
            }

            exports.disposeAndInitializeOperationInputGradients = disposeAndInitializeOperationInputGradients;

            function disposeTransientOperationArrays(operations, activations, gradients) {
                operations.forEach(function (op) {
                    return op.disposeTransientArrays(activations, gradients);
                });
            }

            exports.disposeTransientOperationArrays = disposeTransientOperationArrays;

            function throwErrorIfEvaluationSetContainsPlaceholderNodes(evaluationSet) {
                evaluationSet.forEach(function (node) {
                    if (node instanceof graph_1.PlaceholderNode) {
                        var shape = '[' + node.output.shape.join(', ') + ']';
                        throw new Error('Placeholder node "' + node.name + '" ' + shape +
                            ' not present in feed dictionary.');
                    }
                });
            }

            exports.throwErrorIfEvaluationSetContainsPlaceholderNodes = throwErrorIfEvaluationSetContainsPlaceholderNodes;

        }, {"../math/ndarray": 95, "../util": 101, "./graph": 16, "./graph_util": 17}],
        49: [function (require, module, exports) {
            "use strict";
            var __extends = (this && this.__extends) || (function () {
                var extendStatics = Object.setPrototypeOf ||
                    ({__proto__: []} instanceof Array && function (d, b) {
                        d.__proto__ = b;
                    }) ||
                    function (d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                    };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d;
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            })();
            Object.defineProperty(exports, "__esModule", {value: true});
            var TensorArrayMapBase = (function () {
                function TensorArrayMapBase() {
                    this.dict = {};
                }

                TensorArrayMapBase.prototype.get = function (tensor, skipChecks) {
                    if (skipChecks === void 0) {
                        skipChecks = false;
                    }
                    if (!skipChecks && this.dict[tensor.id] === undefined) {
                        throw new Error("tensor " + tensor.id + " not in array map.");
                    }
                    var nda = this.dict[tensor.id];
                    if (!skipChecks && nda === null) {
                        throw new Error("tensor " + tensor.id + " has null array.");
                    }
                    return nda;
                };
                TensorArrayMapBase.prototype.delete = function (tensor) {
                    delete this.dict[tensor.id];
                };
                TensorArrayMapBase.prototype.nullify = function (tensor) {
                    this.dict[tensor.id] = null;
                };
                TensorArrayMapBase.prototype.disposeArray = function (tensor) {
                    if (this.dict[tensor.id] === undefined) {
                        return;
                    }
                    var nda = this.dict[tensor.id];
                    if (nda === null) {
                        return;
                    }
                    nda.dispose();
                    this.dict[tensor.id] = null;
                };
                TensorArrayMapBase.prototype.size = function () {
                    return Object.keys(this.dict).length;
                };
                TensorArrayMapBase.prototype.dispose = function () {
                    var _this = this;
                    Object.keys(this.dict).forEach(function (tensorID) {
                        var nda = _this.dict[+tensorID];
                        if (nda) {
                            nda.dispose();
                        }
                    });
                    this.dict = {};
                };
                TensorArrayMapBase.prototype.hasNullArray = function (tensor) {
                    if (this.dict[tensor.id] === undefined) {
                        throw new Error("tensor " + tensor.id + " not in array map.");
                    }
                    return this.dict[tensor.id] === null;
                };
                return TensorArrayMapBase;
            }());
            exports.TensorArrayMapBase = TensorArrayMapBase;
            var TensorArrayMap = (function (_super) {
                __extends(TensorArrayMap, _super);

                function TensorArrayMap() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }

                TensorArrayMap.prototype.set = function (tensor, array) {
                    this.dict[tensor.id] = array;
                };
                return TensorArrayMap;
            }(TensorArrayMapBase));
            exports.TensorArrayMap = TensorArrayMap;
            var SummedTensorArrayMap = (function (_super) {
                __extends(SummedTensorArrayMap, _super);

                function SummedTensorArrayMap(math) {
                    var _this = _super.call(this) || this;
                    _this.math = math;
                    return _this;
                }

                SummedTensorArrayMap.prototype.add = function (tensor, array) {
                    if (this.dict[tensor.id] == null) {
                        this.dict[tensor.id] = this.math.keep(array);
                    } else {
                        var oldValue = this.get(tensor);
                        var newValue = this.math.keep(this.math.addStrict(oldValue, array));
                        this.dict[tensor.id] = newValue;
                        oldValue.dispose();
                    }
                };
                return SummedTensorArrayMap;
            }(TensorArrayMapBase));
            exports.SummedTensorArrayMap = SummedTensorArrayMap;

        }, {}],
        50: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var session_1 = require("./graph/session");
            var ndarray_1 = require("./math/ndarray");
            var DEFAULT_EVAL_INTERVAL_MS = 1500;
            var DEFAULT_COST_INTERVAL_MS = 500;
            var DEFAULT_INFERENCE_EXAMPLE_INTERVAL_MS = 3000;
            var MetricReduction;
            (function (MetricReduction) {
                MetricReduction[MetricReduction["SUM"] = 0] = "SUM";
                MetricReduction[MetricReduction["MEAN"] = 1] = "MEAN";
            })(MetricReduction = exports.MetricReduction || (exports.MetricReduction = {}));
            var GraphRunner = (function () {
                function GraphRunner(math, session, eventObserver) {
                    this.math = math;
                    this.session = session;
                    this.eventObserver = eventObserver;
                    this.lastCostTimestamp = 0;
                    this.lastEvalTimestamp = 0;
                    this.resetStatistics();
                    this.zeroScalar = ndarray_1.Scalar.new(0);
                }

                GraphRunner.prototype.resetStatistics = function () {
                    this.totalBatchesTrained = 0;
                };
                GraphRunner.prototype.train = function (costTensor, trainFeedEntries, batchSize, optimizer, numBatches, metricTensor, metricFeedEntries, metricBatchSize, metricReduction, evalIntervalMs, costIntervalMs) {
                    if (metricReduction === void 0) {
                        metricReduction = MetricReduction.MEAN;
                    }
                    if (evalIntervalMs === void 0) {
                        evalIntervalMs = DEFAULT_EVAL_INTERVAL_MS;
                    }
                    if (costIntervalMs === void 0) {
                        costIntervalMs = DEFAULT_COST_INTERVAL_MS;
                    }
                    this.costTensor = costTensor;
                    this.trainFeedEntries = trainFeedEntries;
                    this.metricTensor = metricTensor;
                    this.metricFeedEntries = metricFeedEntries;
                    if (metricBatchSize != null && this.metricBatchSize !== metricBatchSize) {
                        if (this.metricBatchSizeScalar != null) {
                            this.metricBatchSizeScalar.dispose();
                        }
                        this.metricBatchSizeScalar = ndarray_1.Scalar.new(metricBatchSize);
                    }
                    this.metricBatchSize = metricBatchSize;
                    this.metricReduction = metricReduction;
                    this.batchSize = batchSize;
                    this.optimizer = optimizer;
                    this.metricIntervalMs = evalIntervalMs;
                    this.costIntervalMs = costIntervalMs;
                    this.currentTrainLoopNumBatches = numBatches;
                    this.batchesTrainedThisRun = 0;
                    this.isTraining = true;
                    this.trainStartTimestamp = performance.now();
                    this.trainNetwork();
                };
                GraphRunner.prototype.stopTraining = function () {
                    this.isTraining = false;
                };
                GraphRunner.prototype.resumeTraining = function () {
                    this.isTraining = true;
                    this.trainNetwork();
                };
                GraphRunner.prototype.trainNetwork = function () {
                    var _this = this;
                    if (this.batchesTrainedThisRun === this.currentTrainLoopNumBatches) {
                        this.stopTraining();
                    }
                    if (!this.isTraining) {
                        if (this.eventObserver.doneTrainingCallback != null) {
                            this.eventObserver.doneTrainingCallback();
                        }
                        return;
                    }
                    var start = performance.now();
                    var shouldComputeCost = this.eventObserver.avgCostCallback != null &&
                        (start - this.lastCostTimestamp > this.costIntervalMs);
                    if (shouldComputeCost) {
                        this.lastCostTimestamp = start;
                    }
                    var costReduction = shouldComputeCost ? session_1.CostReduction.MEAN : session_1.CostReduction.NONE;
                    this.math.scope(function (keep) {
                        var avgCost = _this.session.train(_this.costTensor, _this.trainFeedEntries, _this.batchSize, _this.optimizer, costReduction);
                        if (shouldComputeCost) {
                            var trainTime = performance.now() - start;
                            _this.eventObserver.avgCostCallback(avgCost);
                            if (_this.eventObserver.trainExamplesPerSecCallback != null) {
                                var examplesPerSec = (_this.batchSize * 1000 / trainTime);
                                _this.eventObserver.trainExamplesPerSecCallback(examplesPerSec);
                            }
                        }
                        if (_this.eventObserver.metricCallback != null &&
                            _this.metricFeedEntries != null &&
                            start - _this.lastEvalTimestamp > _this.metricIntervalMs) {
                            _this.lastEvalTimestamp = start;
                            if (_this.lastComputedMetric != null) {
                                _this.lastComputedMetric.dispose();
                            }
                            _this.lastComputedMetric = _this.computeMetric();
                            _this.eventObserver.metricCallback(_this.lastComputedMetric);
                        }
                        if (_this.eventObserver.totalTimeCallback != null) {
                            _this.eventObserver.totalTimeCallback((start - _this.trainStartTimestamp) / 1000);
                        }
                        _this.batchesTrainedThisRun++;
                        _this.totalBatchesTrained++;
                        if (_this.eventObserver.batchesTrainedCallback != null) {
                            _this.eventObserver.batchesTrainedCallback(_this.totalBatchesTrained);
                        }
                    });
                    requestAnimationFrame(function () {
                        return _this.trainNetwork();
                    });
                };
                GraphRunner.prototype.infer = function (inferenceTensor, inferenceFeedEntries, inferenceExampleIntervalMs, inferenceExampleCount, numPasses) {
                    var _this = this;
                    if (inferenceExampleIntervalMs === void 0) {
                        inferenceExampleIntervalMs = DEFAULT_INFERENCE_EXAMPLE_INTERVAL_MS;
                    }
                    if (inferenceExampleCount === void 0) {
                        inferenceExampleCount = 5;
                    }
                    if (this.eventObserver.inferenceExamplesCallback == null &&
                        this.eventObserver.inferenceExamplesPerSecCallback == null) {
                        throw new Error('Cannot start inference loop, no inference example or ' +
                            'examples/sec observer provided.');
                    }
                    for (var i = 0; i < inferenceFeedEntries.length; i++) {
                        var feedEntry = inferenceFeedEntries[i];
                        if (feedEntry.data instanceof ndarray_1.NDArray) {
                            throw new Error('Cannot start inference on the model runner with feed entries of ' +
                                'type NDArray. Please use InputProviders.');
                        }
                    }
                    this.inferenceExampleIntervalMs = inferenceExampleIntervalMs;
                    this.inferenceTensor = inferenceTensor;
                    this.inferenceFeedEntries = inferenceFeedEntries;
                    this.inferenceExampleCount = inferenceExampleCount;
                    this.currentInferenceLoopNumPasses = numPasses;
                    if (!this.isInferring) {
                        this.inferencePassesThisRun = 0;
                        requestAnimationFrame(function () {
                            return _this.inferNetwork();
                        });
                    }
                    this.isInferring = true;
                };
                GraphRunner.prototype.inferNetwork = function () {
                    var _this = this;
                    if (!this.isInferring ||
                        this.inferencePassesThisRun === this.currentInferenceLoopNumPasses) {
                        return;
                    }
                    this.math.scope(function (keep) {
                        var feeds = [];
                        var inferenceValues = [];
                        var start = performance.now();
                        for (var i = 0; i < _this.inferenceExampleCount; i++) {
                            var ndarrayFeedEntries = [];
                            for (var j = 0; j < _this.inferenceFeedEntries.length; j++) {
                                var feedEntry = _this.inferenceFeedEntries[j];
                                var nextCopy = feedEntry.data.getNextCopy(_this.math);
                                ndarrayFeedEntries.push({tensor: feedEntry.tensor, data: nextCopy});
                            }
                            feeds.push(ndarrayFeedEntries);
                            inferenceValues.push(_this.session.eval(_this.inferenceTensor, ndarrayFeedEntries));
                        }
                        if (_this.eventObserver.inferenceExamplesPerSecCallback != null) {
                            inferenceValues[inferenceValues.length - 1].getValues();
                            var inferenceExamplesPerSecTime = performance.now() - start;
                            var examplesPerSec = (_this.inferenceExampleCount * 1000 / inferenceExamplesPerSecTime);
                            _this.eventObserver.inferenceExamplesPerSecCallback(examplesPerSec);
                        }
                        if (_this.eventObserver.inferenceExamplesCallback != null) {
                            _this.eventObserver.inferenceExamplesCallback(feeds, inferenceValues);
                        }
                        _this.inferencePassesThisRun++;
                    });
                    this.lastInferTimeoutID = window.setTimeout(function () {
                        return _this.inferNetwork();
                    }, this.inferenceExampleIntervalMs);
                };
                GraphRunner.prototype.stopInferring = function () {
                    this.isInferring = false;
                    window.clearTimeout(this.lastInferTimeoutID);
                };
                GraphRunner.prototype.isInferenceRunning = function () {
                    return this.isInferring;
                };
                GraphRunner.prototype.computeMetric = function () {
                    var _this = this;
                    if (this.metricFeedEntries == null) {
                        throw new Error('Cannot compute metric, no metric FeedEntries provided.');
                    }
                    var metric = this.zeroScalar;
                    return this.math.scope(function (keep) {
                        for (var i = 0; i < _this.metricBatchSize; i++) {
                            var metricValue = _this.session.eval(_this.metricTensor, _this.metricFeedEntries);
                            metric = _this.math.add(metric, metricValue);
                        }
                        if (_this.metricReduction === MetricReduction.MEAN) {
                            metric = _this.math.divide(metric, _this.metricBatchSizeScalar);
                        }
                        return metric;
                    });
                };
                GraphRunner.prototype.getTotalBatchesTrained = function () {
                    return this.totalBatchesTrained;
                };
                GraphRunner.prototype.getLastComputedMetric = function () {
                    return this.lastComputedMetric;
                };
                GraphRunner.prototype.setMath = function (math) {
                    this.math = math;
                };
                GraphRunner.prototype.setSession = function (session) {
                    this.session = session;
                };
                GraphRunner.prototype.setInferenceTensor = function (inferenceTensor) {
                    this.inferenceTensor = inferenceTensor;
                };
                GraphRunner.prototype.setInferenceExampleCount = function (inferenceExampleCount) {
                    this.inferenceExampleCount = inferenceExampleCount;
                };
                return GraphRunner;
            }());
            exports.GraphRunner = GraphRunner;

        }, {"./graph/session": 47, "./math/ndarray": 95}],
        51: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var xhr_dataset = require("./data/xhr-dataset");
            exports.xhr_dataset = xhr_dataset;
            var environment = require("./environment");
            exports.environment = environment;
            var gpgpu_util = require("./math/backends/webgl/gpgpu_util");
            exports.gpgpu_util = gpgpu_util;
            var render_ndarray_gpu_util = require("./math/backends/webgl/render_ndarray_gpu_util");
            exports.render_ndarray_gpu_util = render_ndarray_gpu_util;
            var webgl_util = require("./math/backends/webgl/webgl_util");
            exports.webgl_util = webgl_util;
            var conv_util = require("./math/conv_util");
            exports.conv_util = conv_util;
            var test_util = require("./test_util");
            exports.test_util = test_util;
            var util = require("./util");
            exports.util = util;
            var version_1 = require("./version");
            exports.version = version_1.version;
            var checkpoint_loader_1 = require("./data/checkpoint_loader");
            exports.CheckpointLoader = checkpoint_loader_1.CheckpointLoader;
            var dataset_1 = require("./data/dataset");
            exports.InMemoryDataset = dataset_1.InMemoryDataset;
            var input_provider_1 = require("./data/input_provider");
            exports.InCPUMemoryShuffledInputProviderBuilder = input_provider_1.InCPUMemoryShuffledInputProviderBuilder;
            exports.InGPUMemoryShuffledInputProviderBuilder = input_provider_1.InGPUMemoryShuffledInputProviderBuilder;
            var xhr_dataset_1 = require("./data/xhr-dataset");
            exports.XhrDataset = xhr_dataset_1.XhrDataset;
            var environment_1 = require("./environment");
            exports.ENV = environment_1.ENV;
            exports.Environment = environment_1.Environment;
            var graph_1 = require("./graph/graph");
            exports.Graph = graph_1.Graph;
            exports.Tensor = graph_1.Tensor;
            var adadelta_optimizer_1 = require("./graph/optimizers/adadelta_optimizer");
            exports.AdadeltaOptimizer = adadelta_optimizer_1.AdadeltaOptimizer;
            var adagrad_optimizer_1 = require("./graph/optimizers/adagrad_optimizer");
            exports.AdagradOptimizer = adagrad_optimizer_1.AdagradOptimizer;
            var adam_optimizer_1 = require("./graph/optimizers/adam_optimizer");
            exports.AdamOptimizer = adam_optimizer_1.AdamOptimizer;
            var adamax_optimizer_1 = require("./graph/optimizers/adamax_optimizer");
            exports.AdamaxOptimizer = adamax_optimizer_1.AdamaxOptimizer;
            var momentum_optimizer_1 = require("./graph/optimizers/momentum_optimizer");
            exports.MomentumOptimizer = momentum_optimizer_1.MomentumOptimizer;
            var optimizer_1 = require("./graph/optimizers/optimizer");
            exports.Optimizer = optimizer_1.Optimizer;
            var rmsprop_optimizer_1 = require("./graph/optimizers/rmsprop_optimizer");
            exports.RMSPropOptimizer = rmsprop_optimizer_1.RMSPropOptimizer;
            var sgd_optimizer_1 = require("./graph/optimizers/sgd_optimizer");
            exports.SGDOptimizer = sgd_optimizer_1.SGDOptimizer;
            var session_1 = require("./graph/session");
            exports.CostReduction = session_1.CostReduction;
            exports.Session = session_1.Session;
            var graph_runner_1 = require("./graph_runner");
            exports.GraphRunner = graph_runner_1.GraphRunner;
            exports.MetricReduction = graph_runner_1.MetricReduction;
            var initializers_1 = require("./initializers");
            exports.ConstantInitializer = initializers_1.ConstantInitializer;
            exports.NDArrayInitializer = initializers_1.NDArrayInitializer;
            exports.OnesInitializer = initializers_1.OnesInitializer;
            exports.RandomNormalInitializer = initializers_1.RandomNormalInitializer;
            exports.RandomTruncatedNormalInitializer = initializers_1.RandomTruncatedNormalInitializer;
            exports.RandomUniformInitializer = initializers_1.RandomUniformInitializer;
            exports.VarianceScalingInitializer = initializers_1.VarianceScalingInitializer;
            exports.ZerosInitializer = initializers_1.ZerosInitializer;
            var backend_cpu_1 = require("./math/backends/backend_cpu");
            exports.MathBackendCPU = backend_cpu_1.MathBackendCPU;
            exports.NDArrayMathCPU = backend_cpu_1.NDArrayMathCPU;
            var backend_webgl_1 = require("./math/backends/backend_webgl");
            exports.MathBackendWebGL = backend_webgl_1.MathBackendWebGL;
            exports.NDArrayMathGPU = backend_webgl_1.NDArrayMathGPU;
            var matmul_1 = require("./math/backends/types/matmul");
            exports.MatrixOrientation = matmul_1.MatrixOrientation;
            var gpgpu_context_1 = require("./math/backends/webgl/gpgpu_context");
            exports.GPGPUContext = gpgpu_context_1.GPGPUContext;
            var math_1 = require("./math/math");
            exports.NDArrayMath = math_1.NDArrayMath;
            var ndarray_1 = require("./math/ndarray");
            exports.Array1D = ndarray_1.Array1D;
            exports.Array2D = ndarray_1.Array2D;
            exports.Array3D = ndarray_1.Array3D;
            exports.Array4D = ndarray_1.Array4D;
            exports.NDArray = ndarray_1.NDArray;
            exports.Scalar = ndarray_1.Scalar;

        }, {
            "./data/checkpoint_loader": 10,
            "./data/dataset": 11,
            "./data/input_provider": 12,
            "./data/xhr-dataset": 13,
            "./environment": 15,
            "./graph/graph": 16,
            "./graph/optimizers/adadelta_optimizer": 38,
            "./graph/optimizers/adagrad_optimizer": 39,
            "./graph/optimizers/adam_optimizer": 40,
            "./graph/optimizers/adamax_optimizer": 41,
            "./graph/optimizers/momentum_optimizer": 42,
            "./graph/optimizers/optimizer": 43,
            "./graph/optimizers/rmsprop_optimizer": 44,
            "./graph/optimizers/sgd_optimizer": 45,
            "./graph/session": 47,
            "./graph_runner": 50,
            "./initializers": 52,
            "./math/backends/backend_cpu": 55,
            "./math/backends/backend_webgl": 57,
            "./math/backends/types/matmul": 61,
            "./math/backends/webgl/gpgpu_context": 71,
            "./math/backends/webgl/gpgpu_util": 73,
            "./math/backends/webgl/render_ndarray_gpu_util": 80,
            "./math/backends/webgl/webgl_util": 89,
            "./math/conv_util": 92,
            "./math/math": 94,
            "./math/ndarray": 95,
            "./test_util": 100,
            "./util": 101,
            "./version": 102
        }],
        52: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var ndarray_1 = require("./math/ndarray");
            var VarianceScalingInitializer = (function () {
                function VarianceScalingInitializer(scale, mode, distribution) {
                    if (scale === void 0) {
                        scale = 1.0;
                    }
                    if (mode === void 0) {
                        mode = 'fan_in';
                    }
                    if (distribution === void 0) {
                        distribution = 'normal';
                    }
                    this.scale = scale;
                    this.mode = mode;
                    this.distribution = distribution;
                }

                VarianceScalingInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
                    var n = 0;
                    if (this.mode === 'fan_in') {
                        n = inputUnits;
                    } else if (this.mode === 'fan_out') {
                        n = outputUnits;
                    } else if (this.mode === 'fan_avg') {
                        n = (inputUnits + outputUnits) / 2;
                    } else {
                        throw new Error("Unexpected mode for variance scaling initializer: " + this.mode);
                    }
                    if (this.distribution === 'normal') {
                        return ndarray_1.NDArray.randTruncatedNormal(weightsShape, 0.0, Math.sqrt(this.scale / n));
                    } else if (this.distribution === 'uniform') {
                        return ndarray_1.NDArray.randUniform(weightsShape, 0.0, Math.sqrt(3 * this.scale / n));
                    } else {
                        throw new Error("Unexpected distribution for variance scaling initializer: " +
                            ("" + this.distribution));
                    }
                };
                return VarianceScalingInitializer;
            }());
            exports.VarianceScalingInitializer = VarianceScalingInitializer;
            var ZerosInitializer = (function () {
                function ZerosInitializer() {
                }

                ZerosInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
                    return ndarray_1.NDArray.zeros(weightsShape);
                };
                return ZerosInitializer;
            }());
            exports.ZerosInitializer = ZerosInitializer;
            var OnesInitializer = (function () {
                function OnesInitializer() {
                }

                OnesInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
                    var values = ndarray_1.NDArray.zeros(weightsShape);
                    values.fill(1);
                    return values;
                };
                return OnesInitializer;
            }());
            exports.OnesInitializer = OnesInitializer;
            var ConstantInitializer = (function () {
                function ConstantInitializer(value) {
                    if (value === void 0) {
                        value = 0;
                    }
                    this.value = value;
                }

                ConstantInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
                    var values = ndarray_1.NDArray.zeros(weightsShape);
                    values.fill(this.value);
                    return values;
                };
                return ConstantInitializer;
            }());
            exports.ConstantInitializer = ConstantInitializer;
            var NDArrayInitializer = (function () {
                function NDArrayInitializer(ndarray) {
                    this.ndarray = ndarray;
                }

                NDArrayInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
                    return this.ndarray;
                };
                return NDArrayInitializer;
            }());
            exports.NDArrayInitializer = NDArrayInitializer;
            var RandomNormalInitializer = (function () {
                function RandomNormalInitializer(mean, stdev) {
                    if (mean === void 0) {
                        mean = 0;
                    }
                    if (stdev === void 0) {
                        stdev = .05;
                    }
                    this.mean = mean;
                    this.stdev = stdev;
                }

                RandomNormalInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
                    return ndarray_1.NDArray.randNormal(weightsShape, this.mean, this.stdev);
                };
                return RandomNormalInitializer;
            }());
            exports.RandomNormalInitializer = RandomNormalInitializer;
            var RandomTruncatedNormalInitializer = (function () {
                function RandomTruncatedNormalInitializer(mean, stdev) {
                    if (mean === void 0) {
                        mean = 0;
                    }
                    if (stdev === void 0) {
                        stdev = .05;
                    }
                    this.mean = mean;
                    this.stdev = stdev;
                }

                RandomTruncatedNormalInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
                    return ndarray_1.NDArray.randTruncatedNormal(weightsShape, this.mean, this.stdev);
                };
                return RandomTruncatedNormalInitializer;
            }());
            exports.RandomTruncatedNormalInitializer = RandomTruncatedNormalInitializer;
            var RandomUniformInitializer = (function () {
                function RandomUniformInitializer(minval, maxval) {
                    if (minval === void 0) {
                        minval = -.05;
                    }
                    if (maxval === void 0) {
                        maxval = .05;
                    }
                    this.minval = minval;
                    this.maxval = maxval;
                }

                RandomUniformInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
                    return ndarray_1.NDArray.randUniform(weightsShape, this.minval, this.maxval);
                };
                return RandomUniformInitializer;
            }());
            exports.RandomUniformInitializer = RandomUniformInitializer;

        }, {"./math/ndarray": 95}],
        53: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var ndarray_1 = require("./ndarray");
            var TanHFunc = (function () {
                function TanHFunc() {
                    this.one = ndarray_1.Scalar.new(1);
                }

                TanHFunc.prototype.output = function (math, x) {
                    return math.tanh(x);
                };
                TanHFunc.prototype.der = function (math, x, y) {
                    var _this = this;
                    return math.scope(function () {
                        var ySquared = math.elementWiseMul(y, y);
                        return math.scalarMinusArray(_this.one, ySquared);
                    });
                };
                TanHFunc.prototype.dispose = function () {
                    this.one.dispose();
                };
                return TanHFunc;
            }());
            exports.TanHFunc = TanHFunc;
            var ReLUFunc = (function () {
                function ReLUFunc() {
                }

                ReLUFunc.prototype.output = function (math, x) {
                    return math.relu(x);
                };
                ReLUFunc.prototype.der = function (math, x, y) {
                    return math.step(x);
                };
                ReLUFunc.prototype.dispose = function () {
                };
                return ReLUFunc;
            }());
            exports.ReLUFunc = ReLUFunc;
            var LeakyReluFunc = (function () {
                function LeakyReluFunc(alpha) {
                    this.alpha = alpha;
                }

                LeakyReluFunc.prototype.output = function (math, x) {
                    return math.leakyRelu(x, this.alpha);
                };
                LeakyReluFunc.prototype.der = function (math, x, y) {
                    return math.step(x, this.alpha);
                };
                LeakyReluFunc.prototype.dispose = function () {
                };
                return LeakyReluFunc;
            }());
            exports.LeakyReluFunc = LeakyReluFunc;
            var SigmoidFunc = (function () {
                function SigmoidFunc() {
                }

                SigmoidFunc.prototype.output = function (math, x) {
                    return math.sigmoid(x);
                };
                SigmoidFunc.prototype.der = function (math, x, y) {
                    return math.scope(function () {
                        var ySquared = math.elementWiseMul(y, y);
                        return math.subStrict(y, ySquared);
                    });
                };
                SigmoidFunc.prototype.dispose = function () {
                };
                return SigmoidFunc;
            }());
            exports.SigmoidFunc = SigmoidFunc;
            var SquareFunc = (function () {
                function SquareFunc() {
                    this.two = ndarray_1.Scalar.new(2);
                }

                SquareFunc.prototype.output = function (math, x) {
                    return math.elementWiseMul(x, x);
                };
                SquareFunc.prototype.der = function (math, x, y) {
                    return math.scalarTimesArray(this.two, x);
                };
                SquareFunc.prototype.dispose = function () {
                    this.two.dispose();
                };
                return SquareFunc;
            }());
            exports.SquareFunc = SquareFunc;
            var EluFunc = (function () {
                function EluFunc() {
                }

                EluFunc.prototype.output = function (math, x) {
                    return math.elu(x);
                };
                EluFunc.prototype.der = function (math, x, y) {
                    return math.eluDer(x);
                };
                EluFunc.prototype.dispose = function () {
                };
                return EluFunc;
            }());
            exports.EluFunc = EluFunc;

        }, {"./ndarray": 95}],
        54: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});

            function axesAreInnerMostDims(axes, rank) {
                for (var i = 0; i < axes.length; ++i) {
                    if (axes[axes.length - i - 1] !== rank - 1 - i) {
                        return false;
                    }
                }
                return true;
            }

            exports.axesAreInnerMostDims = axesAreInnerMostDims;

            function combineLocations(outputLoc, reduceLoc, axes) {
                var rank = outputLoc.length + reduceLoc.length;
                var loc = [];
                var outIdx = 0;
                var reduceIdx = 0;
                for (var dim = 0; dim < rank; dim++) {
                    if (axes.indexOf(dim) === -1) {
                        loc.push(outputLoc[outIdx++]);
                    } else {
                        loc.push(reduceLoc[reduceIdx++]);
                    }
                }
                return loc;
            }

            exports.combineLocations = combineLocations;

            function computeOutAndReduceShapes(aShape, axes) {
                var outShape = [];
                var rank = aShape.length;
                for (var dim = 0; dim < rank; dim++) {
                    if (axes.indexOf(dim) === -1) {
                        outShape.push(aShape[dim]);
                    }
                }
                var reduceShape = axes.map(function (dim) {
                    return aShape[dim];
                });
                return [outShape, reduceShape];
            }

            exports.computeOutAndReduceShapes = computeOutAndReduceShapes;

            function expandShapeToKeepDim(shape, axes) {
                var reduceSubShape = axes.map(function (x) {
                    return 1;
                });
                return combineLocations(shape, reduceSubShape, axes);
            }

            exports.expandShapeToKeepDim = expandShapeToKeepDim;

            function parseAxisParam(axis, shape) {
                if (axis == null) {
                    axis = shape.map(function (s, i) {
                        return i;
                    });
                } else if (typeof (axis) === 'number') {
                    axis = [axis];
                }
                return axis;
            }

            exports.parseAxisParam = parseAxisParam;

            function assertAxesAreInnerMostDims(msg, axes, rank) {
                if (!axesAreInnerMostDims(axes, rank)) {
                    throw new Error(msg + " supports only inner-most axes for now. " +
                        ("Got axes " + axes + " and rank-" + rank + " input."));
                }
            }

            exports.assertAxesAreInnerMostDims = assertAxesAreInnerMostDims;

            function getPermutedAxes(axes, rank) {
                if (axesAreInnerMostDims(axes, rank)) {
                    return null;
                }
                var result = [];
                for (var i = 0; i < rank; ++i) {
                    if (axes.indexOf(i) === -1) {
                        result.push(i);
                    }
                }
                axes.forEach(function (axis) {
                    return result.push(axis);
                });
                return result;
            }

            exports.getPermutedAxes = getPermutedAxes;

            function getInnerMostAxes(numAxes, rank) {
                var res = [];
                for (var i = rank - numAxes; i < rank; ++i) {
                    res.push(i);
                }
                return res;
            }

            exports.getInnerMostAxes = getInnerMostAxes;

        }, {}],
        55: [function (require, module, exports) {
            "use strict";
            var __extends = (this && this.__extends) || (function () {
                var extendStatics = Object.setPrototypeOf ||
                    ({__proto__: []} instanceof Array && function (d, b) {
                        d.__proto__ = b;
                    }) ||
                    function (d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                    };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d;
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            })();
            var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) {
                        try {
                            step(generator.next(value));
                        } catch (e) {
                            reject(e);
                        }
                    }

                    function rejected(value) {
                        try {
                            step(generator["throw"](value));
                        } catch (e) {
                            reject(e);
                        }
                    }

                    function step(result) {
                        result.done ? resolve(result.value) : new P(function (resolve) {
                            resolve(result.value);
                        }).then(fulfilled, rejected);
                    }

                    step((generator = generator.apply(thisArg, _arguments || [])).next());
                });
            };
            var __generator = (this && this.__generator) || function (thisArg, body) {
                var _ = {
                    label: 0, sent: function () {
                        if (t[0] & 1) throw t[1];
                        return t[1];
                    }, trys: [], ops: []
                }, f, y, t, g;
                return g = {
                    next: verb(0),
                    "throw": verb(1),
                    "return": verb(2)
                }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
                    return this;
                }), g;

                function verb(n) {
                    return function (v) {
                        return step([n, v]);
                    };
                }

                function step(op) {
                    if (f) throw new TypeError("Generator is already executing.");
                    while (_) try {
                        if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                        if (y = 0, t) op = [0, t.value];
                        switch (op[0]) {
                            case 0:
                            case 1:
                                t = op;
                                break;
                            case 4:
                                _.label++;
                                return {value: op[1], done: false};
                            case 5:
                                _.label++;
                                y = op[1];
                                op = [0];
                                continue;
                            case 7:
                                op = _.ops.pop();
                                _.trys.pop();
                                continue;
                            default:
                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                    _ = 0;
                                    continue;
                                }
                                if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                    _.label = op[1];
                                    break;
                                }
                                if (op[0] === 6 && _.label < t[1]) {
                                    _.label = t[1];
                                    t = op;
                                    break;
                                }
                                if (t && _.label < t[2]) {
                                    _.label = t[2];
                                    _.ops.push(op);
                                    break;
                                }
                                if (t[2]) _.ops.pop();
                                _.trys.pop();
                                continue;
                        }
                        op = body.call(thisArg, _);
                    } catch (e) {
                        op = [6, e];
                        y = 0;
                    } finally {
                        f = t = 0;
                    }
                    if (op[0] & 5) throw op[1];
                    return {value: op[0] ? op[1] : void 0, done: true};
                }
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var seedrandom = require("seedrandom");
            var environment_1 = require("../../environment");
            var util = require("../../util");
            var broadcast_util = require("../broadcast_util");
            var concat_util = require("../concat_util");
            var math_1 = require("../math");
            var ndarray_1 = require("../ndarray");
            var types = require("../types");
            var types_1 = require("../types");
            var axis_util = require("./../axis_util");
            var matmul_1 = require("./types/matmul");
            var MathBackendCPU = (function () {
                function MathBackendCPU() {
                    this.data = {};
                }

                MathBackendCPU.prototype.dispose = function () {
                };
                MathBackendCPU.prototype.write = function (id, values, dtype, shape) {
                    this.data[id] = values;
                };
                MathBackendCPU.prototype.writePixels = function (id, pixels, numChannels) {
                    var vals;
                    if (pixels instanceof ImageData) {
                        vals = pixels.data;
                    } else if (pixels instanceof HTMLCanvasElement) {
                        vals = pixels.getContext('2d')
                            .getImageData(0, 0, pixels.width, pixels.height)
                            .data;
                    } else if (pixels instanceof HTMLImageElement ||
                        pixels instanceof HTMLVideoElement) {
                        var canvas = document.createElement('canvas');
                        canvas.width = pixels.width;
                        canvas.height = pixels.height;
                        canvas.getContext('2d').drawImage(pixels, 0, 0, canvas.width, canvas.height);
                        vals = canvas.getContext('2d')
                            .getImageData(0, 0, canvas.width, canvas.height)
                            .data;
                    } else {
                        throw new Error("pixels is of unknown type: " + pixels.constructor.name);
                    }
                    var values;
                    if (numChannels === 4) {
                        values = new Int32Array(vals);
                    } else {
                        var numPixels = pixels.width * pixels.height;
                        values = new Int32Array(numPixels * numChannels);
                        for (var i = 0; i < numPixels; i++) {
                            for (var channel = 0; channel < numChannels; ++channel) {
                                values[i * numChannels + channel] = vals[i * 4 + channel];
                            }
                        }
                    }
                    this.data[id] = values;
                };
                MathBackendCPU.prototype.read = function (id) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            this.throwIfNoData(id);
                            return [2, this.data[id]];
                        });
                    });
                };
                MathBackendCPU.prototype.readSync = function (id) {
                    this.throwIfNoData(id);
                    return this.data[id];
                };
                MathBackendCPU.prototype.disposeData = function (id) {
                    delete this.data[id];
                };
                MathBackendCPU.prototype.time = function (query) {
                    return __awaiter(this, void 0, void 0, function () {
                        var start;
                        return __generator(this, function (_a) {
                            start = performance.now();
                            query();
                            return [2, performance.now() - start];
                        });
                    });
                };
                MathBackendCPU.prototype.throwIfNoData = function (id) {
                    if (!(id in this.data)) {
                        throw new Error("No data found for NDArray with id " + id + ". " +
                            "Use dl.ENV.math instead of constructing your own NDArrayMath. " +
                            "If you need to construct your own math, make sure this array is " +
                            "allocated after the math construction");
                    }
                };
                MathBackendCPU.prototype.clone = function (x) {
                    return ndarray_1.NDArray.make(x.shape, {values: new Float32Array(x.getValues())});
                };
                MathBackendCPU.prototype.slice1D = function (x, begin, size) {
                    var newVals = x.getValues().slice(begin, begin + size);
                    return ndarray_1.Array1D.new(newVals);
                };
                MathBackendCPU.prototype.slice2D = function (x, begin, size) {
                    var result = ndarray_1.Array2D.zeros(size);
                    var startI = begin[0], startJ = begin[1];
                    for (var i = 0; i < size[0]; ++i) {
                        for (var j = 0; j < size[1]; ++j) {
                            var val = x.get(i + startI, j + startJ);
                            result.set(val, i, j);
                        }
                    }
                    return result;
                };
                MathBackendCPU.prototype.slice3D = function (x, begin, size) {
                    var result = ndarray_1.Array3D.zeros(size);
                    var startI = begin[0], startJ = begin[1], startK = begin[2];
                    for (var i = 0; i < size[0]; ++i) {
                        for (var j = 0; j < size[1]; ++j) {
                            for (var k = 0; k < size[2]; ++k) {
                                var val = x.get(i + startI, j + startJ, k + startK);
                                result.set(val, i, j, k);
                            }
                        }
                    }
                    return result;
                };
                MathBackendCPU.prototype.slice4D = function (x, begin, size) {
                    var result = ndarray_1.Array4D.zeros(size);
                    var startI = begin[0], startJ = begin[1], startK = begin[2], startL = begin[3];
                    for (var i = 0; i < size[0]; ++i) {
                        for (var j = 0; j < size[1]; ++j) {
                            for (var k = 0; k < size[2]; ++k) {
                                for (var l = 0; l < size[3]; ++l) {
                                    var val = x.get(i + startI, j + startJ, k + startK, l + startL);
                                    result.set(val, i, j, k, l);
                                }
                            }
                        }
                    }
                    return result;
                };
                MathBackendCPU.prototype.concat1D = function (a, b) {
                    var outShape = concat_util.computeOutShape(a.shape, b.shape, 0);
                    var result = ndarray_1.Array1D.zeros(outShape);
                    var aVals = a.getValues();
                    var bVals = b.getValues();
                    var vals = result.getValues();
                    vals.set(aVals, 0);
                    vals.set(bVals, a.size);
                    return result;
                };
                MathBackendCPU.prototype.concat2D = function (a, b, axis) {
                    var outShape = concat_util.computeOutShape(a.shape, b.shape, axis);
                    var result = ndarray_1.Array2D.zeros(outShape);
                    if (axis === 0) {
                        var aVals = a.getValues();
                        var bVals = b.getValues();
                        var vals = result.getValues();
                        vals.set(aVals, 0);
                        vals.set(bVals, a.size);
                        return result;
                    }
                    for (var i = 0; i < outShape[0]; ++i) {
                        for (var j = 0; j < outShape[1]; ++j) {
                            var index = [i, j];
                            var value = void 0;
                            if (index[axis] < a.shape[axis]) {
                                value = a.get(i, j);
                            } else {
                                index[axis] -= a.shape[axis];
                                var i2 = index[0], j2 = index[1];
                                value = b.get(i2, j2);
                            }
                            result.set(value, i, j);
                        }
                    }
                    return result;
                };
                MathBackendCPU.prototype.concat3D = function (a, b, axis) {
                    var outShape = concat_util.computeOutShape(a.shape, b.shape, axis);
                    var result = ndarray_1.Array3D.zeros(outShape);
                    if (axis === 0) {
                        var aVals = a.getValues();
                        var bVals = b.getValues();
                        var vals = result.getValues();
                        vals.set(aVals, 0);
                        vals.set(bVals, a.size);
                        return result;
                    }
                    for (var i = 0; i < outShape[0]; ++i) {
                        for (var j = 0; j < outShape[1]; ++j) {
                            for (var k = 0; k < outShape[2]; ++k) {
                                var index = [i, j, k];
                                var value = void 0;
                                if (index[axis] < a.shape[axis]) {
                                    value = a.get(i, j, k);
                                } else {
                                    index[axis] -= a.shape[axis];
                                    var i2 = index[0], j2 = index[1], k2 = index[2];
                                    value = b.get(i2, j2, k2);
                                }
                                result.set(value, i, j, k);
                            }
                        }
                    }
                    return result;
                };
                MathBackendCPU.prototype.concat4D = function (a, b, axis) {
                    var outShape = concat_util.computeOutShape(a.shape, b.shape, axis);
                    var result = ndarray_1.Array4D.zeros(outShape);
                    if (axis === 0) {
                        var aVals = a.getValues();
                        var bVals = b.getValues();
                        var vals = result.getValues();
                        vals.set(aVals, 0);
                        vals.set(bVals, a.size);
                        return result;
                    }
                    for (var i = 0; i < outShape[0]; ++i) {
                        for (var j = 0; j < outShape[1]; ++j) {
                            for (var k = 0; k < outShape[2]; ++k) {
                                for (var l = 0; l < outShape[3]; ++l) {
                                    var index = [i, j, k, l];
                                    var value = void 0;
                                    if (index[axis] < a.shape[axis]) {
                                        value = a.get(i, j, k, l);
                                    } else {
                                        index[axis] -= a.shape[axis];
                                        var i2 = index[0], j2 = index[1], k2 = index[2], l2 = index[3];
                                        value = b.get(i2, j2, k2, l2);
                                    }
                                    result.set(value, i, j, k, l);
                                }
                            }
                        }
                    }
                    return result;
                };
                MathBackendCPU.prototype.neg = function (x) {
                    return this.multiply(ndarray_1.Scalar.new(-1), x);
                };
                MathBackendCPU.prototype.add = function (a, b) {
                    return this.broadcastedBinaryOp(a, b, types.upcastType(a.dtype, b.dtype), function (aValue, bValue) {
                        return aValue + bValue;
                    });
                };
                MathBackendCPU.prototype.subtract = function (a, b) {
                    return this.broadcastedBinaryOp(a, b, types.upcastType(a.dtype, b.dtype), function (aValue, bValue) {
                        return aValue - bValue;
                    });
                };
                MathBackendCPU.prototype.pow = function (a, b) {
                    return this.broadcastedBinaryOp(a, b, a.dtype, function (aValue, bValue) {
                        return Math.pow(aValue, bValue);
                    });
                };
                MathBackendCPU.prototype.matMul = function (a, b, aOrientation, bOrientation) {
                    if (aOrientation === void 0) {
                        aOrientation = matmul_1.MatrixOrientation.REGULAR;
                    }
                    if (bOrientation === void 0) {
                        bOrientation = matmul_1.MatrixOrientation.REGULAR;
                    }
                    var sharedDim = (aOrientation === matmul_1.MatrixOrientation.REGULAR) ? a.shape[1] : a.shape[0];
                    var leftDim = (aOrientation === matmul_1.MatrixOrientation.REGULAR) ? a.shape[0] : a.shape[1];
                    var rightDim = (bOrientation === matmul_1.MatrixOrientation.REGULAR) ? b.shape[1] : b.shape[0];
                    var normalGetter = function (matrix, i, j) {
                        return matrix.get(i, j);
                    };
                    var transposedGetter = function (matrix, i, j) {
                        return matrix.get(j, i);
                    };
                    var aGetter = (aOrientation === matmul_1.MatrixOrientation.REGULAR) ?
                        normalGetter :
                        transposedGetter;
                    var bGetter = (bOrientation === matmul_1.MatrixOrientation.REGULAR) ?
                        normalGetter :
                        transposedGetter;
                    var values = new Float32Array(leftDim * rightDim);
                    var index = 0;
                    for (var i = 0; i < leftDim; ++i) {
                        for (var j = 0; j < rightDim; ++j) {
                            var sum = 0;
                            for (var k = 0; k < sharedDim; ++k) {
                                sum += aGetter(a, i, k) * bGetter(b, k, j);
                            }
                            values[index++] = sum;
                        }
                    }
                    return ndarray_1.Array2D.new([leftDim, rightDim], values);
                };
                MathBackendCPU.prototype.multiply = function (a, b) {
                    return this.broadcastedBinaryOp(a, b, a.dtype, function (aValue, bValue) {
                        return aValue * bValue;
                    });
                };
                MathBackendCPU.prototype.divide = function (a, b) {
                    return this.broadcastedBinaryOp(a, b, 'float32', function (aValue, bValue) {
                        return aValue / bValue;
                    });
                };
                MathBackendCPU.prototype.sum = function (x, axes) {
                    axis_util.assertAxesAreInnerMostDims('sum', axes, x.rank);
                    var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
                    var resultDtype = types_1.SumTypesMap[x.dtype];
                    var result = ndarray_1.NDArray.zeros(outShape, resultDtype);
                    var reduceSize = util.sizeFromShape(reduceShape);
                    var vals = result.getValues();
                    var aVals = x.getValues();
                    for (var i = 0; i < vals.length; ++i) {
                        var offset = i * reduceSize;
                        var sum = 0;
                        for (var j = 0; j < reduceSize; ++j) {
                            sum += aVals[offset + j];
                        }
                        vals[i] = sum;
                    }
                    return result;
                };
                MathBackendCPU.prototype.argMin = function (x, axes) {
                    axis_util.assertAxesAreInnerMostDims('argMin', axes, x.rank);
                    var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
                    var result = ndarray_1.NDArray.zeros(outShape, 'int32');
                    var reduceSize = util.sizeFromShape(reduceShape);
                    var vals = result.getValues();
                    var aVals = x.getValues();
                    for (var i = 0; i < vals.length; ++i) {
                        var offset = i * reduceSize;
                        var min = aVals[offset];
                        var minIndex = 0;
                        for (var j = 0; j < reduceSize; ++j) {
                            var value = aVals[offset + j];
                            if (isNaN(value)) {
                                minIndex = util.NAN_INT32;
                                break;
                            }
                            if (value < min) {
                                min = value;
                                minIndex = j;
                            }
                        }
                        vals[i] = minIndex;
                    }
                    return result;
                };
                MathBackendCPU.prototype.argMax = function (x, axes) {
                    axis_util.assertAxesAreInnerMostDims('argMax', axes, x.rank);
                    var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
                    var result = ndarray_1.NDArray.zeros(outShape, 'int32');
                    var reduceSize = util.sizeFromShape(reduceShape);
                    var vals = result.getValues();
                    var aVals = x.getValues();
                    for (var i = 0; i < vals.length; ++i) {
                        var offset = i * reduceSize;
                        var max = aVals[offset];
                        var maxIndex = 0;
                        for (var j = 0; j < reduceSize; ++j) {
                            var value = aVals[offset + j];
                            if (isNaN(value)) {
                                maxIndex = util.NAN_INT32;
                                break;
                            }
                            if (value > max) {
                                max = value;
                                maxIndex = j;
                            }
                        }
                        vals[i] = maxIndex;
                    }
                    return result;
                };
                MathBackendCPU.prototype.equal = function (a, b) {
                    return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
                        if (util.isValNaN(aVal, a.dtype) || util.isValNaN(bVal, b.dtype)) {
                            return util.getNaN('bool');
                        } else {
                            return (aVal === bVal) ? 1 : 0;
                        }
                    });
                };
                MathBackendCPU.prototype.topKValues = function (x, k) {
                    return this.topK(x, k).values;
                };
                MathBackendCPU.prototype.topKIndices = function (x, k) {
                    return this.topK(x, k).indices;
                };
                MathBackendCPU.prototype.topK = function (x, k) {
                    var values = x.getValues();
                    var valuesAndIndices = [];
                    for (var i = 0; i < values.length; i++) {
                        valuesAndIndices.push({value: values[i], index: i});
                    }
                    valuesAndIndices.sort(function (a, b) {
                        return b.value - a.value;
                    });
                    var topkValues = util.getTypedArrayFromDType(x.dtype, k);
                    var topkIndices = new Int32Array(k);
                    for (var i = 0; i < k; i++) {
                        topkValues[i] = valuesAndIndices[i].value;
                        topkIndices[i] = valuesAndIndices[i].index;
                    }
                    return {
                        values: ndarray_1.Array1D.new(topkValues),
                        indices: ndarray_1.Array1D.new(topkIndices)
                    };
                };
                MathBackendCPU.prototype.min = function (x, axes) {
                    axis_util.assertAxesAreInnerMostDims('min', axes, x.rank);
                    var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
                    var result = ndarray_1.NDArray.zeros(outShape, x.dtype);
                    var reduceSize = util.sizeFromShape(reduceShape);
                    var vals = result.getValues();
                    var aVals = x.getValues();
                    for (var i = 0; i < vals.length; ++i) {
                        var offset = i * reduceSize;
                        var min = aVals[0];
                        for (var j = 0; j < reduceSize; ++j) {
                            var value = aVals[offset + j];
                            if (isNaN(value)) {
                                min = Number.NaN;
                                break;
                            }
                            if (value < min) {
                                min = value;
                            }
                        }
                        vals[i] = min;
                    }
                    return result;
                };
                MathBackendCPU.prototype.max = function (x, axes) {
                    axis_util.assertAxesAreInnerMostDims('max', axes, x.rank);
                    var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
                    var result = ndarray_1.NDArray.zeros(outShape, x.dtype);
                    var reduceSize = util.sizeFromShape(reduceShape);
                    var vals = result.getValues();
                    var aVals = x.getValues();
                    for (var i = 0; i < vals.length; ++i) {
                        var offset = i * reduceSize;
                        var max = aVals[offset];
                        for (var j = 0; j < reduceSize; ++j) {
                            var value = aVals[offset + j];
                            if (isNaN(value)) {
                                max = Number.NaN;
                                break;
                            }
                            if (value > max) {
                                max = value;
                            }
                        }
                        vals[i] = max;
                    }
                    return result;
                };
                MathBackendCPU.prototype.ceil = function (x) {
                    var values = x.getValues();
                    var newValues = new Float32Array(values.length);
                    for (var i = 0; i < values.length; ++i) {
                        newValues[i] = Math.ceil(values[i]);
                    }
                    return ndarray_1.NDArray.make(x.shape, {values: newValues});
                };
                MathBackendCPU.prototype.floor = function (x) {
                    var values = x.getValues();
                    var newValues = new Float32Array(values.length);
                    for (var i = 0; i < values.length; ++i) {
                        newValues[i] = Math.floor(values[i]);
                    }
                    return ndarray_1.NDArray.make(x.shape, {values: newValues});
                };
                MathBackendCPU.prototype.exp = function (x) {
                    var values = x.getValues();
                    var newValues = new Float32Array(values.length);
                    for (var i = 0; i < values.length; ++i) {
                        newValues[i] = Math.exp(values[i]);
                    }
                    return ndarray_1.NDArray.make(x.shape, {values: newValues});
                };
                MathBackendCPU.prototype.log = function (x) {
                    var values = x.getValues();
                    var newValues = new Float32Array(values.length);
                    for (var i = 0; i < values.length; ++i) {
                        var value = values[i];
                        newValues[i] = Math.log(value);
                    }
                    return ndarray_1.NDArray.make(x.shape, {values: newValues});
                };
                MathBackendCPU.prototype.sqrt = function (x) {
                    var values = x.getValues();
                    var newValues = new Float32Array(values.length);
                    for (var i = 0; i < values.length; ++i) {
                        var value = values[i];
                        newValues[i] = Math.sqrt(value);
                    }
                    return ndarray_1.NDArray.make(x.shape, {values: newValues});
                };
                MathBackendCPU.prototype.square = function (x) {
                    var values = x.getValues();
                    var newValues = new Float32Array(values.length);
                    for (var i = 0; i < values.length; ++i) {
                        var value = values[i];
                        newValues[i] = value * value;
                    }
                    return ndarray_1.NDArray.make(x.shape, {values: newValues});
                };
                MathBackendCPU.prototype.relu = function (x) {
                    var res = ndarray_1.NDArray.zeros(x.shape, x.dtype);
                    var resVals = res.getValues();
                    var inVals = x.getValues();
                    for (var i = 0; i < inVals.length; ++i) {
                        var val = inVals[i];
                        if (util.isValNaN(val, x.dtype)) {
                            resVals[i] = util.getNaN(res.dtype);
                        } else {
                            resVals[i] = Math.max(0, inVals[i]);
                        }
                    }
                    return res;
                };
                MathBackendCPU.prototype.elu = function (x) {
                    var resultValues = new Float32Array(x.size);
                    var values = x.dataSync();
                    for (var i = 0; i < values.length; ++i) {
                        var v = values[i];
                        if (v >= 0) {
                            resultValues[i] = v;
                        } else {
                            resultValues[i] = (Math.exp(v) - 1);
                        }
                    }
                    return ndarray_1.NDArray.make(x.shape, {values: resultValues});
                };
                MathBackendCPU.prototype.eluDer = function (x) {
                    var resultValues = new Float32Array(x.size);
                    var values = x.dataSync();
                    for (var i = 0; i < values.length; ++i) {
                        var v = values[i];
                        if (v >= 0) {
                            resultValues[i] = 1;
                        } else {
                            resultValues[i] = Math.exp(v);
                        }
                    }
                    return ndarray_1.NDArray.make(x.shape, {values: resultValues});
                };
                MathBackendCPU.prototype.selu = function (x) {
                    var scaleAlpha = 1.7580993408473768599402175208123;
                    var scale = 1.0507009873554804934193349852946;
                    var resultValues = new Float32Array(x.size);
                    var values = x.dataSync();
                    for (var i = 0; i < values.length; ++i) {
                        var v = values[i];
                        if (v >= 0) {
                            resultValues[i] = scale * v;
                        } else {
                            resultValues[i] = scaleAlpha * (Math.exp(v) - 1);
                        }
                    }
                    return ndarray_1.NDArray.make(x.shape, {values: resultValues});
                };
                MathBackendCPU.prototype.leakyRelu = function (x, alpha) {
                    var resultValues = new Float32Array(x.size);
                    var values = x.dataSync();
                    for (var i = 0; i < values.length; i++) {
                        var v = values[i];
                        if (v >= 0) {
                            resultValues[i] = v;
                        } else {
                            resultValues[i] = alpha * v;
                        }
                    }
                    return ndarray_1.NDArray.make(x.shape, {values: resultValues});
                };
                MathBackendCPU.prototype.prelu = function (x, alpha) {
                    var resultValues = new Float32Array(x.size);
                    var values = x.dataSync();
                    var alphas = alpha.dataSync();
                    for (var i = 0; i < values.length; i++) {
                        var v = values[i];
                        if (v >= 0) {
                            resultValues[i] = v;
                        } else {
                            resultValues[i] = alphas[i] * v;
                        }
                    }
                    return ndarray_1.NDArray.make(x.shape, {values: resultValues});
                };
                MathBackendCPU.prototype.preluDer = function (x, alpha) {
                    var resultValues = new Float32Array(x.size);
                    var values = x.dataSync();
                    var alphas = alpha.dataSync();
                    for (var i = 0; i < values.length; i++) {
                        var v = values[i];
                        if (v > 0) {
                            resultValues[i] = 1;
                        } else if (v < 0) {
                            resultValues[i] = alphas[i];
                        } else {
                            resultValues[i] = v;
                        }
                    }
                    return ndarray_1.NDArray.make(x.shape, {values: resultValues});
                };
                MathBackendCPU.prototype.clip = function (x, min, max) {
                    var resultValues = new Float32Array(x.size);
                    var values = x.getValues();
                    for (var i = 0; i < values.length; ++i) {
                        resultValues[i] = Math.min(max, Math.max(min, values[i]));
                    }
                    return ndarray_1.NDArray.make(x.shape, {values: resultValues});
                };
                MathBackendCPU.prototype.abs = function (x) {
                    var resultValues = new Float32Array(x.size);
                    var values = x.getValues();
                    for (var i = 0; i < values.length; ++i) {
                        resultValues[i] = Math.abs(values[i]);
                    }
                    return ndarray_1.NDArray.make(x.shape, {values: resultValues});
                };
                MathBackendCPU.prototype.sigmoid = function (x) {
                    var resultValues = new Float32Array(x.size);
                    var values = x.getValues();
                    for (var i = 0; i < values.length; ++i) {
                        resultValues[i] = 1 / (1 + Math.exp(-values[i]));
                    }
                    return ndarray_1.NDArray.make(x.shape, {values: resultValues});
                };
                MathBackendCPU.prototype.sin = function (x) {
                    var resultValues = new Float32Array(x.size);
                    var values = x.getValues();
                    for (var i = 0; i < values.length; ++i) {
                        resultValues[i] = Math.sin(values[i]);
                    }
                    return ndarray_1.NDArray.make(x.shape, {values: resultValues});
                };
                MathBackendCPU.prototype.cos = function (x) {
                    var resultValues = new Float32Array(x.size);
                    var values = x.getValues();
                    for (var i = 0; i < values.length; ++i) {
                        resultValues[i] = Math.cos(values[i]);
                    }
                    return ndarray_1.NDArray.make(x.shape, {values: resultValues});
                };
                MathBackendCPU.prototype.tan = function (x) {
                    var resultValues = new Float32Array(x.size);
                    var values = x.getValues();
                    for (var i = 0; i < values.length; ++i) {
                        resultValues[i] = Math.tan(values[i]);
                    }
                    return ndarray_1.NDArray.make(x.shape, {values: resultValues});
                };
                MathBackendCPU.prototype.asin = function (x) {
                    var resultValues = new Float32Array(x.size);
                    var values = x.getValues();
                    for (var i = 0; i < values.length; ++i) {
                        resultValues[i] = Math.asin(values[i]);
                    }
                    return ndarray_1.NDArray.make(x.shape, {values: resultValues});
                };
                MathBackendCPU.prototype.acos = function (x) {
                    var resultValues = new Float32Array(x.size);
                    var values = x.getValues();
                    for (var i = 0; i < values.length; ++i) {
                        resultValues[i] = Math.acos(values[i]);
                    }
                    return ndarray_1.NDArray.make(x.shape, {values: resultValues});
                };
                MathBackendCPU.prototype.atan = function (x) {
                    var resultValues = new Float32Array(x.size);
                    var values = x.getValues();
                    for (var i = 0; i < values.length; ++i) {
                        resultValues[i] = Math.atan(values[i]);
                    }
                    return ndarray_1.NDArray.make(x.shape, {values: resultValues});
                };
                MathBackendCPU.prototype.sinh = function (x) {
                    var resultValues = new Float32Array(x.size);
                    var values = x.getValues();
                    for (var i = 0; i < values.length; ++i) {
                        resultValues[i] = Math.sinh(values[i]);
                    }
                    return ndarray_1.NDArray.make(x.shape, {values: resultValues});
                };
                MathBackendCPU.prototype.cosh = function (x) {
                    var resultValues = new Float32Array(x.size);
                    var values = x.getValues();
                    for (var i = 0; i < values.length; ++i) {
                        resultValues[i] = Math.cosh(values[i]);
                    }
                    return ndarray_1.NDArray.make(x.shape, {values: resultValues});
                };
                MathBackendCPU.prototype.tanh = function (x) {
                    var resultValues = new Float32Array(x.size);
                    var values = x.getValues();
                    for (var i = 0; i < values.length; ++i) {
                        resultValues[i] = util.tanh(values[i]);
                    }
                    return ndarray_1.NDArray.make(x.shape, {values: resultValues});
                };
                MathBackendCPU.prototype.step = function (x, alpha) {
                    if (alpha === void 0) {
                        alpha = 0;
                    }
                    var resultValues = new Float32Array(x.size);
                    var values = x.getValues();
                    for (var i = 0; i < values.length; ++i) {
                        var value = values[i];
                        if (util.isValNaN(value, x.dtype)) {
                            resultValues[i] = util.getNaN(x.dtype);
                        } else {
                            resultValues[i] = value > 0 ? 1 : alpha;
                        }
                    }
                    return ndarray_1.NDArray.make(x.shape, {values: resultValues});
                };
                MathBackendCPU.prototype.conv2d = function (x, filter, bias, convInfo) {
                    var filterHeight = convInfo.filterHeight;
                    var filterWidth = convInfo.filterWidth;
                    var padLeft = convInfo.padInfo.left;
                    var padTop = convInfo.padInfo.top;
                    var y = ndarray_1.Array4D.zeros(convInfo.outShape);
                    for (var b = 0; b < convInfo.batchSize; ++b) {
                        for (var d2 = 0; d2 < convInfo.outChannels; ++d2) {
                            for (var yR = 0; yR < convInfo.outHeight; ++yR) {
                                var xRCorner = yR * convInfo.strideHeight - padLeft;
                                var xRMin = Math.max(0, xRCorner);
                                var xRMax = Math.min(convInfo.inHeight, filterHeight + xRCorner);
                                for (var yC = 0; yC < convInfo.outWidth; ++yC) {
                                    var xCCorner = yC * convInfo.strideWidth - padTop;
                                    var xCMin = Math.max(0, xCCorner);
                                    var xCMax = Math.min(convInfo.inWidth, filterWidth + xCCorner);
                                    var dotProd = 0;
                                    for (var xR = xRMin; xR < xRMax; ++xR) {
                                        var wR = xR - xRCorner;
                                        for (var xC = xCMin; xC < xCMax; ++xC) {
                                            var wC = xC - xCCorner;
                                            for (var d1 = 0; d1 < convInfo.inChannels; ++d1) {
                                                var pixel = x.get(b, xR, xC, d1);
                                                var weight = filter.get(wR, wC, d1, d2);
                                                dotProd += pixel * weight;
                                            }
                                        }
                                    }
                                    var biasVal = (bias != null) ? bias.get(d2) : 0;
                                    y.set(dotProd + biasVal, b, yR, yC, d2);
                                }
                            }
                        }
                    }
                    return y;
                };
                MathBackendCPU.prototype.conv2dDerInput = function (dy, filter, convInfo) {
                    var filterHeight = convInfo.filterHeight;
                    var filterWidth = convInfo.filterWidth;
                    var topPad = filterHeight - 1 - convInfo.padInfo.top;
                    var leftPad = filterWidth - 1 - convInfo.padInfo.left;
                    var strideHeight = convInfo.strideHeight;
                    var strideWidth = convInfo.strideWidth;
                    var dx = ndarray_1.Array4D.zeros(convInfo.inShape);
                    for (var b = 0; b < convInfo.batchSize; ++b) {
                        for (var d1 = 0; d1 < convInfo.inChannels; ++d1) {
                            for (var xR = 0; xR < convInfo.inHeight; ++xR) {
                                var xRCorner = xR - leftPad;
                                var xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));
                                var yRMax = Math.min(convInfo.outHeight, (filterHeight + xRCorner) / strideHeight);
                                for (var xC = 0; xC < convInfo.inWidth; ++xC) {
                                    var xCCorner = xC - topPad;
                                    var xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));
                                    var yCMax = Math.min(convInfo.outWidth, (filterWidth + xCCorner) / strideWidth);
                                    var dotProd = 0;
                                    for (var yR = xRMin; yR < yRMax; ++yR) {
                                        var wR = yR * strideHeight - xRCorner;
                                        for (var yC = xCMin; yC < yCMax; ++yC) {
                                            var wC = yC * strideWidth - xCCorner;
                                            for (var d2 = 0; d2 < convInfo.outChannels; ++d2) {
                                                var pixel = dy.get(b, yR, yC, d2);
                                                var weight = filter.get(filterHeight - 1 - wR, filterWidth - 1 - wC, d1, d2);
                                                dotProd += pixel * weight;
                                            }
                                        }
                                    }
                                    dx.set(dotProd, b, xR, xC, d1);
                                }
                            }
                        }
                    }
                    return dx;
                };
                MathBackendCPU.prototype.conv2dDerFilter = function (x, dy, convInfo) {
                    var strideHeight = convInfo.strideHeight;
                    var strideWidth = convInfo.strideWidth;
                    var filterHeight = convInfo.filterHeight;
                    var filterWidth = convInfo.filterWidth;
                    var dW = ndarray_1.Array4D.zeros(convInfo.filterShape);
                    var leftPad = convInfo.padInfo.left;
                    var topPad = convInfo.padInfo.top;
                    for (var wR = 0; wR < filterHeight; ++wR) {
                        var yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));
                        var yRMax = Math.min(convInfo.outHeight, (convInfo.inHeight + topPad - wR) / strideHeight);
                        for (var wC = 0; wC < filterWidth; ++wC) {
                            var yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));
                            var yCMax = Math.min(convInfo.outWidth, (convInfo.inWidth + leftPad - wC) / strideWidth);
                            for (var d1 = 0; d1 < convInfo.inChannels; ++d1) {
                                for (var d2 = 0; d2 < convInfo.outChannels; ++d2) {
                                    var dotProd = 0;
                                    for (var b = 0; b < convInfo.batchSize; ++b) {
                                        for (var yR = yRMin; yR < yRMax; ++yR) {
                                            var xR = wR + yR * strideHeight - topPad;
                                            for (var yC = yCMin; yC < yCMax; ++yC) {
                                                var xC = wC + yC * strideWidth - leftPad;
                                                dotProd += x.get(b, xR, xC, d1) * dy.get(b, yR, yC, d2);
                                            }
                                        }
                                    }
                                    dW.set(dotProd, wR, wC, d1, d2);
                                }
                            }
                        }
                    }
                    return dW;
                };
                MathBackendCPU.prototype.conv2dDerBias = function (dy) {
                    var _a = dy.shape, batchSize = _a[0], numRows = _a[1], numCols = _a[2], outDepth = _a[3];
                    var values = new Float32Array(outDepth);
                    for (var d2 = 0; d2 < outDepth; ++d2) {
                        var sum = 0;
                        for (var b = 0; b < batchSize; ++b) {
                            for (var r = 0; r < numRows; ++r) {
                                for (var c = 0; c < numCols; ++c) {
                                    sum += dy.get(b, r, c, d2);
                                }
                            }
                        }
                        values[d2] = sum;
                    }
                    return ndarray_1.Array1D.new(values);
                };
                MathBackendCPU.prototype.depthwiseConv2D = function (x, filter, convInfo) {
                    var filterHeight = convInfo.filterHeight;
                    var filterWidth = convInfo.filterWidth;
                    var padLeft = convInfo.padInfo.left;
                    var padTop = convInfo.padInfo.top;
                    var chMul = convInfo.outChannels / convInfo.inChannels;
                    var y = ndarray_1.Array4D.zeros(convInfo.outShape);
                    for (var b = 0; b < convInfo.batchSize; ++b) {
                        for (var d1 = 0; d1 < convInfo.inChannels; ++d1) {
                            for (var yR = 0; yR < convInfo.outHeight; ++yR) {
                                var xRCorner = yR * convInfo.strideHeight - padLeft;
                                var xRMin = Math.max(0, xRCorner);
                                var xRMax = Math.min(convInfo.inHeight, filterHeight + xRCorner);
                                for (var yC = 0; yC < convInfo.outWidth; ++yC) {
                                    var xCCorner = yC * convInfo.strideWidth - padTop;
                                    var xCMin = Math.max(0, xCCorner);
                                    var xCMax = Math.min(convInfo.inWidth, filterWidth + xCCorner);
                                    for (var q = 0; q < chMul; ++q) {
                                        var dotProd = 0;
                                        for (var xR = xRMin; xR < xRMax; ++xR) {
                                            var wR = xR - xRCorner;
                                            for (var xC = xCMin; xC < xCMax; ++xC) {
                                                var wC = xC - xCCorner;
                                                var pixel = x.get(b, xR, xC, d1);
                                                var weight = filter.get(wR, wC, d1, q);
                                                dotProd += pixel * weight;
                                            }
                                        }
                                        y.set(dotProd, b, yR, yC, d1 * chMul + q);
                                    }
                                }
                            }
                        }
                    }
                    return y;
                };
                MathBackendCPU.prototype.tile = function (x, reps) {
                    var newShape = new Array(x.rank);
                    for (var i = 0; i < newShape.length; i++) {
                        newShape[i] = x.shape[i] * reps[i];
                    }
                    var dtype;
                    if (x.dtype === 'float32') {
                        dtype = Float32Array;
                    } else if (x.dtype === 'int32') {
                        dtype = Int32Array;
                    } else if (x.dtype === 'bool') {
                        dtype = Uint8Array;
                    } else {
                        throw new Error("Dtype " + x.dtype + " not supported for tile");
                    }
                    var resultValues = new dtype(util.sizeFromShape(newShape));
                    var result = ndarray_1.NDArray.make(newShape, {values: resultValues}, x.dtype);
                    var values = x.getValues();
                    for (var i = 0; i < result.size; ++i) {
                        var newLoc = result.indexToLoc(i);
                        var originalLoc = new Array(x.rank);
                        for (var i_1 = 0; i_1 < originalLoc.length; i_1++) {
                            originalLoc[i_1] = newLoc[i_1] % x.shape[i_1];
                        }
                        var originalIndex = x.locToIndex(originalLoc);
                        resultValues[i] = values[originalIndex];
                    }
                    return result;
                };
                MathBackendCPU.prototype.transpose = function (x, perm) {
                    var newShape = new Array(x.rank);
                    for (var i = 0; i < newShape.length; i++) {
                        newShape[i] = x.shape[perm[i]];
                    }
                    var resultValues = new Float32Array(x.size);
                    var values = x.getValues();
                    var result = ndarray_1.NDArray.make(newShape, {values: resultValues});
                    for (var i = 0; i < x.size; ++i) {
                        var loc = x.indexToLoc(i);
                        var newLoc = new Array(loc.length);
                        for (var i_2 = 0; i_2 < newLoc.length; i_2++) {
                            newLoc[i_2] = loc[perm[i_2]];
                        }
                        var newIndex = result.locToIndex(newLoc);
                        resultValues[newIndex] = values[i];
                    }
                    return result;
                };
                MathBackendCPU.prototype.pool = function (x, convInfo, poolType) {
                    var strideHeight = convInfo.strideHeight;
                    var strideWidth = convInfo.strideWidth;
                    var filterHeight = convInfo.filterHeight;
                    var filterWidth = convInfo.filterWidth;
                    var y = ndarray_1.Array4D.zeros(convInfo.outShape);
                    var padTop = convInfo.padInfo.top;
                    var padLeft = convInfo.padInfo.left;
                    for (var b = 0; b < convInfo.batchSize; ++b) {
                        for (var d = 0; d < convInfo.inChannels; ++d) {
                            for (var yR = 0; yR < convInfo.outHeight; ++yR) {
                                var xRCorner = yR * strideHeight - padTop;
                                var xRMin = Math.max(0, xRCorner);
                                var xRMax = Math.min(convInfo.inHeight, filterHeight + xRCorner);
                                for (var yC = 0; yC < convInfo.outWidth; ++yC) {
                                    var xCCorner = yC * strideWidth - padLeft;
                                    var xCMin = Math.max(0, xCCorner);
                                    var xCMax = Math.min(convInfo.inWidth, filterWidth + xCCorner);
                                    var minMaxValue = (poolType === 'max' ? Number.NEGATIVE_INFINITY :
                                        Number.POSITIVE_INFINITY);
                                    var avgValue = 0;
                                    for (var xR = xRMin; xR < xRMax; ++xR) {
                                        for (var xC = xCMin; xC < xCMax; ++xC) {
                                            var pixel = x.get(b, xR, xC, d);
                                            if (isNaN(pixel)) {
                                                minMaxValue = NaN;
                                                avgValue = NaN;
                                                break;
                                            }
                                            if ((poolType === 'max' && pixel > minMaxValue) ||
                                                (poolType === 'min' && pixel < minMaxValue)) {
                                                minMaxValue = pixel;
                                            } else if (poolType === 'avg') {
                                                avgValue += pixel / (filterHeight * filterWidth);
                                            }
                                        }
                                        if (isNaN(minMaxValue)) {
                                            break;
                                        }
                                    }
                                    y.set(poolType === 'avg' ? avgValue : minMaxValue, b, yR, yC, d);
                                }
                            }
                        }
                    }
                    return y;
                };
                MathBackendCPU.prototype.maxPool = function (x, convInfo) {
                    return this.pool(x, convInfo, 'max');
                };
                MathBackendCPU.prototype.maxPoolPositions = function (x, convInfo) {
                    var maxPositions = ndarray_1.Array4D.zeros(convInfo.outShape);
                    var strideHeight = convInfo.strideHeight;
                    var strideWidth = convInfo.strideWidth;
                    var filterHeight = convInfo.filterHeight;
                    var filterWidth = convInfo.filterWidth;
                    var padTop = convInfo.padInfo.top;
                    var padLeft = convInfo.padInfo.left;
                    for (var b = 0; b < convInfo.batchSize; ++b) {
                        for (var d = 0; d < convInfo.inChannels; ++d) {
                            for (var yR = 0; yR < convInfo.outHeight; ++yR) {
                                var xRCorner = yR * strideHeight - padTop;
                                var xRMin = Math.max(0, xRCorner);
                                var xRMax = Math.min(convInfo.inHeight, filterHeight + xRCorner);
                                for (var yC = 0; yC < convInfo.outWidth; ++yC) {
                                    var xCCorner = yC * strideWidth - padLeft;
                                    var xCMin = Math.max(0, xCCorner);
                                    var xCMax = Math.min(convInfo.inWidth, filterWidth + xCCorner);
                                    var maxValue = Number.NEGATIVE_INFINITY;
                                    var maxPosition = -1;
                                    for (var xR = xRMin; xR < xRMax; ++xR) {
                                        var wR = xR - xRCorner;
                                        for (var xC = xCMin; xC < xCMax; ++xC) {
                                            var wC = xC - xCCorner;
                                            var pixel = x.get(b, xR, xC, d);
                                            if (pixel > maxValue) {
                                                maxValue = pixel;
                                                maxPosition = wR * filterWidth + wC;
                                            }
                                        }
                                    }
                                    maxPositions.set(maxPosition, b, yR, yC, d);
                                }
                            }
                        }
                    }
                    return maxPositions;
                };
                MathBackendCPU.prototype.maxPoolBackprop = function (dy, x, convInfo) {
                    var maxPositions = this.maxPoolPositions(x, convInfo);
                    var strideHeight = convInfo.strideHeight;
                    var strideWidth = convInfo.strideWidth;
                    var filterHeight = convInfo.filterHeight;
                    var filterWidth = convInfo.filterWidth;
                    var padLeft = filterWidth - 1 - convInfo.padInfo.left;
                    var padTop = filterHeight - 1 - convInfo.padInfo.top;
                    var dx = ndarray_1.Array4D.zeros(x.shape);
                    for (var b = 0; b < convInfo.batchSize; ++b) {
                        for (var d = 0; d < convInfo.inChannels; ++d) {
                            for (var dxR = 0; dxR < convInfo.inHeight; ++dxR) {
                                for (var dxC = 0; dxC < convInfo.inWidth; ++dxC) {
                                    var dyRCorner = dxR - padTop;
                                    var dyCCorner = dxC - padLeft;
                                    var dotProd = 0;
                                    for (var wR = 0; wR < filterHeight; ++wR) {
                                        var dyR = (dyRCorner + wR) / strideHeight;
                                        if (dyR < 0 || dyR >= convInfo.outHeight ||
                                            Math.floor(dyR) !== dyR) {
                                            continue;
                                        }
                                        for (var wC = 0; wC < filterWidth; ++wC) {
                                            var dyC = (dyCCorner + wC) / strideWidth;
                                            if (dyC < 0 || dyC >= convInfo.outWidth ||
                                                Math.floor(dyC) !== dyC) {
                                                continue;
                                            }
                                            var maxPos = filterHeight * filterWidth - 1 -
                                                maxPositions.get(b, dyR, dyC, d);
                                            var curPos = wR * filterWidth + wC;
                                            var mask = maxPos === curPos ? 1 : 0;
                                            if (mask === 0) {
                                                continue;
                                            }
                                            var pixel = dy.get(b, dyR, dyC, d);
                                            dotProd += pixel * mask;
                                        }
                                    }
                                    dx.set(dotProd, b, dxR, dxC, d);
                                }
                            }
                        }
                    }
                    return dx;
                };
                MathBackendCPU.prototype.minPool = function (x, convInfo) {
                    return this.pool(x, convInfo, 'min');
                };
                MathBackendCPU.prototype.avgPool = function (x, convInfo) {
                    return this.pool(x, convInfo, 'avg');
                };
                MathBackendCPU.prototype.resizeBilinear3D = function (x, newShape2D, alignCorners) {
                    var output = ndarray_1.Array3D.zeros([newShape2D[0], newShape2D[1], x.shape[2]]);
                    var effectiveInputSize = alignCorners ? [x.shape[0] - 1, x.shape[1] - 1, x.shape[2]] : x.shape;
                    var effectiveOutputSize = alignCorners ?
                        [output.shape[0] - 1, output.shape[1] - 1, output.shape[2]] :
                        output.shape;
                    for (var r = 0; r < output.shape[0]; r++) {
                        for (var c = 0; c < output.shape[1]; c++) {
                            for (var d = 0; d < output.shape[2]; d++) {
                                var sourceFracRow = (effectiveInputSize[0]) * r / (effectiveOutputSize[0]);
                                var sourceFracCol = (effectiveInputSize[1]) * c / (effectiveOutputSize[1]);
                                var sourceRowFloor = Math.floor(sourceFracRow);
                                var sourceRowCeil = Math.min(x.shape[0] - 1, Math.ceil(sourceFracRow));
                                var sourceColFloor = Math.floor(sourceFracCol);
                                var sourceColCeil = Math.min(x.shape[1] - 1, Math.ceil(sourceFracCol));
                                var topLeft = x.get(sourceRowFloor, sourceColFloor, d);
                                var bottomLeft = x.get(sourceRowCeil, sourceColFloor, d);
                                var topRight = x.get(sourceRowFloor, sourceColCeil, d);
                                var bottomRight = x.get(sourceRowCeil, sourceColCeil, d);
                                var rowFrac = sourceFracRow - sourceRowFloor;
                                var colFrac = sourceFracCol - sourceColFloor;
                                var top_1 = topLeft + (topRight - topLeft) * colFrac;
                                var bottom = bottomLeft + (bottomRight - bottomLeft) * colFrac;
                                var newValue = top_1 + (bottom - top_1) * rowFrac;
                                output.set(newValue, r, c, d);
                            }
                        }
                    }
                    return output;
                };
                MathBackendCPU.prototype.batchNormalization2D = function (x, mean, variance, varianceEpsilon, scale, offset) {
                    var xValues = x.getValues();
                    var meanValues = mean.getValues();
                    var varianceValues = variance.getValues();
                    var scaleValues = scale ? scale.getValues() : new Float32Array([1]);
                    var offsetValues = offset ? offset.getValues() : new Float32Array([0]);
                    var outValues = new Float32Array(xValues.length);
                    for (var i = 0; i < xValues.length; i++) {
                        outValues[i] = offsetValues[i % offsetValues.length] +
                            (xValues[i] - meanValues[i % meanValues.length]) *
                            scaleValues[i % scaleValues.length] /
                            Math.sqrt(varianceValues[i % varianceValues.length] + varianceEpsilon);
                    }
                    return ndarray_1.Array2D.new(x.shape, outValues);
                };
                MathBackendCPU.prototype.batchNormalization3D = function (x, mean, variance, varianceEpsilon, scale, offset) {
                    var xValues = x.getValues();
                    var meanValues = mean.getValues();
                    var varianceValues = variance.getValues();
                    var scaleValues = scale ? scale.getValues() : new Float32Array([1]);
                    var offsetValues = offset ? offset.getValues() : new Float32Array([0]);
                    var outValues = new Float32Array(xValues.length);
                    for (var i = 0; i < xValues.length; i++) {
                        outValues[i] = offsetValues[i % offsetValues.length] +
                            (xValues[i] - meanValues[i % meanValues.length]) *
                            scaleValues[i % scaleValues.length] /
                            Math.sqrt(varianceValues[i % varianceValues.length] + varianceEpsilon);
                    }
                    return ndarray_1.Array3D.new(x.shape, outValues);
                };
                MathBackendCPU.prototype.multinomial = function (probabilities, numSamples, seed) {
                    var batchSize = probabilities.shape[0];
                    var numEvents = probabilities.shape[1];
                    var res = ndarray_1.Array2D.zeros([batchSize, numSamples], 'int32');
                    var resVals = res.getValues();
                    var probVals = probabilities.getValues();
                    for (var b = 0; b < batchSize; ++b) {
                        var offset = b * numEvents;
                        var cdf = new Float32Array(numEvents - 1);
                        cdf[0] = probVals[offset];
                        for (var event_1 = 1; event_1 < cdf.length; ++event_1) {
                            cdf[event_1] = cdf[event_1 - 1] + probVals[offset + event_1];
                        }
                        var random = seedrandom.alea(seed.toString());
                        var outOffset = b * numSamples;
                        for (var sampleId = 0; sampleId < numSamples; ++sampleId) {
                            var r = random();
                            resVals[outOffset + sampleId] = cdf.length;
                            for (var event_2 = 0; event_2 < cdf.length; event_2++) {
                                if (r < cdf[event_2]) {
                                    resVals[outOffset + sampleId] = event_2;
                                    break;
                                }
                            }
                        }
                    }
                    return res;
                };
                MathBackendCPU.prototype.oneHot = function (indices, depth, onValue, offValue) {
                    var res = new Float32Array(indices.size * depth);
                    res.fill(offValue);
                    for (var event_3 = 0; event_3 < indices.size; ++event_3) {
                        res[event_3 * depth + indices.get(event_3)] = onValue;
                    }
                    return ndarray_1.Array2D.new([indices.size, depth], res);
                };
                MathBackendCPU.prototype.broadcastedBinaryOp = function (a, b, dtype, op) {
                    var newShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
                    var result = ndarray_1.NDArray.zeros(newShape, dtype);
                    var newValues = result.getValues();
                    var aValues = a.getValues();
                    var bValues = b.getValues();
                    var aBroadcastDims = broadcast_util.getBroadcastDims(a.shape, newShape);
                    var bBroadcastDims = broadcast_util.getBroadcastDims(b.shape, newShape);
                    var _loop_1 = function (i) {
                        var loc = result.indexToLoc(i);
                        var aLoc = loc.slice(-a.rank);
                        aBroadcastDims.forEach(function (d) {
                            return aLoc[d] = 0;
                        });
                        var aIndex = a.locToIndex(aLoc);
                        var bLoc = loc.slice(-b.rank);
                        bBroadcastDims.forEach(function (d) {
                            return bLoc[d] = 0;
                        });
                        var bIndex = b.locToIndex(bLoc);
                        newValues[i] = op(aValues[aIndex], bValues[bIndex]);
                    };
                    for (var i = 0; i < newValues.length; ++i) {
                        _loop_1(i);
                    }
                    return result;
                };
                return MathBackendCPU;
            }());
            exports.MathBackendCPU = MathBackendCPU;
            environment_1.ENV.registerBackend('cpu', function () {
                return new MathBackendCPU();
            });
            var NDArrayMathCPU = (function (_super) {
                __extends(NDArrayMathCPU, _super);

                function NDArrayMathCPU(safeMode) {
                    if (safeMode === void 0) {
                        safeMode = false;
                    }
                    var _this = this;
                    console.warn('new NDArrayMathCPU() is deprecated. Please use the global ' +
                        'dl.ENV.math. In rare cases, to construct your own NDArrayMath ' +
                        'that runs on CPU, use math = new NDArrayMath(\'cpu\', safeMode); ' +
                        'and make sure to set it as global: dl.ENV.setMath(math);');
                    _this = _super.call(this, 'cpu', safeMode) || this;
                    environment_1.ENV.setMath(_this);
                    return _this;
                }

                return NDArrayMathCPU;
            }(math_1.NDArrayMath));
            exports.NDArrayMathCPU = NDArrayMathCPU;

        }, {
            "../../environment": 15,
            "../../util": 101,
            "../broadcast_util": 90,
            "../concat_util": 91,
            "../math": 94,
            "../ndarray": 95,
            "../types": 99,
            "./../axis_util": 54,
            "./types/matmul": 61,
            "seedrandom": 2
        }],
        56: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var util = require("../../util");
            var kernel_registry = require("./kernel_registry");
            var tape_1 = require("./tape");
            var BackendEngine = (function () {
                function BackendEngine(backend) {
                    this.backend = backend;
                    this.debugMode = false;
                    this.masterTape = new tape_1.Tape(backend);
                }

                BackendEngine.prototype.enableDebugMode = function () {
                    this.debugMode = true;
                };
                BackendEngine.prototype.executeKernel = function (kernelName, config, grad) {
                    var _this = this;
                    var kernelFn = function () {
                        return kernel_registry.executeKernel(_this.backend, kernelName, config);
                    };
                    var start;
                    if (this.debugMode) {
                        start = performance.now();
                    }
                    var result = kernelFn();
                    if (this.debugMode) {
                        var vals = result.getValues();
                        var time = util.rightPad(performance.now() - start + "ms", 9);
                        var paddedName = util.rightPad(name, 25);
                        var rank = result.rank;
                        var size = result.size;
                        var shape = util.rightPad(result.shape.toString(), 14);
                        console.log("%c" + paddedName + "\t%c" + time + "\t%c" + rank + "D " + shape + "\t%c" + size, 'font-weight:bold', 'color:red', 'color:blue', 'color: orange');
                        this.checkForNaN(vals, result.dtype, name);
                    }
                    var evaluatedNode = {
                        name: "kernel: " + kernelName,
                        kernel: kernelName,
                        inputAndArgs: config,
                        output: result,
                        gradient: grad
                    };
                    this.masterTape.addEvaluatedKernelNode(evaluatedNode);
                    return result;
                };
                BackendEngine.prototype.gradientWrt = function (y, xs) {
                    return this.masterTape.gradientWrt(y, xs);
                };
                BackendEngine.prototype.checkForNaN = function (vals, dtype, name) {
                    for (var i = 0; i < vals.length; i++) {
                        if (util.isValNaN(vals[i], dtype)) {
                            throw Error("The result of the last math." + name + " has NaNs.");
                        }
                    }
                };
                BackendEngine.prototype.getBackend = function () {
                    return this.backend;
                };
                return BackendEngine;
            }());
            exports.BackendEngine = BackendEngine;

        }, {"../../util": 101, "./kernel_registry": 58, "./tape": 59}],
        57: [function (require, module, exports) {
            "use strict";
            var __extends = (this && this.__extends) || (function () {
                var extendStatics = Object.setPrototypeOf ||
                    ({__proto__: []} instanceof Array && function (d, b) {
                        d.__proto__ = b;
                    }) ||
                    function (d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                    };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d;
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            })();
            var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) {
                        try {
                            step(generator.next(value));
                        } catch (e) {
                            reject(e);
                        }
                    }

                    function rejected(value) {
                        try {
                            step(generator["throw"](value));
                        } catch (e) {
                            reject(e);
                        }
                    }

                    function step(result) {
                        result.done ? resolve(result.value) : new P(function (resolve) {
                            resolve(result.value);
                        }).then(fulfilled, rejected);
                    }

                    step((generator = generator.apply(thisArg, _arguments || [])).next());
                });
            };
            var __generator = (this && this.__generator) || function (thisArg, body) {
                var _ = {
                    label: 0, sent: function () {
                        if (t[0] & 1) throw t[1];
                        return t[1];
                    }, trys: [], ops: []
                }, f, y, t, g;
                return g = {
                    next: verb(0),
                    "throw": verb(1),
                    "return": verb(2)
                }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
                    return this;
                }), g;

                function verb(n) {
                    return function (v) {
                        return step([n, v]);
                    };
                }

                function step(op) {
                    if (f) throw new TypeError("Generator is already executing.");
                    while (_) try {
                        if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                        if (y = 0, t) op = [0, t.value];
                        switch (op[0]) {
                            case 0:
                            case 1:
                                t = op;
                                break;
                            case 4:
                                _.label++;
                                return {value: op[1], done: false};
                            case 5:
                                _.label++;
                                y = op[1];
                                op = [0];
                                continue;
                            case 7:
                                op = _.ops.pop();
                                _.trys.pop();
                                continue;
                            default:
                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                    _ = 0;
                                    continue;
                                }
                                if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                    _.label = op[1];
                                    break;
                                }
                                if (op[0] === 6 && _.label < t[1]) {
                                    _.label = t[1];
                                    t = op;
                                    break;
                                }
                                if (t && _.label < t[2]) {
                                    _.label = t[2];
                                    _.ops.push(op);
                                    break;
                                }
                                if (t[2]) _.ops.pop();
                                _.trys.pop();
                                continue;
                        }
                        op = body.call(thisArg, _);
                    } catch (e) {
                        op = [6, e];
                        y = 0;
                    } finally {
                        f = t = 0;
                    }
                    if (op[0] & 5) throw op[1];
                    return {value: op[0] ? op[1] : void 0, done: true};
                }
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var environment_1 = require("../../environment");
            var util = require("../../util");
            var axis_util = require("../axis_util");
            var math_1 = require("../math");
            var ndarray_1 = require("../ndarray");
            var reduce_util = require("../reduce_util");
            var types_1 = require("../types");
            var argminmax_gpu_1 = require("./webgl/argminmax_gpu");
            var batchnorm_gpu_1 = require("./webgl/batchnorm_gpu");
            var binaryop_gpu = require("./webgl/binaryop_gpu");
            var binaryop_gpu_1 = require("./webgl/binaryop_gpu");
            var clip_gpu_1 = require("./webgl/clip_gpu");
            var concat_gpu_1 = require("./webgl/concat_gpu");
            var conv_backprop_gpu_1 = require("./webgl/conv_backprop_gpu");
            var conv_gpu_1 = require("./webgl/conv_gpu");
            var conv_gpu_depthwise_1 = require("./webgl/conv_gpu_depthwise");
            var copy_gpu_1 = require("./webgl/copy_gpu");
            var gpgpu_context_1 = require("./webgl/gpgpu_context");
            var gpgpu_math = require("./webgl/gpgpu_math");
            var gpgpu_util = require("./webgl/gpgpu_util");
            var max_pool_backprop_gpu_1 = require("./webgl/max_pool_backprop_gpu");
            var mulmat_gpu_1 = require("./webgl/mulmat_gpu");
            var multinomial_gpu_1 = require("./webgl/multinomial_gpu");
            var onehot_gpu_1 = require("./webgl/onehot_gpu");
            var pool_gpu_1 = require("./webgl/pool_gpu");
            var reduce_gpu_1 = require("./webgl/reduce_gpu");
            var resize_bilinear_gpu_1 = require("./webgl/resize_bilinear_gpu");
            var slice_gpu_1 = require("./webgl/slice_gpu");
            var tex_util_1 = require("./webgl/tex_util");
            var texture_manager_1 = require("./webgl/texture_manager");
            var tile_gpu_1 = require("./webgl/tile_gpu");
            var transpose_gpu_1 = require("./webgl/transpose_gpu");
            var unary_op = require("./webgl/unaryop_gpu");
            var unaryop_gpu_1 = require("./webgl/unaryop_gpu");
            var webgl_util = require("./webgl/webgl_util");
            var MathBackendWebGL = (function () {
                function MathBackendWebGL(gpgpu) {
                    this.texData = {};
                    this.binaryCache = {};
                    if (environment_1.ENV.get('WEBGL_VERSION') < 1) {
                        throw new Error('WebGL is not supported on this device');
                    }
                    if (gpgpu == null) {
                        var gl = gpgpu_util.createWebGLContext();
                        this.gpgpu = new gpgpu_context_1.GPGPUContext(gl);
                        this.gpgpuCreatedLocally = true;
                    } else {
                        this.gpgpu = gpgpu;
                        this.gpgpuCreatedLocally = false;
                    }
                    this.textureManager = new texture_manager_1.TextureManager(this.gpgpu);
                }

                MathBackendWebGL.prototype.writePixels = function (id, pixels, numChannels) {
                    var shape = [pixels.height, pixels.width, numChannels];
                    var texShape = [shape[0], shape[1]];
                    var texture = this.textureManager.acquireTexture(texShape);
                    this.gpgpu.uploadPixelDataToTexture(texture, pixels);
                    this.texData[id] = {
                        texture: texture,
                        textureType: tex_util_1.TextureType.RGBA_COLOR,
                        texShape: texShape,
                        numChannels: numChannels,
                        dtype: 'int32'
                    };
                };
                MathBackendWebGL.prototype.write = function (id, values, dtype, shape) {
                    var texShape = webgl_util.getTextureShapeFromLogicalShape(this.gpgpu.gl, shape);
                    var texture = this.textureManager.acquireTexture(texShape);
                    var textureType = tex_util_1.TextureType.DEFAULT;
                    this.texData[id] = {texture: texture, textureType: textureType, texShape: texShape, dtype: dtype};
                    if (values != null) {
                        this.gpgpu.uploadMatrixToTexture(texture, texShape[0], texShape[1], typedArrayToFloat32(values, dtype));
                    }
                };
                MathBackendWebGL.prototype.readSync = function (id) {
                    this.throwIfNoData(id);
                    var values;
                    var _a = this.texData[id], texture = _a.texture, textureType = _a.textureType,
                        texShape = _a.texShape, numChannels = _a.numChannels, dtype = _a.dtype;
                    if (textureType === tex_util_1.TextureType.DEFAULT) {
                        values = this.gpgpu.downloadMatrixFromTexture(texture, texShape[0], texShape[1]);
                    } else {
                        values = this.gpgpu.downloadMatrixFromRGBAColorTexture(texture, texShape[0], texShape[1], numChannels);
                    }
                    return float32ToTypedArray(values, dtype);
                };
                MathBackendWebGL.prototype.read = function (id) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _a, texture, textureType, texShape;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    this.throwIfNoData(id);
                                    _a = this.texData[id], texture = _a.texture, textureType = _a.textureType, texShape = _a.texShape;
                                    if (environment_1.ENV.get('WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED') &&
                                        textureType === tex_util_1.TextureType.DEFAULT) {
                                        return [2, this.gpgpu.downloadMatrixFromTextureAsync(texture, texShape[0], texShape[1])];
                                    }
                                    if (!environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_ENABLED')) {
                                        return [2, this.readSync(id)];
                                    }
                                    return [4, this.gpgpu.runQuery(function () {
                                    })];
                                case 1:
                                    _b.sent();
                                    return [2, this.readSync(id)];
                            }
                        });
                    });
                };
                MathBackendWebGL.prototype.time = function (query) {
                    return __awaiter(this, void 0, void 0, function () {
                        var start, a;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    if (!!environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_ENABLED')) return [3, 2];
                                    start = performance.now();
                                    a = query();
                                    return [4, a.data()];
                                case 1:
                                    _a.sent();
                                    return [2, performance.now() - start];
                                case 2:
                                    return [2, this.gpgpu.runQuery(query)];
                            }
                        });
                    });
                };
                MathBackendWebGL.prototype.disposeData = function (id) {
                    if (id in this.texData) {
                        var _a = this.texData[id], texture = _a.texture, texShape = _a.texShape;
                        this.textureManager.releaseTexture(texture, texShape);
                        delete this.texData[id];
                    }
                };
                MathBackendWebGL.prototype.getTexture = function (id) {
                    this.throwIfNoData(id);
                    return this.texData[id].texture;
                };
                MathBackendWebGL.prototype.getTextureData = function (id) {
                    this.throwIfNoData(id);
                    return this.texData[id];
                };
                MathBackendWebGL.prototype.getGPGPUContext = function () {
                    return this.gpgpu;
                };
                MathBackendWebGL.prototype.clone = function (x) {
                    this.throwIfNoData(x.id);
                    var texShape = this.texData[x.id].texShape;
                    var source = x.as2D(texShape[0], texShape[1]);
                    var output = this.makeOutputArray(texShape, x.dtype);
                    this.copy2D(source, [0, 0], texShape, output, [0, 0], texShape);
                    return output.reshape(x.shape);
                };
                MathBackendWebGL.prototype.slice1D = function (x, begin, size) {
                    var program = new slice_gpu_1.SliceProgram([size]);
                    var customSetup = program.getCustomSetupFunc([begin]);
                    return this.compileAndRun(program, [x], null, customSetup);
                };
                MathBackendWebGL.prototype.slice2D = function (x, begin, size) {
                    var program = new slice_gpu_1.SliceProgram(size);
                    var customSetup = program.getCustomSetupFunc(begin);
                    return this.compileAndRun(program, [x], null, customSetup);
                };
                MathBackendWebGL.prototype.slice3D = function (x, begin, size) {
                    var program = new slice_gpu_1.SliceProgram(size);
                    var customSetup = program.getCustomSetupFunc(begin);
                    return this.compileAndRun(program, [x], null, customSetup);
                };
                MathBackendWebGL.prototype.slice4D = function (x, begin, size) {
                    var program = new slice_gpu_1.SliceProgram(size);
                    var customSetup = program.getCustomSetupFunc(begin);
                    return this.compileAndRun(program, [x], null, customSetup);
                };
                MathBackendWebGL.prototype.copy2D = function (source, sourceBeginRowCol, sourceSizeRowCol, dest, destBeginRowCol, destSizeRowCol) {
                    var program = new copy_gpu_1.Copy2DProgram(sourceSizeRowCol[1], destSizeRowCol[1]);
                    var customSetup = program.getCustomSetupFunc(sourceBeginRowCol, destBeginRowCol, destSizeRowCol);
                    this.compileAndRun(program, [source], dest, customSetup);
                };
                MathBackendWebGL.prototype.concat1D = function (a, b) {
                    var program = new concat_gpu_1.ConcatProgram(a.shape, b.shape, 0);
                    return this.compileAndRun(program, [a, b]);
                };
                MathBackendWebGL.prototype.concat2D = function (a, b, axis) {
                    var program = new concat_gpu_1.ConcatProgram(a.shape, b.shape, axis);
                    return this.compileAndRun(program, [a, b]);
                };
                MathBackendWebGL.prototype.concat3D = function (a, b, axis) {
                    var program = new concat_gpu_1.ConcatProgram(a.shape, b.shape, axis);
                    return this.compileAndRun(program, [a, b]);
                };
                MathBackendWebGL.prototype.concat4D = function (a, b, axis) {
                    var program = new concat_gpu_1.ConcatProgram(a.shape, b.shape, axis);
                    return this.compileAndRun(program, [a, b]);
                };
                MathBackendWebGL.prototype.neg = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.NEG);
                    return this.compileAndRun(program, [x]);
                };
                MathBackendWebGL.prototype.matMul = function (a, b, aOrientation, bOrientation) {
                    var program = new mulmat_gpu_1.MatMulProgram(a.shape, b.shape, aOrientation, bOrientation);
                    return this.compileAndRun(program, [a, b]);
                };
                MathBackendWebGL.prototype.multiply = function (a, b) {
                    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.MUL, a.shape, b.shape);
                    return this.compileAndRun(program, [a, b]);
                };
                MathBackendWebGL.prototype.batchNormalization2D = function (x, mean, variance, varianceEpsilon, scale, offset) {
                    var inputs = [x, mean, variance];
                    var offsetShape = null;
                    if (offset != null) {
                        offsetShape = offset.shape;
                        inputs.push(offset);
                    }
                    var scaleShape = null;
                    if (scale != null) {
                        scaleShape = scale.shape;
                        inputs.push(scale);
                    }
                    var program = new batchnorm_gpu_1.BatchNormProgram(x.shape, mean.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon);
                    return this.compileAndRun(program, inputs);
                };
                MathBackendWebGL.prototype.batchNormalization3D = function (x, mean, variance, varianceEpsilon, scale, offset) {
                    var inputs = [x, mean, variance];
                    var offsetShape = null;
                    if (offset != null) {
                        offsetShape = offset.shape;
                        inputs.push(offset);
                    }
                    var scaleShape = null;
                    if (scale != null) {
                        scaleShape = scale.shape;
                        inputs.push(scale);
                    }
                    var program = new batchnorm_gpu_1.BatchNormProgram(x.shape, mean.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon);
                    return this.compileAndRun(program, inputs);
                };
                MathBackendWebGL.prototype.tile = function (x, reps) {
                    var program = new tile_gpu_1.TileProgram(x.shape, reps);
                    return this.compileAndRun(program, [x]);
                };
                MathBackendWebGL.prototype.transpose = function (x, perm) {
                    var program = new transpose_gpu_1.TransposeProgram(x.shape, perm);
                    return this.compileAndRun(program, [x]);
                };
                MathBackendWebGL.prototype.reduce = function (x, reduceType, dtype) {
                    var batchSize = x.shape[0];
                    var inSize = x.shape[1];
                    var windowSize = reduce_util.computeOptimalWindowSize(inSize);
                    var reduceInfo = {windowSize: windowSize, inSize: inSize, batchSize: batchSize};
                    var program = new reduce_gpu_1.ReduceProgram(reduceInfo, reduceType);
                    var _a = program.outputShape, rows = _a[0], cols = _a[1];
                    var output = this.makeOutputArray(program.outputShape, dtype).as2D(rows, cols);
                    this.compileAndRun(program, [x], output);
                    if (output.shape[1] === 1) {
                        return output;
                    }
                    return this.reduce(output, reduceType, dtype);
                };
                MathBackendWebGL.prototype.argReduce = function (x, reduceType, bestIndicesA) {
                    if (bestIndicesA === void 0) {
                        bestIndicesA = null;
                    }
                    var batchSize = x.shape[0];
                    var inSize = x.shape[1];
                    if (bestIndicesA != null) {
                        batchSize = bestIndicesA.shape[0];
                        inSize = bestIndicesA.shape[1];
                    }
                    var windowSize = reduce_util.computeOptimalWindowSize(inSize);
                    var reduceInfo = {windowSize: windowSize, inSize: inSize, batchSize: batchSize};
                    var program = new argminmax_gpu_1.ArgMinMaxProgram(reduceInfo, reduceType, bestIndicesA == null);
                    var _a = program.outputShape, rows = _a[0], cols = _a[1];
                    var output = this.makeOutputArray(program.outputShape, 'int32').as2D(rows, cols);
                    var inputs = [x];
                    if (bestIndicesA != null) {
                        inputs.push(bestIndicesA);
                    }
                    this.compileAndRun(program, inputs, output);
                    if (output.shape[1] === 1) {
                        return output;
                    }
                    return this.argReduce(x, reduceType, output);
                };
                MathBackendWebGL.prototype.sum = function (x, axes) {
                    axis_util.assertAxesAreInnerMostDims('sum', axes, x.rank);
                    var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
                    var inSize = util.sizeFromShape(reduceShape);
                    var a2D = x.as2D(-1, inSize);
                    var outputDType = types_1.SumTypesMap[x.dtype];
                    return this.reduce(a2D, 'sum', outputDType).reshape(outShape);
                };
                MathBackendWebGL.prototype.argMin = function (x, axes) {
                    axis_util.assertAxesAreInnerMostDims('argMin', axes, x.rank);
                    var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
                    var inSize = util.sizeFromShape(reduceShape);
                    var a2D = x.as2D(-1, inSize);
                    return this.argReduce(a2D, 'min').reshape(outShape);
                };
                MathBackendWebGL.prototype.argMax = function (x, axes) {
                    axis_util.assertAxesAreInnerMostDims('argMax', axes, x.rank);
                    var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
                    var inSize = util.sizeFromShape(reduceShape);
                    var a2D = x.as2D(-1, inSize);
                    return this.argReduce(a2D, 'max').reshape(outShape);
                };
                MathBackendWebGL.prototype.equal = function (a, b) {
                    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.EQUAL, a.shape, b.shape);
                    var output = this.makeOutputArray(program.outputShape, 'bool');
                    return this.compileAndRun(program, [a, b], output);
                };
                MathBackendWebGL.prototype.topKValues = function (x, k) {
                    throw new Error('topKValues GPU not yet implemented!');
                };
                MathBackendWebGL.prototype.topKIndices = function (x, k) {
                    throw new Error('topKIndices GPU not yet implemented!');
                };
                MathBackendWebGL.prototype.min = function (x, axes) {
                    axis_util.assertAxesAreInnerMostDims('min', axes, x.rank);
                    var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
                    var inSize = util.sizeFromShape(reduceShape);
                    var a2D = x.as2D(-1, inSize);
                    return this.reduce(a2D, 'min', a2D.dtype).reshape(outShape);
                };
                MathBackendWebGL.prototype.max = function (x, axes) {
                    axis_util.assertAxesAreInnerMostDims('max', axes, x.rank);
                    var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
                    var inSize = util.sizeFromShape(reduceShape);
                    var a2D = x.as2D(-1, inSize);
                    return this.reduce(a2D, 'max', a2D.dtype).reshape(outShape);
                };
                MathBackendWebGL.prototype.divide = function (a, b) {
                    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.DIV, a.shape, b.shape);
                    var output = this.makeOutputArray(program.outputShape, 'float32');
                    return this.compileAndRun(program, [a, b], output);
                };
                MathBackendWebGL.prototype.add = function (a, b) {
                    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.ADD, a.shape, b.shape);
                    return this.compileAndRun(program, [a, b]);
                };
                MathBackendWebGL.prototype.subtract = function (a, b) {
                    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.SUB, a.shape, b.shape);
                    return this.compileAndRun(program, [a, b]);
                };
                MathBackendWebGL.prototype.pow = function (a, b) {
                    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.POW, a.shape, b.shape);
                    return this.compileAndRun(program, [a, b]);
                };
                MathBackendWebGL.prototype.ceil = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.CEIL);
                    return this.compileAndRun(program, [x]);
                };
                MathBackendWebGL.prototype.floor = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.FLOOR);
                    return this.compileAndRun(program, [x]);
                };
                MathBackendWebGL.prototype.exp = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.EXP);
                    return this.compileAndRun(program, [x]);
                };
                MathBackendWebGL.prototype.log = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.LOG);
                    return this.compileAndRun(program, [x]);
                };
                MathBackendWebGL.prototype.sqrt = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SQRT);
                    return this.compileAndRun(program, [x]);
                };
                MathBackendWebGL.prototype.square = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SQUARE);
                    return this.compileAndRun(program, [x]);
                };
                MathBackendWebGL.prototype.relu = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.RELU);
                    return this.compileAndRun(program, [x]);
                };
                MathBackendWebGL.prototype.elu = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ELU);
                    return this.compileAndRun(program, [x]);
                };
                MathBackendWebGL.prototype.eluDer = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ELU_DER);
                    return this.compileAndRun(program, [x]);
                };
                MathBackendWebGL.prototype.selu = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SELU);
                    return this.compileAndRun(program, [x]);
                };
                MathBackendWebGL.prototype.leakyRelu = function (x, alpha) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.LEAKY_RELU(alpha));
                    return this.compileAndRun(program, [x]);
                };
                MathBackendWebGL.prototype.prelu = function (a, b) {
                    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.PRELU, a.shape, b.shape);
                    return this.compileAndRun(program, [a, b]);
                };
                MathBackendWebGL.prototype.preluDer = function (a, b) {
                    var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.PRELU_DER, a.shape, b.shape);
                    return this.compileAndRun(program, [a, b]);
                };
                MathBackendWebGL.prototype.clip = function (x, min, max) {
                    var program = new clip_gpu_1.ClipProgram(x.shape, min, max);
                    return this.compileAndRun(program, [x]);
                };
                MathBackendWebGL.prototype.abs = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ABS);
                    return this.compileAndRun(program, [x]);
                };
                MathBackendWebGL.prototype.sigmoid = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SIGMOID);
                    return this.compileAndRun(program, [x]);
                };
                MathBackendWebGL.prototype.sin = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SIN);
                    return this.compileAndRun(program, [x]);
                };
                MathBackendWebGL.prototype.cos = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.COS);
                    return this.compileAndRun(program, [x]);
                };
                MathBackendWebGL.prototype.tan = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.TAN);
                    return this.compileAndRun(program, [x]);
                };
                MathBackendWebGL.prototype.asin = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ASIN);
                    return this.compileAndRun(program, [x]);
                };
                MathBackendWebGL.prototype.acos = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ACOS);
                    return this.compileAndRun(program, [x]);
                };
                MathBackendWebGL.prototype.atan = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ATAN);
                    return this.compileAndRun(program, [x]);
                };
                MathBackendWebGL.prototype.sinh = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SINH);
                    return this.compileAndRun(program, [x]);
                };
                MathBackendWebGL.prototype.cosh = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.COSH);
                    return this.compileAndRun(program, [x]);
                };
                MathBackendWebGL.prototype.tanh = function (x) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.TANH);
                    return this.compileAndRun(program, [x]);
                };
                MathBackendWebGL.prototype.step = function (x, alpha) {
                    var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.STEP(alpha));
                    return this.compileAndRun(program, [x]);
                };
                MathBackendWebGL.prototype.conv2d = function (x, filter, bias, convInfo) {
                    var program = new conv_gpu_1.Conv2DProgram(convInfo, bias != null);
                    var inputs = bias != null ? [x, filter, bias] : [x, filter];
                    return this.compileAndRun(program, inputs);
                };
                MathBackendWebGL.prototype.conv2dDerInput = function (dy, filter, convInfo) {
                    var program = new conv_backprop_gpu_1.Conv2DDerInputProgram(convInfo);
                    return this.compileAndRun(program, [dy, filter]);
                };
                MathBackendWebGL.prototype.conv2dDerFilter = function (x, dy, convInfo) {
                    var program = new conv_backprop_gpu_1.Conv2DDerFilterProgram(convInfo);
                    return this.compileAndRun(program, [x, dy]);
                };
                MathBackendWebGL.prototype.conv2dDerBias = function (dy) {
                    var program = new conv_backprop_gpu_1.Conv2DDerBiasProgram(dy.shape);
                    return this.compileAndRun(program, [dy]);
                };
                MathBackendWebGL.prototype.depthwiseConv2D = function (x, filter, convInfo) {
                    var program = new conv_gpu_depthwise_1.DepthwiseConv2DProgram(convInfo);
                    return this.compileAndRun(program, [x, filter]);
                };
                MathBackendWebGL.prototype.maxPool = function (x, convInfo) {
                    var program = new pool_gpu_1.Pool2DProgram(convInfo, 'max', false);
                    return this.compileAndRun(program, [x]);
                };
                MathBackendWebGL.prototype.minPool = function (x, convInfo) {
                    var program = new pool_gpu_1.Pool2DProgram(convInfo, 'min', false);
                    return this.compileAndRun(program, [x]);
                };
                MathBackendWebGL.prototype.avgPool = function (x, convInfo) {
                    var program = new pool_gpu_1.Pool2DProgram(convInfo, 'avg', false);
                    return this.compileAndRun(program, [x]);
                };
                MathBackendWebGL.prototype.maxPoolBackprop = function (dy, x, convInfo) {
                    var getPositions = true;
                    var maxPoolPositionsProgram = new pool_gpu_1.Pool2DProgram(convInfo, 'max', getPositions);
                    var maxPoolPositions = this.compileAndRun(maxPoolPositionsProgram, [x]);
                    var maxPoolBackPropProgram = new max_pool_backprop_gpu_1.MaxPool2DBackpropProgram(convInfo);
                    var result = this.compileAndRun(maxPoolBackPropProgram, [dy, maxPoolPositions]);
                    maxPoolPositions.dispose();
                    return result;
                };
                MathBackendWebGL.prototype.resizeBilinear3D = function (x, newShape2D, alignCorners) {
                    var program = new resize_bilinear_gpu_1.ResizeBilinear3DProgram(x.shape, newShape2D, alignCorners);
                    return this.compileAndRun(program, [x]);
                };
                MathBackendWebGL.prototype.multinomial = function (probs, numSamples, seed) {
                    var batchSize = probs.shape[0];
                    var numOutcomes = probs.shape[1];
                    var program = new multinomial_gpu_1.MultinomialProgram(batchSize, numOutcomes, numSamples);
                    var output = this.makeOutputArray(program.outputShape, 'int32');
                    var customSetup = program.getCustomSetupFunc(seed);
                    return this.compileAndRun(program, [probs], output, customSetup);
                };
                MathBackendWebGL.prototype.oneHot = function (indices, depth, onValue, offValue) {
                    var program = new onehot_gpu_1.OneHotProgram(indices.size, depth, onValue, offValue);
                    return this.compileAndRun(program, [indices]);
                };
                MathBackendWebGL.prototype.makeOutputArray = function (shape, dtype) {
                    return ndarray_1.NDArray.make(shape, {}, dtype);
                };
                MathBackendWebGL.prototype.compileAndRun = function (program, inputs, output, customSetup) {
                    var _this = this;
                    if (output == null) {
                        output = this.makeOutputArray(program.outputShape, inputs[0].dtype);
                    }
                    var inputsData = inputs.map(function (input) {
                        _this.throwIfNoData(input.id);
                        return {array: input, texData: _this.texData[input.id]};
                    });
                    this.throwIfNoData(output.id);
                    var outputData = {array: output, texData: this.texData[output.id]};
                    var key = gpgpu_math.makeShaderKey(program, inputsData, outputData);
                    var binary = this.getAndSaveBinary(key, function () {
                        return gpgpu_math.compileProgram(_this.gpgpu, program, inputsData, outputData);
                    });
                    gpgpu_math.runProgram(binary, inputsData, outputData, customSetup);
                    return output;
                };
                MathBackendWebGL.prototype.getAndSaveBinary = function (key, getBinary) {
                    if (!(key in this.binaryCache)) {
                        this.binaryCache[key] = getBinary();
                    }
                    return this.binaryCache[key];
                };
                MathBackendWebGL.prototype.getTextureManager = function () {
                    return this.textureManager;
                };
                MathBackendWebGL.prototype.dispose = function () {
                    for (var key in this.binaryCache) {
                        this.gpgpu.deleteProgram(this.binaryCache[key].webGLProgram);
                    }
                    this.textureManager.dispose();
                    if (this.gpgpuCreatedLocally) {
                        this.gpgpu.dispose();
                    }
                };
                MathBackendWebGL.prototype.throwIfNoData = function (id) {
                    if (!(id in this.texData)) {
                        throw new Error("No data found for NDArray with id " + id + ". " +
                            "Use dl.ENV.math instead of constructing your own NDArrayMath. " +
                            "If you need to construct your own math, make sure this array is " +
                            "allocated after the math construction");
                    }
                };
                return MathBackendWebGL;
            }());
            exports.MathBackendWebGL = MathBackendWebGL;
            environment_1.ENV.registerBackend('webgl', function () {
                return new MathBackendWebGL();
            });
            var NDArrayMathGPU = (function (_super) {
                __extends(NDArrayMathGPU, _super);

                function NDArrayMathGPU(gpgpu, safeMode) {
                    if (safeMode === void 0) {
                        safeMode = false;
                    }
                    var _this = this;
                    console.warn('new NDArrayMathGPU() is deprecated. Please use the global ' +
                        'dl.ENV.math. In rare cases, to construct your own NDArrayMath ' +
                        'that runs on GPU, use math = new NDArrayMath(\'webgl\', safeMode); ' +
                        'and make sure to set it as global: dl.ENV.setMath(math);');
                    _this = _super.call(this, new MathBackendWebGL(gpgpu), safeMode) || this;
                    environment_1.ENV.setMath(_this);
                    return _this;
                }

                NDArrayMathGPU.prototype.getGPGPUContext = function () {
                    return this.backendEngine.getBackend()
                        .getGPGPUContext();
                };
                NDArrayMathGPU.prototype.getTextureManager = function () {
                    return this.backendEngine.getBackend()
                        .getTextureManager();
                };
                return NDArrayMathGPU;
            }(math_1.NDArrayMath));
            exports.NDArrayMathGPU = NDArrayMathGPU;

            function float32ToTypedArray(a, dtype) {
                if (dtype === 'float32') {
                    return a;
                } else if (dtype === 'int32' || dtype === 'bool') {
                    var result = (dtype === 'int32') ? new Int32Array(a.length) :
                        new Uint8Array(a.length);
                    for (var i = 0; i < result.length; ++i) {
                        var val = a[i];
                        val = isNaN(val) ? util.getNaN(dtype) : Math.round(val);
                        result[i] = val;
                    }
                    return result;
                } else {
                    throw new Error("Unknown dtype " + dtype);
                }
            }

            function typedArrayToFloat32(a, dtype) {
                if (a instanceof Float32Array) {
                    return a;
                } else {
                    var res = new Float32Array(a.length);
                    for (var i = 0; i < res.length; i++) {
                        var val = a[i];
                        res[i] = util.isValNaN(val, dtype) ? NaN : val;
                    }
                    return res;
                }
            }

        }, {
            "../../environment": 15,
            "../../util": 101,
            "../axis_util": 54,
            "../math": 94,
            "../ndarray": 95,
            "../reduce_util": 97,
            "../types": 99,
            "./webgl/argminmax_gpu": 62,
            "./webgl/batchnorm_gpu": 63,
            "./webgl/binaryop_gpu": 64,
            "./webgl/clip_gpu": 65,
            "./webgl/concat_gpu": 66,
            "./webgl/conv_backprop_gpu": 67,
            "./webgl/conv_gpu": 68,
            "./webgl/conv_gpu_depthwise": 69,
            "./webgl/copy_gpu": 70,
            "./webgl/gpgpu_context": 71,
            "./webgl/gpgpu_math": 72,
            "./webgl/gpgpu_util": 73,
            "./webgl/max_pool_backprop_gpu": 74,
            "./webgl/mulmat_gpu": 75,
            "./webgl/multinomial_gpu": 76,
            "./webgl/onehot_gpu": 77,
            "./webgl/pool_gpu": 78,
            "./webgl/reduce_gpu": 79,
            "./webgl/resize_bilinear_gpu": 81,
            "./webgl/slice_gpu": 83,
            "./webgl/tex_util": 84,
            "./webgl/texture_manager": 85,
            "./webgl/tile_gpu": 86,
            "./webgl/transpose_gpu": 87,
            "./webgl/unaryop_gpu": 88,
            "./webgl/webgl_util": 89
        }],
        58: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var KERNEL_METHODS = {
                MatMul: function (backend, config) {
                    return backend.matMul(config.inputs.a, config.inputs.b, config.args.aOrientation, config.args.bOrientation);
                },
                Clone: function (backend, config) {
                    return backend.clone(config.inputs.x);
                },
                Slice1D: function (backend, config) {
                    return backend.slice1D(config.inputs.x, config.args.begin, config.args.size);
                },
                Slice2D: function (backend, config) {
                    return backend.slice2D(config.inputs.x, config.args.begin, config.args.size);
                },
                Slice3D: function (backend, config) {
                    return backend.slice3D(config.inputs.x, config.args.begin, config.args.size);
                },
                Slice4D: function (backend, config) {
                    return backend.slice4D(config.inputs.x, config.args.begin, config.args.size);
                },
                Concat1D: function (backend, config) {
                    return backend.concat1D(config.inputs.a, config.inputs.b);
                },
                Concat2D: function (backend, config) {
                    return backend.concat2D(config.inputs.a, config.inputs.b, config.args.axis);
                },
                Concat3D: function (backend, config) {
                    return backend.concat3D(config.inputs.a, config.inputs.b, config.args.axis);
                },
                Concat4D: function (backend, config) {
                    return backend.concat4D(config.inputs.a, config.inputs.b, config.args.axis);
                },
                Neg: function (backend, config) {
                    return backend.neg(config.inputs.x);
                },
                Add: function (backend, config) {
                    return backend.add(config.inputs.a, config.inputs.b);
                },
                Sub: function (backend, config) {
                    return backend.subtract(config.inputs.a, config.inputs.b);
                },
                Mul: function (backend, config) {
                    return backend.multiply(config.inputs.a, config.inputs.b);
                },
                Div: function (backend, config) {
                    return backend.divide(config.inputs.a, config.inputs.b);
                },
                Sum: function (backend, config) {
                    return backend.sum(config.inputs.x, config.args.axes);
                },
                ArgMax: function (backend, config) {
                    return backend.argMax(config.inputs.x, config.args.axes);
                },
                ArgMin: function (backend, config) {
                    return backend.argMin(config.inputs.x, config.args.axes);
                },
                Equal: function (backend, config) {
                    return backend.equal(config.inputs.a, config.inputs.b);
                },
                TopKValues: function (backend, config) {
                    return backend.topKValues(config.inputs.x, config.args.k);
                },
                TopKIndices: function (backend, config) {
                    return backend.topKIndices(config.inputs.x, config.args.k);
                },
                Min: function (backend, config) {
                    return backend.min(config.inputs.x, config.args.axes);
                },
                Max: function (backend, config) {
                    return backend.max(config.inputs.x, config.args.axes);
                },
                Ceil: function (backend, config) {
                    return backend.ceil(config.inputs.x);
                },
                Floor: function (backend, config) {
                    return backend.floor(config.inputs.x);
                },
                Pow: function (backend, config) {
                    return backend.pow(config.inputs.a, config.inputs.b);
                },
                Exp: function (backend, config) {
                    return backend.exp(config.inputs.x);
                },
                Log: function (backend, config) {
                    return backend.log(config.inputs.x);
                },
                Sqrt: function (backend, config) {
                    return backend.sqrt(config.inputs.x);
                },
                Square: function (backend, config) {
                    return backend.square(config.inputs.x);
                },
                Relu: function (backend, config) {
                    return backend.relu(config.inputs.x);
                },
                LeakyRelu: function (backend, config) {
                    return backend.leakyRelu(config.inputs.x, config.args.alpha);
                },
                PReLU: function (backend, config) {
                    return backend.prelu(config.inputs.x, config.inputs.alpha);
                },
                PReLUDer: function (backend, config) {
                    return backend.preluDer(config.inputs.x, config.inputs.alpha);
                },
                Elu: function (backend, config) {
                    return backend.elu(config.inputs.x);
                },
                EluDer: function (backend, config) {
                    return backend.eluDer(config.inputs.x);
                },
                Selu: function (backend, config) {
                    return backend.selu(config.inputs.x);
                },
                Abs: function (backend, config) {
                    return backend.abs(config.inputs.x);
                },
                Sigmoid: function (backend, config) {
                    return backend.sigmoid(config.inputs.x);
                },
                Step: function (backend, config) {
                    return backend.step(config.inputs.x, config.args.alpha);
                },
                Sin: function (backend, config) {
                    return backend.sin(config.inputs.x);
                },
                Cos: function (backend, config) {
                    return backend.cos(config.inputs.x);
                },
                Tan: function (backend, config) {
                    return backend.tan(config.inputs.x);
                },
                Asin: function (backend, config) {
                    return backend.asin(config.inputs.x);
                },
                Acos: function (backend, config) {
                    return backend.acos(config.inputs.x);
                },
                Atan: function (backend, config) {
                    return backend.atan(config.inputs.x);
                },
                Sinh: function (backend, config) {
                    return backend.sinh(config.inputs.x);
                },
                Cosh: function (backend, config) {
                    return backend.cosh(config.inputs.x);
                },
                Tanh: function (backend, config) {
                    return backend.tanh(config.inputs.x);
                },
                Clip: function (backend, config) {
                    return backend.clip(config.inputs.x, config.args.min, config.args.max);
                },
                Transpose: function (backend, config) {
                    return backend.transpose(config.inputs.x, config.args.perm);
                },
                Tile: function (backend, config) {
                    return backend.tile(config.inputs.x, config.args.reps);
                },
                Conv2D: function (backend, config) {
                    return backend.conv2d(config.inputs.x, config.inputs.filter, config.inputs.bias, config.args.convInfo);
                },
                Conv2DDerInput: function (backend, config) {
                    return backend.conv2dDerInput(config.inputs.dy, config.inputs.filter, config.args.convInfo);
                },
                Conv2DDerFilter: function (backend, config) {
                    return backend.conv2dDerFilter(config.inputs.x, config.inputs.dy, config.args.convInfo);
                },
                Conv2DDerBias: function (backend, config) {
                    return backend.conv2dDerBias(config.inputs.dy);
                },
                DepthwiseConv2D: function (backend, config) {
                    return backend.depthwiseConv2D(config.inputs.x, config.inputs.filter, config.args.convInfo);
                },
                MaxPool: function (backend, config) {
                    return backend.maxPool(config.inputs.x, config.args.convInfo);
                },
                MaxPoolBackprop: function (backend, config) {
                    return backend.maxPoolBackprop(config.inputs.dy, config.inputs.x, config.args.convInfo);
                },
                AvgPool: function (backend, config) {
                    return backend.avgPool(config.inputs.x, config.args.convInfo);
                },
                MinPool: function (backend, config) {
                    return backend.minPool(config.inputs.x, config.args.convInfo);
                },
                ResizeBilinear3D: function (backend, config) {
                    return backend.resizeBilinear3D(config.inputs.x, config.args.newShape2D, config.args.alignCorners);
                },
                BatchNorm3D: function (backend, config) {
                    return backend.batchNormalization3D(config.inputs.x, config.inputs.mean, config.inputs.variance, config.args.varianceEpsilon, config.inputs.scale, config.inputs.offset);
                },
                BatchNorm2D: function (backend, config) {
                    return backend.batchNormalization2D(config.inputs.x, config.inputs.mean, config.inputs.variance, config.args.varianceEpsilon, config.inputs.scale, config.inputs.offset);
                },
                Multinomial: function (backend, config) {
                    return backend.multinomial(config.inputs.probs, config.args.numSamples, config.args.seed);
                },
                OneHot: function (backend, config) {
                    return backend.oneHot(config.inputs.indices, config.args.depth, config.args.onValue, config.args.offValue);
                }
            };

            function executeKernel(backend, kernelName, config) {
                return KERNEL_METHODS[kernelName](backend, config);
            }

            exports.executeKernel = executeKernel;

        }, {}],
        59: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var ndarray_1 = require("../ndarray");
            var tape_util = require("./tape_util");
            var Tape = (function () {
                function Tape(backend) {
                    this.backend = backend;
                    this.evaluatedTapeNodes = [];
                    this.outputNodeMap = {};
                }

                Tape.prototype.addEvaluatedKernelNode = function (node) {
                    this.outputNodeMap[node.output.id] = node;
                    this.evaluatedTapeNodes.push(node);
                };
                Tape.prototype.gradientWrt = function (y, xs) {
                    if (this.outputNodeMap[y.id] == null) {
                        throw new Error("Cannot compute gradient: y is not part of this tape.");
                    }
                    var filteredNodes = tape_util.getFilteredNodesXToY(this.evaluatedTapeNodes, xs, y);
                    var arrayAccumulatedGradientMap = {};
                    arrayAccumulatedGradientMap[y.id] = ndarray_1.Scalar.new(1);
                    tape_util.backpropagateGradients(this.backend, arrayAccumulatedGradientMap, filteredNodes);
                    var gradients = [];
                    for (var i = 0; i < xs.length; i++) {
                        gradients.push(arrayAccumulatedGradientMap[xs[i].id]);
                    }
                    return gradients;
                };
                return Tape;
            }());
            exports.Tape = Tape;

        }, {"../ndarray": 95, "./tape_util": 60}],
        60: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});

            function getFilteredNodesXToY(tapeNodes, xs, y) {
                var arraysFromX = {};
                for (var i = 0; i < xs.length; i++) {
                    arraysFromX[xs[i].id] = true;
                }
                for (var i = 0; i < tapeNodes.length; i++) {
                    var node = tapeNodes[i];
                    var nodeInputs = node.inputAndArgs.inputs;
                    for (var inputName in nodeInputs) {
                        var input = nodeInputs[inputName];
                        for (var j = 0; j < xs.length; j++) {
                            if (arraysFromX[input.id]) {
                                arraysFromX[node.output.id] = true;
                                break;
                            }
                        }
                        if (arraysFromX[node.output.id]) {
                            break;
                        }
                    }
                }
                var arraysLeadToY = {};
                arraysLeadToY[y.id] = true;
                for (var i = tapeNodes.length - 1; i >= 0; i--) {
                    var node = tapeNodes[i];
                    var nodeInputs = node.inputAndArgs.inputs;
                    if (arraysLeadToY[node.output.id]) {
                        for (var inputName in nodeInputs) {
                            arraysLeadToY[nodeInputs[inputName].id] = true;
                        }
                    }
                }
                var filteredTapeNodes = [];
                for (var i = 0; i < tapeNodes.length; i++) {
                    var node = tapeNodes[i];
                    if (arraysFromX[node.output.id] && arraysLeadToY[node.output.id]) {
                        var prunedInputs = {};
                        for (var inputName in node.inputAndArgs.inputs) {
                            var nodeInput = node.inputAndArgs.inputs[inputName];
                            if (arraysFromX[nodeInput.id]) {
                                prunedInputs[inputName] = nodeInput;
                            }
                        }
                        var prunedNode = Object.assign({}, node);
                        prunedNode.inputAndArgs = {inputs: prunedInputs};
                        filteredTapeNodes.push(prunedNode);
                    }
                }
                return filteredTapeNodes;
            }

            exports.getFilteredNodesXToY = getFilteredNodesXToY;

            function backpropagateGradients(backend, arrayAccumulatedGradientMap, filteredNodes) {
                for (var i = filteredNodes.length - 1; i >= 0; i--) {
                    var node = filteredNodes[i];
                    var dy = arrayAccumulatedGradientMap[node.output.id];
                    if (node.gradient == null) {
                        throw new Error("Cannot compute gradient: gradient function not found for\n              " + node.name + ".");
                    }
                    var inputGradients = node.gradient(dy, node.output);
                    for (var inputName in node.inputAndArgs.inputs) {
                        if (!(inputName in inputGradients)) {
                            throw new Error("Cannot backprop through input " +
                                (node.name + "." + inputName + ". Gradients found: ") +
                                (Object.keys(inputGradients) + "."));
                        }
                        var grad = inputGradients[inputName]();
                        var activation = node.inputAndArgs.inputs[inputName];
                        if (arrayAccumulatedGradientMap[activation.id] == null) {
                            arrayAccumulatedGradientMap[activation.id] = grad;
                        } else {
                            var curGradient = arrayAccumulatedGradientMap[activation.id];
                            arrayAccumulatedGradientMap[activation.id] =
                                backend.add(curGradient, grad);
                            curGradient.dispose();
                        }
                    }
                }
            }

            exports.backpropagateGradients = backpropagateGradients;

        }, {}],
        61: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var MatrixOrientation;
            (function (MatrixOrientation) {
                MatrixOrientation[MatrixOrientation["REGULAR"] = 0] = "REGULAR";
                MatrixOrientation[MatrixOrientation["TRANSPOSED"] = 1] = "TRANSPOSED";
            })(MatrixOrientation = exports.MatrixOrientation || (exports.MatrixOrientation = {}));

        }, {}],
        62: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var ArgMinMaxProgram = (function () {
                function ArgMinMaxProgram(reduceInfo, op, firstPass) {
                    this.variableNames = ['A'];
                    var windowSize = reduceInfo.windowSize;
                    var batchSize = reduceInfo.batchSize;
                    var inSize = reduceInfo.inSize;
                    var outSize = Math.ceil(inSize / windowSize);
                    if (!firstPass) {
                        this.variableNames.push('bestIndicesA');
                    }
                    this.outputShape = [batchSize, outSize];
                    var compOp = (op === 'max') ? '>' : '<';
                    var indexSnippet = firstPass ?
                        'inOffset + i;' :
                        'round(getBestIndicesA(batch, inOffset + i));';
                    this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + windowSize + ";\n\n        int bestIndex = 0;\n        float bestValue = getA(batch, inOffset);\n\n        for (int i = 0; i < " + windowSize + "; i++) {\n          int inIdx = " + indexSnippet + ";\n          float candidate = getA(batch, inIdx);\n          if (isNaN(candidate)) {\n            setOutput(candidate);\n            return;\n          }\n          if (candidate " + compOp + " bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ";
                }

                return ArgMinMaxProgram;
            }());
            exports.ArgMinMaxProgram = ArgMinMaxProgram;

        }, {}],
        63: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var broadcast_util = require("../../broadcast_util");
            var BatchNormProgram = (function () {
                function BatchNormProgram(xShape, meanShape, varianceShape, offsetShape, scaleShape, varianceEpsilon) {
                    this.outputShape = [];
                    this.supportsBroadcasting = true;
                    this.variableNames = ['x', 'mean', 'variance'];
                    broadcast_util.assertAndGetBroadcastShape(xShape, meanShape);
                    broadcast_util.assertAndGetBroadcastShape(xShape, varianceShape);
                    var offsetSnippet = '0.0';
                    if (offsetShape != null) {
                        broadcast_util.assertAndGetBroadcastShape(xShape, offsetShape);
                        this.variableNames.push('offset');
                        offsetSnippet = 'getOffsetAtOutCoords()';
                    }
                    var scaleSnippet = '1.0';
                    if (scaleShape != null) {
                        broadcast_util.assertAndGetBroadcastShape(xShape, scaleShape);
                        this.variableNames.push('scale');
                        scaleSnippet = 'getScaleAtOutCoords()';
                    }
                    this.outputShape = xShape;
                    this.userCode = "\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = " + offsetSnippet + ";\n        float scale = " + scaleSnippet + ";\n        float inv = scale / sqrt(variance + float(" + varianceEpsilon + "));\n        setOutput((x - mean) * inv + offset);\n      }\n    ";
                }

                return BatchNormProgram;
            }());
            exports.BatchNormProgram = BatchNormProgram;

        }, {"../../broadcast_util": 90}],
        64: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var broadcast_util = require("../../broadcast_util");
            exports.ADD = 'return a + b;';
            exports.SUB = 'return a - b;';
            exports.MUL = 'return a * b;';
            exports.DIV = 'return a / b;';
            exports.POW = "\n  return (round(mod(b, 2.0)) == 0 || round(mod(b, 2.0)) == 2) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n";
            exports.EQUAL = "\n  if (isNaN(a)) return a;\n  if (isNaN(b)) return b;\n  return float(a == b);\n";
            exports.PRELU = "\n  return (a >= 0.0) ? a : b * a;\n";
            exports.PRELU_DER = "\n  return (a > 0.0) ? 1.0 : ((a < 0.0) ? b : a);\n";
            var BinaryOpProgram = (function () {
                function BinaryOpProgram(op, aShape, bShape) {
                    this.variableNames = ['A', 'B'];
                    this.supportsBroadcasting = true;
                    this.outputShape =
                        broadcast_util.assertAndGetBroadcastShape(aShape, bShape);
                    this.userCode = "\n      float binaryOperation(float a, float b) {\n        " + op + "\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ";
                }

                return BinaryOpProgram;
            }());
            exports.BinaryOpProgram = BinaryOpProgram;

        }, {"../../broadcast_util": 90}],
        65: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var ClipProgram = (function () {
                function ClipProgram(aShape, min, max) {
                    this.variableNames = ['A'];
                    this.outputShape = aShape;
                    var minFixed = min.toFixed(20);
                    var maxFixed = max.toFixed(20);
                    this.userCode = "\n      void main() {\n        float value = getAAtOutCoords();\n        if (isNaN(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, " + minFixed + ", " + maxFixed + "));\n      }\n    ";
                }

                return ClipProgram;
            }());
            exports.ClipProgram = ClipProgram;

        }, {}],
        66: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var concat_util = require("../../concat_util");
            var shader_compiler_1 = require("./shader_compiler");
            var ConcatProgram = (function () {
                function ConcatProgram(aShape, bShape, axis) {
                    this.variableNames = ['A', 'B'];
                    this.outputShape = [];
                    var yAxes = ['yR', 'yC', 'yD', 'yW'];
                    var concatAxis = yAxes[axis];
                    this.outputShape = concat_util.computeOutShape(aShape, bShape, axis);
                    var dType = shader_compiler_1.getCoordsDataType(aShape.length);
                    var unpackSnippet = getUnpack(aShape.length);
                    var sampleCoords = getSampleCoords(aShape.length);
                    this.userCode = "\n      void main() {\n        " + dType + " coords = getOutputCoords();\n        " + unpackSnippet + "\n\n        float value = 0.0;\n        if (" + concatAxis + " < " + aShape[axis] + ") {\n          value = getA(" + sampleCoords + ");\n        } else {\n          " + concatAxis + " -= " + aShape[axis] + ";\n          value = getB(" + sampleCoords + ");\n        }\n\n        setOutput(value);\n      }\n    ";
                }

                return ConcatProgram;
            }());
            exports.ConcatProgram = ConcatProgram;

            function getSampleCoords(rank) {
                if (rank === 1) {
                    return 'yR';
                } else if (rank === 2) {
                    return 'yR, yC';
                } else if (rank === 3) {
                    return 'yR, yC, yD';
                } else if (rank === 4) {
                    return 'yR, yC, yD, yW';
                } else {
                    throw Error("Concat for rank " + rank + " is not yet supported");
                }
            }

            function getUnpack(rank) {
                var res = rank === 1 ? 'int yR = coords;' : 'int yR = coords.x;';
                if (rank > 1) {
                    res += '\nint yC = coords.y;';
                }
                if (rank > 2) {
                    res += '\nint yD = coords.z;';
                }
                if (rank > 3) {
                    res += '\nint yW = coords.w;';
                }
                if (rank > 4) {
                    throw Error("Concat for rank " + rank + " is not yet supported");
                }
                return res;
            }

        }, {"../../concat_util": 91, "./shader_compiler": 82}],
        67: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var Conv2DDerFilterProgram = (function () {
                function Conv2DDerFilterProgram(convInfo) {
                    this.variableNames = ['x', 'dy'];
                    this.outputShape = convInfo.filterShape;
                    var strideHeight = convInfo.strideHeight;
                    var strideWidth = convInfo.strideWidth;
                    var padTop = convInfo.padInfo.top;
                    var padLeft = convInfo.padInfo.left;
                    this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < " + convInfo.batchSize + "; b++) {\n          for (int yR = 0; yR < " + convInfo.outHeight + "; yR++) {\n            int xR = wR + yR * " + strideHeight + " - " + padTop + ";\n\n            if (xR < 0 || xR >= " + convInfo.inHeight + ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < " + convInfo.outWidth + "; yC++) {\n              int xC = wC + yC * " + strideWidth + " - " + padLeft + ";\n\n              if (xC < 0 || xC >= " + convInfo.inWidth + ") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
                }

                return Conv2DDerFilterProgram;
            }());
            exports.Conv2DDerFilterProgram = Conv2DDerFilterProgram;
            var Conv2DDerInputProgram = (function () {
                function Conv2DDerInputProgram(convInfo) {
                    this.variableNames = ['dy', 'W'];
                    this.outputShape = convInfo.inShape;
                    var filterHeight = convInfo.filterHeight;
                    var filterWidth = convInfo.filterWidth;
                    var strideHeight = convInfo.strideHeight;
                    var strideWidth = convInfo.strideWidth;
                    var padTop = filterHeight - 1 - convInfo.padInfo.top;
                    var padLeft = filterWidth - 1 - convInfo.padInfo.left;
                    this.userCode = "\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + strideHeight + ".0;\n\n          if (dyR < 0.0 || dyR >= " + convInfo.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " + filterHeight + " - 1 - wR;\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + strideWidth + ".0;\n\n            if (dyC < 0.0 || dyC >= " + convInfo.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " + filterWidth + " - 1 - wC;\n\n            for (int d2 = 0; d2 < " + convInfo.outChannels + "; d2++) {\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, d2);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
                }

                return Conv2DDerInputProgram;
            }());
            exports.Conv2DDerInputProgram = Conv2DDerInputProgram;
            var Conv2DDerBiasProgram = (function () {
                function Conv2DDerBiasProgram(yShape) {
                    this.variableNames = ['dy'];
                    var batchSize = yShape[0], yNumRows = yShape[1], yNumCols = yShape[2], outputDepth = yShape[3];
                    this.outputShape = [outputDepth];
                    this.userCode = "\n      void main() {\n        int d2 = getOutputCoords();\n\n        float derBias = 0.0;\n        for (int b = 0; b < " + batchSize + "; b++) {\n          for (int yR = 0; yR < " + yNumRows + "; yR++) {\n            for (int yC = 0; yC < " + yNumCols + "; yC++) {\n              derBias += getDy(b, yR, yC, d2);\n            }\n          }\n        }\n        setOutput(derBias);\n      }\n    ";
                }

                return Conv2DDerBiasProgram;
            }());
            exports.Conv2DDerBiasProgram = Conv2DDerBiasProgram;

        }, {}],
        68: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var Conv2DProgram = (function () {
                function Conv2DProgram(convInfo, hasBias) {
                    this.variableNames = ['x', 'W'];
                    if (hasBias) {
                        this.variableNames.push('bias');
                    }
                    this.outputShape = convInfo.outShape;
                    var biasSnippet = hasBias ? 'dotProd += getBias(d2);' : '';
                    var padTop = convInfo.padInfo.top;
                    var padLeft = convInfo.padInfo.left;
                    var strideHeight = convInfo.strideHeight;
                    var strideWidth = convInfo.strideWidth;
                    var filterHeight = convInfo.filterHeight;
                    var filterWidth = convInfo.filterWidth;
                    var inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;
                    var inputDepthVec4Remainder = convInfo.inChannels % 4;
                    this.userCode = "\n      const ivec2 strides = ivec2(" + strideHeight + ", " + strideWidth + ");\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= " + convInfo.inHeight + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            int xC = xCCorner + wC;\n\n            if (xC < 0 || xC >= " + convInfo.inWidth + ") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < " + inputDepthNearestVec4 + "; d1 += 4) {\n              vec4 xValues = vec4(\n                getX(batch, xR, xC, d1),\n                getX(batch, xR, xC, d1 + 1),\n                getX(batch, xR, xC, d1 + 2),\n                getX(batch, xR, xC, d1 + 3)\n              );\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              dotProd += dot(xValues, wValues);\n            }\n\n            if (" + (inputDepthVec4Remainder === 1) + ") {\n              dotProd +=\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + ") *\n                getW(wR, wC, " + inputDepthNearestVec4 + ", d2);\n            } else if (" + (inputDepthVec4Remainder === 2) + ") {\n              vec2 xValues = vec2(\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + "),\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + " + 1)\n              );\n              vec2 wValues = vec2(\n                getW(wR, wC, " + inputDepthNearestVec4 + ", d2),\n                getW(wR, wC, " + inputDepthNearestVec4 + " + 1, d2)\n              );\n              dotProd += dot(xValues, wValues);\n            } else if (" + (inputDepthVec4Remainder === 3) + ") {\n              vec3 xValues = vec3(\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + "),\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + " + 1),\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + " + 2)\n              );\n              vec3 wValues = vec3(\n                getW(wR, wC, " + inputDepthNearestVec4 + ", d2),\n                getW(wR, wC, " + inputDepthNearestVec4 + " + 1, d2),\n                getW(wR, wC, " + inputDepthNearestVec4 + " + 2, d2)\n              );\n              dotProd += dot(xValues, wValues);\n            }\n          }\n        }\n        " + biasSnippet + "\n        setOutput(dotProd);\n      }\n    ";
                }

                return Conv2DProgram;
            }());
            exports.Conv2DProgram = Conv2DProgram;

        }, {}],
        69: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var DepthwiseConv2DProgram = (function () {
                function DepthwiseConv2DProgram(convInfo) {
                    this.variableNames = ['x', 'W'];
                    this.outputShape = convInfo.outShape;
                    var xNumRows = convInfo.inHeight;
                    var xNumCols = convInfo.inWidth;
                    var padTop = convInfo.padInfo.top;
                    var padLeft = convInfo.padInfo.left;
                    var strideHeight = convInfo.strideHeight;
                    var strideWidth = convInfo.strideWidth;
                    var filterHeight = convInfo.filterHeight;
                    var filterWidth = convInfo.filterWidth;
                    var channelMul = convInfo.outChannels / convInfo.inChannels;
                    this.userCode = "\n      const ivec2 strides = ivec2(" + strideHeight + ", " + strideWidth + ");\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / " + channelMul + ";\n        int q = d2 - d1 * " + channelMul + ";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TODO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= " + xNumRows + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            int xC = xCCorner + wC;\n\n            if (xC < 0 || xC >= " + xNumCols + ") {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
                }

                return DepthwiseConv2DProgram;
            }());
            exports.DepthwiseConv2DProgram = DepthwiseConv2DProgram;

        }, {}],
        70: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var Copy2DProgram = (function () {
                function Copy2DProgram(srcNumCols, destNumCols) {
                    this.variableNames = ['source'];
                    this.outputShape = null;
                    this.userCode = "\n      uniform ivec2 sourceStart;\n      uniform ivec2 destStart;\n\n      void main() {\n        ivec2 destCoords = getOutputCoords() - destStart;\n        int index = destCoords.x * " + destNumCols + " + destCoords.y;\n        int r = index / " + srcNumCols + ";\n        ivec2 sourceCoords = sourceStart + ivec2(r, index - r * " + srcNumCols + ");\n        setOutput(getSource(sourceCoords.x, sourceCoords.y));\n      }\n    ";
                }

                Copy2DProgram.prototype.getCustomSetupFunc = function (sourceStart, destStart, destSize) {
                    return function (gpgpu, webGLProgram) {
                        gpgpu.setOutputMatrixWriteRegion(destStart[0], destSize[0], destStart[1], destSize[1]);
                        var sourceStartCRLoc = gpgpu.getUniformLocation(webGLProgram, 'sourceStart');
                        gpgpu.gl.uniform2i(sourceStartCRLoc, sourceStart[0], sourceStart[1]);
                        var destStartCRLoc = gpgpu.getUniformLocation(webGLProgram, 'destStart');
                        gpgpu.gl.uniform2i(destStartCRLoc, destStart[0], destStart[1]);
                    };
                };
                return Copy2DProgram;
            }());
            exports.Copy2DProgram = Copy2DProgram;

        }, {}],
        71: [function (require, module, exports) {
            "use strict";
            var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) {
                        try {
                            step(generator.next(value));
                        } catch (e) {
                            reject(e);
                        }
                    }

                    function rejected(value) {
                        try {
                            step(generator["throw"](value));
                        } catch (e) {
                            reject(e);
                        }
                    }

                    function step(result) {
                        result.done ? resolve(result.value) : new P(function (resolve) {
                            resolve(result.value);
                        }).then(fulfilled, rejected);
                    }

                    step((generator = generator.apply(thisArg, _arguments || [])).next());
                });
            };
            var __generator = (this && this.__generator) || function (thisArg, body) {
                var _ = {
                    label: 0, sent: function () {
                        if (t[0] & 1) throw t[1];
                        return t[1];
                    }, trys: [], ops: []
                }, f, y, t, g;
                return g = {
                    next: verb(0),
                    "throw": verb(1),
                    "return": verb(2)
                }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
                    return this;
                }), g;

                function verb(n) {
                    return function (v) {
                        return step([n, v]);
                    };
                }

                function step(op) {
                    if (f) throw new TypeError("Generator is already executing.");
                    while (_) try {
                        if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                        if (y = 0, t) op = [0, t.value];
                        switch (op[0]) {
                            case 0:
                            case 1:
                                t = op;
                                break;
                            case 4:
                                _.label++;
                                return {value: op[1], done: false};
                            case 5:
                                _.label++;
                                y = op[1];
                                op = [0];
                                continue;
                            case 7:
                                op = _.ops.pop();
                                _.trys.pop();
                                continue;
                            default:
                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                    _ = 0;
                                    continue;
                                }
                                if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                    _.label = op[1];
                                    break;
                                }
                                if (op[0] === 6 && _.label < t[1]) {
                                    _.label = t[1];
                                    t = op;
                                    break;
                                }
                                if (t && _.label < t[2]) {
                                    _.label = t[2];
                                    _.ops.push(op);
                                    break;
                                }
                                if (t[2]) _.ops.pop();
                                _.trys.pop();
                                continue;
                        }
                        op = body.call(thisArg, _);
                    } catch (e) {
                        op = [6, e];
                        y = 0;
                    } finally {
                        f = t = 0;
                    }
                    if (op[0] & 5) throw op[1];
                    return {value: op[0] ? op[1] : void 0, done: true};
                }
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var environment_1 = require("../../../environment");
            var util = require("../../../util");
            var gpgpu_util = require("./gpgpu_util");
            var tex_util = require("./tex_util");
            var webgl_util = require("./webgl_util");
            var GPGPUContext = (function () {
                function GPGPUContext(gl) {
                    this.outputTexture = null;
                    this.program = null;
                    this.disposed = false;
                    this.autoDebugValidate = false;
                    if (gl != null) {
                        this.gl = gl;
                    } else {
                        this.gl = gpgpu_util.createWebGLContext();
                    }
                    if (environment_1.ENV.get('WEBGL_VERSION') === 1) {
                        this.textureFloatExtension =
                            webgl_util.getExtensionOrThrow(this.gl, 'OES_texture_float');
                        this.colorBufferFloatExtension =
                            this.gl.getExtension('WEBGL_color_buffer_float');
                    } else {
                        this.colorBufferFloatExtension =
                            webgl_util.getExtensionOrThrow(this.gl, 'EXT_color_buffer_float');
                    }
                    this.loseContextExtension =
                        webgl_util.getExtensionOrThrow(this.gl, 'WEBGL_lose_context');
                    if (environment_1.ENV.get('WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED')) {
                        this.getBufferSubDataAsyncExtension =
                            this.gl.getExtension('WEBGL_get_buffer_sub_data_async');
                    }
                    this.vertexBuffer = gpgpu_util.createVertexBuffer(this.gl);
                    this.indexBuffer = gpgpu_util.createIndexBuffer(this.gl);
                    this.framebuffer = webgl_util.createFramebuffer(this.gl);
                }

                GPGPUContext.prototype.dispose = function () {
                    var _this = this;
                    this.throwIfDisposed();
                    if (this.program != null) {
                        console.warn('Disposing a GPGPUContext that still has a bound WebGLProgram.' +
                            ' This is probably a resource leak, delete the program with ' +
                            'GPGPUContext.deleteProgram before disposing.');
                    }
                    if (this.outputTexture != null) {
                        console.warn('Disposing a GPGPUContext that still has a bound output matrix ' +
                            'texture.  This is probably a resource leak, delete the output ' +
                            'matrix texture with GPGPUContext.deleteMatrixTexture before ' +
                            'disposing.');
                    }
                    var gl = this.gl;
                    webgl_util.callAndCheck(gl, function () {
                        return gl.finish();
                    });
                    webgl_util.callAndCheck(gl, function () {
                        return gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                    });
                    webgl_util.callAndCheck(gl, function () {
                        return gl.deleteFramebuffer(_this.framebuffer);
                    });
                    webgl_util.callAndCheck(gl, function () {
                        return gl.bindBuffer(gl.ARRAY_BUFFER, null);
                    });
                    webgl_util.callAndCheck(gl, function () {
                        return gl.deleteBuffer(_this.vertexBuffer);
                    });
                    webgl_util.callAndCheck(gl, function () {
                        return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                    });
                    webgl_util.callAndCheck(gl, function () {
                        return gl.deleteBuffer(_this.indexBuffer);
                    });
                    this.loseContextExtension.loseContext();
                    this.disposed = true;
                };
                GPGPUContext.prototype.enableAutomaticDebugValidation = function (enabled) {
                    this.autoDebugValidate = enabled;
                    webgl_util.enableDebugWebGLErrorChecking(enabled);
                };
                GPGPUContext.prototype.createMatrixTexture = function (rows, columns) {
                    this.throwIfDisposed();
                    return gpgpu_util.createMatrixTexture(this.gl, rows, columns);
                };
                GPGPUContext.prototype.uploadPixelDataToTexture = function (texture, pixels) {
                    this.throwIfDisposed();
                    gpgpu_util.uploadPixelDataToTexture(this.gl, texture, pixels);
                };
                GPGPUContext.prototype.createPackedMatrixTexture = function (rows, columns) {
                    this.throwIfDisposed();
                    return gpgpu_util.createPackedMatrixTexture(this.gl, rows, columns);
                };
                GPGPUContext.prototype.deleteMatrixTexture = function (texture) {
                    var _this = this;
                    this.throwIfDisposed();
                    if (this.outputTexture === texture) {
                        webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);
                        this.outputTexture = null;
                    }
                    webgl_util.callAndCheck(this.gl, function () {
                        return _this.gl.deleteTexture(texture);
                    });
                };
                GPGPUContext.prototype.uploadMatrixToTexture = function (texture, rows, columns, matrix) {
                    this.throwIfDisposed();
                    var numChannels = 1;
                    return gpgpu_util.uploadMatrixToTexture(this.gl, texture, rows, columns, matrix, numChannels);
                };
                GPGPUContext.prototype.uploadMatrixToPackedTexture = function (texture, rows, columns, matrix) {
                    this.throwIfDisposed();
                    return gpgpu_util.uploadMatrixToPackedTexture(this.gl, texture, rows, columns, matrix);
                };
                GPGPUContext.prototype.downloadMatrixFromTexture = function (texture, rows, columns) {
                    var _this = this;
                    return this.downloadMatrixDriver(texture, function () {
                        return gpgpu_util.downloadMatrixFromOutputTexture(_this.gl, rows, columns);
                    });
                };
                GPGPUContext.prototype.downloadMatrixFromTextureAsync = function (texture, rows, columns) {
                    return __awaiter(this, void 0, void 0, function () {
                        var _this = this;
                        return __generator(this, function (_a) {
                            if (this.getBufferSubDataAsyncExtension == null) {
                                throw new Error("Cannot download matrix from output texture asynchronously, " +
                                    "WEBGL_get_buffer_sub_data_async is not enabled.");
                            }
                            return [2, this.downloadMatrixDriverAsync(texture, function () {
                                return gpgpu_util.downloadMatrixFromOutputTextureAsync(_this.gl, _this.getBufferSubDataAsyncExtension, rows, columns);
                            })];
                        });
                    });
                };
                GPGPUContext.prototype.downloadMatrixFromRGBAColorTexture = function (texture, rows, columns, channels) {
                    var _this = this;
                    return this.downloadMatrixDriver(texture, function () {
                        return gpgpu_util.downloadMatrixFromRGBAColorTexture(_this.gl, rows, columns, channels);
                    });
                };
                GPGPUContext.prototype.downloadMatrixFromPackedTexture = function (texture, rows, columns) {
                    var _this = this;
                    return this.downloadMatrixDriver(texture, function () {
                        return gpgpu_util.downloadMatrixFromPackedOutputTexture(_this.gl, rows, columns);
                    });
                };
                GPGPUContext.prototype.createProgram = function (fragmentShaderSource) {
                    this.throwIfDisposed();
                    var gl = this.gl;
                    var fragmentShader = webgl_util.createFragmentShader(gl, fragmentShaderSource);
                    var vertexShader = gpgpu_util.createVertexShader(gl);
                    var program = webgl_util.createProgram(gl);
                    webgl_util.callAndCheck(gl, function () {
                        return gl.attachShader(program, vertexShader);
                    });
                    webgl_util.callAndCheck(gl, function () {
                        return gl.attachShader(program, fragmentShader);
                    });
                    webgl_util.linkProgram(gl, program);
                    if (this.autoDebugValidate) {
                        webgl_util.validateProgram(gl, program);
                    }
                    return program;
                };
                GPGPUContext.prototype.deleteProgram = function (program) {
                    var _this = this;
                    this.throwIfDisposed();
                    if (program === this.program) {
                        this.program = null;
                    }
                    if (program != null) {
                        webgl_util.callAndCheck(this.gl, function () {
                            return _this.gl.deleteProgram(program);
                        });
                    }
                };
                GPGPUContext.prototype.setProgram = function (program) {
                    var _this = this;
                    this.throwIfDisposed();
                    this.program = program;
                    if ((this.program != null) && this.autoDebugValidate) {
                        webgl_util.validateProgram(this.gl, this.program);
                    }
                    webgl_util.callAndCheck(this.gl, function () {
                        return _this.gl.useProgram(program);
                    });
                };
                GPGPUContext.prototype.getUniformLocation = function (program, uniformName) {
                    this.throwIfDisposed();
                    return webgl_util.getProgramUniformLocationOrThrow(this.gl, program, uniformName);
                };
                GPGPUContext.prototype.getAttributeLocation = function (program, attribute) {
                    var _this = this;
                    this.throwIfDisposed();
                    return webgl_util.callAndCheck(this.gl, function () {
                        return _this.gl.getAttribLocation(program, attribute);
                    });
                };
                GPGPUContext.prototype.getUniformLocationNoThrow = function (program, uniformName) {
                    this.throwIfDisposed();
                    return this.gl.getUniformLocation(program, uniformName);
                };
                GPGPUContext.prototype.setInputMatrixTexture = function (inputMatrixTexture, uniformLocation, textureUnit) {
                    this.throwIfDisposed();
                    this.throwIfNoProgram();
                    webgl_util.bindTextureToProgramUniformSampler(this.gl, this.program, inputMatrixTexture, uniformLocation, textureUnit);
                };
                GPGPUContext.prototype.setOutputMatrixTexture = function (outputMatrixTexture, rows, columns) {
                    this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows);
                };
                GPGPUContext.prototype.setOutputPackedMatrixTexture = function (outputPackedMatrixTexture, rows, columns) {
                    this.throwIfDisposed();
                    var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0],
                        height = _a[1];
                    this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height);
                };
                GPGPUContext.prototype.setOutputMatrixWriteRegion = function (startRow, numRows, startColumn, numColumns) {
                    this.setOutputMatrixWriteRegionDriver(startColumn, startRow, numColumns, numRows);
                };
                GPGPUContext.prototype.setOutputPackedMatrixWriteRegion = function (startRow, numRows, startColumn, numColumns) {
                    throw new Error('setOutputPackedMatrixWriteRegion not implemented.');
                };
                GPGPUContext.prototype.debugValidate = function () {
                    if (this.program != null) {
                        webgl_util.validateProgram(this.gl, this.program);
                    }
                    webgl_util.validateFramebuffer(this.gl);
                };
                GPGPUContext.prototype.executeProgram = function (attribLocations) {
                    this.throwIfDisposed();
                    this.throwIfNoProgram();
                    var gl = this.gl;
                    gpgpu_util.bindVertexProgramAttributeStreams(gl, this.program, this.vertexBuffer, attribLocations);
                    if (this.autoDebugValidate) {
                        this.debugValidate();
                    }
                    webgl_util.callAndCheck(gl, function () {
                        return gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
                    });
                };
                GPGPUContext.prototype.blockUntilAllProgramsCompleted = function () {
                    var _this = this;
                    this.throwIfDisposed();
                    webgl_util.callAndCheck(this.gl, function () {
                        return _this.gl.finish();
                    });
                };
                GPGPUContext.prototype.runQuery = function (queryFn) {
                    if (environment_1.ENV.get('WEBGL_VERSION') === 2) {
                        return this.runQueryWebGL2(queryFn);
                    }
                    return this.runQueryWebGL1(queryFn);
                };
                GPGPUContext.prototype.runQueryWebGL2 = function (benchmark) {
                    var _this = this;
                    var ext = webgl_util.getExtensionOrThrow(this.gl, 'EXT_disjoint_timer_query_webgl2');
                    var query = this.gl.createQuery();
                    this.gl.beginQuery(ext.TIME_ELAPSED_EXT, query);
                    benchmark();
                    this.gl.endQuery(ext.TIME_ELAPSED_EXT);
                    return new Promise(function (resolve, reject) {
                        var queryGPU = function () {
                            var available = _this.gl
                                .getQueryParameter(query, _this.gl.QUERY_RESULT_AVAILABLE);
                            var disjoint = _this.gl.getParameter(ext.GPU_DISJOINT_EXT);
                            return available && !disjoint;
                        };
                        var getTimeElapsed = function () {
                            var timeElapsedNanos = _this.gl
                                .getQueryParameter(query, _this.gl.QUERY_RESULT);
                            resolve(timeElapsedNanos / 1000000);
                        };
                        var resolveWithWarning = function () {
                            console.warn('Disjoint query timer never available.');
                            resolve(-1);
                        };
                        util.repeatedTry(queryGPU).then(getTimeElapsed).catch(resolveWithWarning);
                    });
                };
                GPGPUContext.prototype.runQueryWebGL1 = function (benchmark) {
                    var _this = this;
                    var ext = webgl_util.getExtensionOrThrow(this.gl, 'EXT_disjoint_timer_query');
                    var query = ext.createQueryEXT();
                    ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);
                    benchmark();
                    ext.endQueryEXT(ext.TIME_ELAPSED_EXT);
                    return new Promise(function (resolve, reject) {
                        var queryGPU = function () {
                            var available = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);
                            var disjoint = _this.gl.getParameter(ext.GPU_DISJOINT_EXT);
                            return available && !disjoint;
                        };
                        var getTimeElapsed = function () {
                            var timeElapsedNanos = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT);
                            resolve(timeElapsedNanos / 1000000);
                        };
                        var resolveWithWarning = function () {
                            console.warn('Disjoint query timer never available.');
                            resolve(-1);
                        };
                        util.repeatedTry(queryGPU).then(getTimeElapsed).catch(resolveWithWarning);
                    });
                };
                GPGPUContext.prototype.downloadMatrixDriverSetup = function (texture) {
                    this.throwIfDisposed();
                    webgl_util.bindColorTextureToFramebuffer(this.gl, texture, this.framebuffer);
                    if (this.autoDebugValidate) {
                        webgl_util.validateFramebuffer(this.gl);
                    }
                };
                GPGPUContext.prototype.downloadMatrixDriverTeardown = function () {
                    if (this.outputTexture != null) {
                        webgl_util.bindColorTextureToFramebuffer(this.gl, this.outputTexture, this.framebuffer);
                        if (this.autoDebugValidate) {
                            webgl_util.validateFramebuffer(this.gl);
                        }
                    } else {
                        webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);
                    }
                };
                GPGPUContext.prototype.downloadMatrixDriver = function (texture, downloadAndDecode) {
                    this.downloadMatrixDriverSetup(texture);
                    var result = downloadAndDecode();
                    this.downloadMatrixDriverTeardown();
                    return result;
                };
                GPGPUContext.prototype.downloadMatrixDriverAsync = function (texture, downloadAndDecode) {
                    return __awaiter(this, void 0, void 0, function () {
                        var result;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    this.downloadMatrixDriverSetup(texture);
                                    return [4, downloadAndDecode()];
                                case 1:
                                    result = _a.sent();
                                    this.downloadMatrixDriverTeardown();
                                    return [2, result];
                            }
                        });
                    });
                };
                GPGPUContext.prototype.setOutputMatrixTextureDriver = function (outputMatrixTextureMaybePacked, width, height) {
                    this.throwIfDisposed();
                    var gl = this.gl;
                    webgl_util.bindColorTextureToFramebuffer(gl, outputMatrixTextureMaybePacked, this.framebuffer);
                    if (this.autoDebugValidate) {
                        webgl_util.validateFramebuffer(gl);
                    }
                    this.outputTexture = outputMatrixTextureMaybePacked;
                    webgl_util.callAndCheck(gl, function () {
                        return gl.viewport(0, 0, width, height);
                    });
                    webgl_util.callAndCheck(gl, function () {
                        return gl.scissor(0, 0, width, height);
                    });
                };
                GPGPUContext.prototype.setOutputMatrixWriteRegionDriver = function (x, y, width, height) {
                    var _this = this;
                    this.throwIfDisposed();
                    webgl_util.callAndCheck(this.gl, function () {
                        return _this.gl.scissor(x, y, width, height);
                    });
                };
                GPGPUContext.prototype.throwIfDisposed = function () {
                    if (this.disposed) {
                        throw new Error('Attempted to use disposed GPGPUContext.');
                    }
                };
                GPGPUContext.prototype.throwIfNoProgram = function () {
                    if (this.program == null) {
                        throw new Error('No GPU program is currently set.');
                    }
                };
                return GPGPUContext;
            }());
            exports.GPGPUContext = GPGPUContext;

        }, {
            "../../../environment": 15,
            "../../../util": 101,
            "./gpgpu_util": 73,
            "./tex_util": 84,
            "./webgl_util": 89
        }],
        72: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var environment_1 = require("../../../environment");
            var util = require("../../../util");
            var shader_compiler = require("./shader_compiler");
            var ATTRIBUTE_NAMES = ['uv', 'clipSpacePos'];
            var NAN_UNIFORM_NAME = 'NaN';

            function shouldUploadNaNUniform() {
                return !environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED');
            }

            function compileProgram(gpgpu, program, inputs, output) {
                var userCode = program.userCode;
                var inputInfos = inputs.map(function (input, i) {
                    var shapeInfo = {
                        logicalShape: input.array.shape,
                        texShape: input.texData.texShape,
                        textureType: input.texData.textureType
                    };
                    return {name: program.variableNames[i], shapeInfo: shapeInfo};
                });
                var inShapeInfos = inputInfos.map(function (x) {
                    return x.shapeInfo;
                });
                var outShapeInfo = {
                    logicalShape: output.array.shape,
                    texShape: output.texData.texShape,
                    textureType: output.texData.textureType
                };
                var source = shader_compiler.makeShader(inputInfos, outShapeInfo, userCode, program.supportsBroadcasting === true);
                var webGLProgram = gpgpu.createProgram(source);
                var uniformLocations = {};
                for (var i = 0; i < program.variableNames.length; i++) {
                    var uniformName = program.variableNames[i];
                    uniformLocations[uniformName] =
                        gpgpu.getUniformLocation(webGLProgram, uniformName);
                }
                var attributeLocations = {};
                ATTRIBUTE_NAMES.forEach(function (attribute) {
                    attributeLocations[attribute] =
                        gpgpu.getAttributeLocation(webGLProgram, attribute);
                });
                if (shouldUploadNaNUniform()) {
                    uniformLocations[NAN_UNIFORM_NAME] =
                        gpgpu.getUniformLocation(webGLProgram, NAN_UNIFORM_NAME);
                }
                return {
                    program: program,
                    source: source,
                    webGLProgram: webGLProgram,
                    uniformLocations: uniformLocations,
                    attributeLocations: attributeLocations,
                    gpgpu: gpgpu,
                    inShapeInfos: inShapeInfos,
                    outShapeInfo: outShapeInfo
                };
            }

            exports.compileProgram = compileProgram;

            function validateBinaryAndProgram(shapeInfos, inputs) {
                if (shapeInfos.length !== inputs.length) {
                    throw Error("Binary was compiled with " + shapeInfos.length + " inputs, but " +
                        ("was executed with " + inputs.length + " inputs"));
                }
                shapeInfos.forEach(function (s, i) {
                    var shapeA = s.logicalShape;
                    var texShapeA = s.texShape;
                    var shapeB = inputs[i].array.shape;
                    var texShapeB = inputs[i].texData.texShape;
                    if (!util.arraysEqual(shapeA, shapeB)) {
                        throw Error("Binary was compiled with different shapes than " +
                            ("the current args. Shapes " + shapeA + " and " + shapeB + " must match"));
                    }
                    if (!util.arraysEqual(texShapeA, texShapeB)) {
                        throw Error("Binary was compiled with different texture shapes than the" +
                            (" current args. Shape " + texShapeA + " and " + texShapeB + " must match"));
                    }
                });
            }

            function runProgram(binary, inputs, output, customSetup) {
                validateBinaryAndProgram(binary.inShapeInfos, inputs);
                validateBinaryAndProgram([binary.outShapeInfo], [output]);
                var outTex = output.texData.texture;
                var outTexShape = output.texData.texShape;
                var gpgpu = binary.gpgpu;
                gpgpu.setOutputMatrixTexture(outTex, outTexShape[0], outTexShape[1]);
                gpgpu.setProgram(binary.webGLProgram);
                inputs.forEach(function (input, i) {
                    var tex = input.texData.texture;
                    var variableName = binary.program.variableNames[i];
                    var variableUniformLocation = binary.uniformLocations[variableName];
                    gpgpu.setInputMatrixTexture(tex, variableUniformLocation, i);
                });
                if (shouldUploadNaNUniform()) {
                    gpgpu.gl.uniform1f(binary.uniformLocations[NAN_UNIFORM_NAME], NaN);
                }
                if (customSetup != null) {
                    customSetup(gpgpu, binary.webGLProgram);
                }
                gpgpu.executeProgram(binary.attributeLocations);
            }

            exports.runProgram = runProgram;

            function makeShaderKey(program, inputs, output) {
                var keyInputs = '';
                inputs.concat(output).forEach(function (x) {
                    keyInputs += x.array.shape + "_" + x.texData.texShape;
                });
                var keyUserCode = program.userCode;
                var keyBroadcast = (program.supportsBroadcasting === true).toString();
                var key = program.constructor.name;
                key += '_' + keyBroadcast + '_' + keyInputs + '_' + keyUserCode;
                return key;
            }

            exports.makeShaderKey = makeShaderKey;

        }, {"../../../environment": 15, "../../../util": 101, "./shader_compiler": 82}],
        73: [function (require, module, exports) {
            "use strict";
            var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) {
                        try {
                            step(generator.next(value));
                        } catch (e) {
                            reject(e);
                        }
                    }

                    function rejected(value) {
                        try {
                            step(generator["throw"](value));
                        } catch (e) {
                            reject(e);
                        }
                    }

                    function step(result) {
                        result.done ? resolve(result.value) : new P(function (resolve) {
                            resolve(result.value);
                        }).then(fulfilled, rejected);
                    }

                    step((generator = generator.apply(thisArg, _arguments || [])).next());
                });
            };
            var __generator = (this && this.__generator) || function (thisArg, body) {
                var _ = {
                    label: 0, sent: function () {
                        if (t[0] & 1) throw t[1];
                        return t[1];
                    }, trys: [], ops: []
                }, f, y, t, g;
                return g = {
                    next: verb(0),
                    "throw": verb(1),
                    "return": verb(2)
                }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
                    return this;
                }), g;

                function verb(n) {
                    return function (v) {
                        return step([n, v]);
                    };
                }

                function step(op) {
                    if (f) throw new TypeError("Generator is already executing.");
                    while (_) try {
                        if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                        if (y = 0, t) op = [0, t.value];
                        switch (op[0]) {
                            case 0:
                            case 1:
                                t = op;
                                break;
                            case 4:
                                _.label++;
                                return {value: op[1], done: false};
                            case 5:
                                _.label++;
                                y = op[1];
                                op = [0];
                                continue;
                            case 7:
                                op = _.ops.pop();
                                _.trys.pop();
                                continue;
                            default:
                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                    _ = 0;
                                    continue;
                                }
                                if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                    _.label = op[1];
                                    break;
                                }
                                if (op[0] === 6 && _.label < t[1]) {
                                    _.label = t[1];
                                    t = op;
                                    break;
                                }
                                if (t && _.label < t[2]) {
                                    _.label = t[2];
                                    _.ops.push(op);
                                    break;
                                }
                                if (t[2]) _.ops.pop();
                                _.trys.pop();
                                continue;
                        }
                        op = body.call(thisArg, _);
                    } catch (e) {
                        op = [6, e];
                        y = 0;
                    } finally {
                        f = t = 0;
                    }
                    if (op[0] & 5) throw op[1];
                    return {value: op[0] ? op[1] : void 0, done: true};
                }
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var environment_1 = require("../../../environment");
            var tex_util = require("./tex_util");
            var webgl_util = require("./webgl_util");

            function getWebGLContextAttributes() {
                return {
                    alpha: false,
                    antialias: false,
                    premultipliedAlpha: false,
                    preserveDrawingBuffer: false,
                    depth: false,
                    stencil: false,
                    failIfMajorPerformanceCaveat: true
                };
            }

            exports.getWebGLContextAttributes = getWebGLContextAttributes;

            function createWebGLContext(canvas) {
                var attributes = getWebGLContextAttributes();
                var gl;
                if (canvas != null) {
                    gl = webgl_util.createWebGLRenderingContextFromCanvas(canvas, attributes);
                } else {
                    gl = webgl_util.createWebGLRenderingContext(attributes);
                }
                webgl_util.callAndCheck(gl, function () {
                    return gl.disable(gl.DEPTH_TEST);
                });
                webgl_util.callAndCheck(gl, function () {
                    return gl.disable(gl.STENCIL_TEST);
                });
                webgl_util.callAndCheck(gl, function () {
                    return gl.disable(gl.BLEND);
                });
                webgl_util.callAndCheck(gl, function () {
                    return gl.disable(gl.DITHER);
                });
                webgl_util.callAndCheck(gl, function () {
                    return gl.disable(gl.POLYGON_OFFSET_FILL);
                });
                webgl_util.callAndCheck(gl, function () {
                    return gl.disable(gl.SAMPLE_COVERAGE);
                });
                webgl_util.callAndCheck(gl, function () {
                    return gl.enable(gl.SCISSOR_TEST);
                });
                webgl_util.callAndCheck(gl, function () {
                    return gl.enable(gl.CULL_FACE);
                });
                webgl_util.callAndCheck(gl, function () {
                    return gl.cullFace(gl.BACK);
                });
                return gl;
            }

            exports.createWebGLContext = createWebGLContext;

            function createVertexShader(gl) {
                var vertexShaderSource = "\n    precision highp float;\n    attribute vec3 clipSpacePos;\n    attribute vec2 uv;\n    varying vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }";
                return webgl_util.createVertexShader(gl, vertexShaderSource);
            }

            exports.createVertexShader = createVertexShader;

            function createVertexBuffer(gl) {
                var vertexArray = new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);
                return webgl_util.createStaticVertexBuffer(gl, vertexArray);
            }

            exports.createVertexBuffer = createVertexBuffer;

            function createIndexBuffer(gl) {
                var triangleVertexIndices = new Uint16Array([0, 1, 2, 2, 1, 3]);
                return webgl_util.createStaticIndexBuffer(gl, triangleVertexIndices);
            }

            exports.createIndexBuffer = createIndexBuffer;

            function getTextureInternalFormat(gl, numChannels) {
                if (!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {
                    return gl.RGBA;
                }
                if (environment_1.ENV.get('WEBGL_VERSION') === 2) {
                    if (numChannels === 4) {
                        return gl.RGBA32F;
                    }
                    return gl.R32F;
                }
                return gl.RGBA;
            }

            function getTextureFormat(gl, numChannels) {
                if (!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {
                    return gl.RGBA;
                }
                if (environment_1.ENV.get('WEBGL_VERSION') === 2) {
                    if (numChannels === 4) {
                        return gl.RGBA;
                    }
                    return gl.RED;
                }
                return gl.RGBA;
            }

            function getTextureType(gl) {
                if (!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {
                    return gl.UNSIGNED_BYTE;
                }
                return gl.FLOAT;
            }

            function createAndConfigureTexture(gl, width, height, numChannels) {
                webgl_util.validateTextureSize(gl, width, height);
                var texture = webgl_util.createTexture(gl);
                var tex2d = gl.TEXTURE_2D;
                var internalFormat = getTextureInternalFormat(gl, numChannels);
                var format = getTextureFormat(gl, numChannels);
                webgl_util.callAndCheck(gl, function () {
                    return gl.bindTexture(tex2d, texture);
                });
                webgl_util.callAndCheck(gl, function () {
                    return gl.texParameteri(tex2d, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                });
                webgl_util.callAndCheck(gl, function () {
                    return gl.texParameteri(tex2d, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                });
                webgl_util.callAndCheck(gl, function () {
                    return gl.texParameteri(tex2d, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                });
                webgl_util.callAndCheck(gl, function () {
                    return gl.texParameteri(tex2d, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                });
                webgl_util.callAndCheck(gl, function () {
                    return gl.texImage2D(tex2d, 0, internalFormat, width, height, 0, format, getTextureType(gl), null);
                });
                webgl_util.callAndCheck(gl, function () {
                    return gl.bindTexture(gl.TEXTURE_2D, null);
                });
                return texture;
            }

            function createMatrixTexture(gl, rows, columns) {
                var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0],
                    height = _a[1];
                var numChannels = 1;
                return createAndConfigureTexture(gl, width, height, numChannels);
            }

            exports.createMatrixTexture = createMatrixTexture;

            function createColorMatrixTexture(gl, rows, columns) {
                var _a = tex_util.getColorMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
                var numChannels = 4;
                return createAndConfigureTexture(gl, width, height, numChannels);
            }

            exports.createColorMatrixTexture = createColorMatrixTexture;

            function createPackedMatrixTexture(gl, rows, columns) {
                var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
                var numChannels = 4;
                return createAndConfigureTexture(gl, width, height, numChannels);
            }

            exports.createPackedMatrixTexture = createPackedMatrixTexture;

            function bindVertexProgramAttributeStreams(gl, program, vertexBuffer, attribLocations) {
                var posOffset = 0;
                var uvOffset = 3 * 4;
                var stride = (3 * 4) + (2 * 4);
                webgl_util.callAndCheck(gl, function () {
                    return gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                });
                webgl_util.bindVertexBufferToProgramAttribute(gl, program, 'clipSpacePos', vertexBuffer, 3, stride, posOffset, attribLocations);
                webgl_util.bindVertexBufferToProgramAttribute(gl, program, 'uv', vertexBuffer, 2, stride, uvOffset, attribLocations);
            }

            exports.bindVertexProgramAttributeStreams = bindVertexProgramAttributeStreams;

            function uploadPixelDataToTexture(gl, texture, pixels) {
                webgl_util.callAndCheck(gl, function () {
                    return gl.bindTexture(gl.TEXTURE_2D, texture);
                });
                webgl_util.callAndCheck(gl, function () {
                    return gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
                });
                webgl_util.callAndCheck(gl, function () {
                    return gl.bindTexture(gl.TEXTURE_2D, null);
                });
            }

            exports.uploadPixelDataToTexture = uploadPixelDataToTexture;

            function uploadDataToTexture(gl, texture, width, height, data, numChannels) {
                var textureFormat = getTextureFormat(gl, numChannels);
                webgl_util.validateTextureSize(gl, width, height);
                webgl_util.callAndCheck(gl, function () {
                    return gl.bindTexture(gl.TEXTURE_2D, texture);
                });
                webgl_util.callAndCheck(gl, function () {
                    return gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, textureFormat, getTextureType(gl), data);
                });
                webgl_util.callAndCheck(gl, function () {
                    return gl.bindTexture(gl.TEXTURE_2D, null);
                });
            }

            function uploadMatrixToTexture(gl, texture, rows, columns, matrix, numChannels) {
                var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
                var unpackedArray;
                if (environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {
                    var channelsPerTexture = numChannels === 1 ? webgl_util.getChannelsPerTexture() : numChannels;
                    if (channelsPerTexture === 1) {
                        unpackedArray = matrix;
                    } else {
                        unpackedArray =
                            new Float32Array(tex_util.getUnpackedArraySizeFromMatrixSize(matrix.length, channelsPerTexture));
                        tex_util.encodeMatrixToUnpackedArray(matrix, unpackedArray, channelsPerTexture);
                    }
                } else {
                    unpackedArray = tex_util.encodeFloatArray(matrix);
                }
                uploadDataToTexture(gl, texture, w, h, unpackedArray, numChannels);
            }

            exports.uploadMatrixToTexture = uploadMatrixToTexture;

            function uploadMatrixToPackedTexture(gl, texture, rows, columns, matrix) {
                var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
                var packedRGBA = new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(rows, columns));
                tex_util.encodeMatrixToPackedRGBA(matrix, rows, columns, packedRGBA);
                var numChannels = 4;
                uploadDataToTexture(gl, texture, w, h, packedRGBA, numChannels);
            }

            exports.uploadMatrixToPackedTexture = uploadMatrixToPackedTexture;

            function getDownloadTargetArrayBuffer(rows, columns, channelsPerTexture) {
                var isFloatTexture = environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED');
                var downloadTarget;
                if (isFloatTexture) {
                    downloadTarget =
                        new Float32Array(tex_util.getUnpackedArraySizeFromMatrixSize(rows * columns, channelsPerTexture));
                } else {
                    downloadTarget = new Uint8Array(rows * columns * channelsPerTexture);
                }
                return downloadTarget;
            }

            function decodeDownloadTargetArrayBuffer(downloadTarget, rows, columns, channelsPerPixel) {
                var isFloatTexture = environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED');
                if (isFloatTexture) {
                    var matrix = new Float32Array(rows * columns);
                    tex_util.decodeMatrixFromUnpackedArray(downloadTarget, matrix, channelsPerPixel);
                    return matrix;
                } else {
                    return tex_util.decodeToFloatArray(downloadTarget);
                }
            }

            function downloadMatrixFromOutputTextureAsync(gl, getBufferSubDataAsyncExtension, rows, columns) {
                return __awaiter(this, void 0, void 0, function () {
                    var gl2, channelsPerPixel, downloadTarget, bufferSizeBytes, buffer;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                gl2 = gl;
                                channelsPerPixel = 4;
                                downloadTarget = getDownloadTargetArrayBuffer(rows, columns, channelsPerPixel);
                                bufferSizeBytes = downloadTarget instanceof Float32Array ?
                                    downloadTarget.length * 4 :
                                    downloadTarget;
                                buffer = gl.createBuffer();
                                webgl_util.callAndCheck(gl, function () {
                                    return gl.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer);
                                });
                                webgl_util.callAndCheck(gl, function () {
                                    return gl.bufferData(gl2.PIXEL_PACK_BUFFER, bufferSizeBytes, gl.STATIC_DRAW);
                                });
                                webgl_util.callAndCheck(gl, function () {
                                    return gl2.readPixels(0, 0, columns, rows, gl.RGBA, getTextureType(gl), 0);
                                });
                                return [4, getBufferSubDataAsyncExtension.getBufferSubDataAsync(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget)];
                            case 1:
                                _a.sent();
                                return [2, decodeDownloadTargetArrayBuffer(downloadTarget, rows, columns, channelsPerPixel)];
                        }
                    });
                });
            }

            exports.downloadMatrixFromOutputTextureAsync = downloadMatrixFromOutputTextureAsync;

            function downloadMatrixFromOutputTexture(gl, rows, columns) {
                var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
                var channelsPerPixel = 4;
                var downloadTarget = getDownloadTargetArrayBuffer(rows, columns, channelsPerPixel);
                webgl_util.callAndCheck(gl, function () {
                    return gl.readPixels(0, 0, w, h, gl.RGBA, getTextureType(gl), downloadTarget);
                });
                return decodeDownloadTargetArrayBuffer(downloadTarget, rows, columns, channelsPerPixel);
            }

            exports.downloadMatrixFromOutputTexture = downloadMatrixFromOutputTexture;

            function downloadMatrixFromRGBAColorTexture(gl, rows, columns, channels) {
                var size = rows * columns * 4;
                var downloadTarget = new Uint8Array(size);
                webgl_util.callAndCheck(gl, function () {
                    return gl.readPixels(0, 0, columns, rows, gl.RGBA, gl.UNSIGNED_BYTE, downloadTarget);
                });
                var packedRGBA = new Float32Array(size);
                for (var i = 0; i < downloadTarget.length; i++) {
                    packedRGBA[i] = downloadTarget[i];
                }
                var matrix = new Float32Array(rows * columns * channels);
                tex_util.decodeMatrixFromUnpackedColorRGBAArray(packedRGBA, matrix, channels);
                return matrix;
            }

            exports.downloadMatrixFromRGBAColorTexture = downloadMatrixFromRGBAColorTexture;

            function downloadMatrixFromPackedOutputTexture(gl, rows, columns) {
                var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
                var packedRGBA = new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(rows, columns));
                webgl_util.callAndCheck(gl, function () {
                    return gl.readPixels(0, 0, w, h, gl.RGBA, getTextureType(gl), packedRGBA);
                });
                var matrix = new Float32Array(rows * columns);
                return tex_util.decodeMatrixFromPackedRGBA(packedRGBA, rows, columns, matrix);
            }

            exports.downloadMatrixFromPackedOutputTexture = downloadMatrixFromPackedOutputTexture;

        }, {"../../../environment": 15, "./tex_util": 84, "./webgl_util": 89}],
        74: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var MaxPool2DBackpropProgram = (function () {
                function MaxPool2DBackpropProgram(convInfo) {
                    this.variableNames = ['dy', 'maxPos'];
                    this.outputShape = convInfo.inShape;
                    var filterHeight = convInfo.filterHeight;
                    var filterWidth = convInfo.filterWidth;
                    var strideHeight = convInfo.strideHeight;
                    var strideWidth = convInfo.strideWidth;
                    var padTop = filterHeight - 1 - convInfo.padInfo.top;
                    var padLeft = filterWidth - 1 - convInfo.padInfo.left;
                    var lastIndex = filterHeight * filterWidth - 1;
                    this.userCode = "\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + strideHeight + ".0;\n\n          if (dyR < 0.0 || dyR >= " + convInfo.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + strideWidth + ".0;\n\n            if (dyC < 0.0 || dyC >= " + convInfo.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = " + lastIndex + " - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * " + filterWidth + " + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
                }

                return MaxPool2DBackpropProgram;
            }());
            exports.MaxPool2DBackpropProgram = MaxPool2DBackpropProgram;

        }, {}],
        75: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var matmul_1 = require("../types/matmul");
            var MatMulProgram = (function () {
                function MatMulProgram(aShape, bShape, aOrient, bOrient) {
                    if (aOrient === void 0) {
                        aOrient = matmul_1.MatrixOrientation.REGULAR;
                    }
                    if (bOrient === void 0) {
                        bOrient = matmul_1.MatrixOrientation.REGULAR;
                    }
                    this.variableNames = ['matrixA', 'matrixB'];
                    var outerShapeA = (aOrient === matmul_1.MatrixOrientation.REGULAR) ? aShape[0] : aShape[1];
                    var outerShapeB = (bOrient === matmul_1.MatrixOrientation.REGULAR) ? bShape[1] : bShape[0];
                    this.outputShape = [outerShapeA, outerShapeB];
                    var sharedDim = (aOrient === matmul_1.MatrixOrientation.REGULAR ? aShape[1] : aShape[0]);
                    var aSnippetFromOffset = function (vec4Offset, indexVar) {
                        return (aOrient === matmul_1.MatrixOrientation.REGULAR) ?
                            "aRow, " + indexVar + " + " + vec4Offset :
                            indexVar + " + " + vec4Offset + ", aRow";
                    };
                    var bSnippetFromOffset = function (vec4Offset, indexVar) {
                        return (bOrient === matmul_1.MatrixOrientation.REGULAR) ?
                            indexVar + " + " + vec4Offset + ", bCol" :
                            "bCol, " + indexVar + " + " + vec4Offset;
                    };
                    var sharedDimNearestVec4 = Math.floor(sharedDim / 4) * 4;
                    var sharedDimVec4Remainder = sharedDim % 4;
                    this.userCode = " float dotARowBCol(int aRow, int bCol) {\n      float result = 0.0;\n      for (int i = 0; i < " + sharedDimNearestVec4 + "; i += 4) {\n        vec4 a = vec4(\n          getMatrixA(" + aSnippetFromOffset(0, 'i') + "),\n          getMatrixA(" + aSnippetFromOffset(1, 'i') + "),\n          getMatrixA(" + aSnippetFromOffset(2, 'i') + "),\n          getMatrixA(" + aSnippetFromOffset(3, 'i') + ")\n        );\n        vec4 b = vec4(\n          getMatrixB(" + bSnippetFromOffset(0, 'i') + "),\n          getMatrixB(" + bSnippetFromOffset(1, 'i') + "),\n          getMatrixB(" + bSnippetFromOffset(2, 'i') + "),\n          getMatrixB(" + bSnippetFromOffset(3, 'i') + ")\n        );\n\n        result += dot(a, b);\n      }\n\n      if (" + (sharedDimVec4Remainder === 1) + ") {\n        result += getMatrixA(" + aSnippetFromOffset(0, sharedDimNearestVec4) + ") *\n          getMatrixB(" + bSnippetFromOffset(0, sharedDimNearestVec4) + ");\n      } else if (" + (sharedDimVec4Remainder === 2) + ") {\n        vec2 a = vec2(\n          getMatrixA(" + aSnippetFromOffset(0, sharedDimNearestVec4) + "),\n          getMatrixA(" + aSnippetFromOffset(1, sharedDimNearestVec4) + ")\n        );\n        vec2 b = vec2(\n          getMatrixB(" + bSnippetFromOffset(0, sharedDimNearestVec4) + "),\n          getMatrixB(" + bSnippetFromOffset(1, sharedDimNearestVec4) + ")\n        );\n        result += dot(a, b);\n      } else if (" + (sharedDimVec4Remainder === 3) + ") {\n        vec3 a = vec3(\n          getMatrixA(" + aSnippetFromOffset(0, sharedDimNearestVec4) + "),\n          getMatrixA(" + aSnippetFromOffset(1, sharedDimNearestVec4) + "),\n          getMatrixA(" + aSnippetFromOffset(2, sharedDimNearestVec4) + ")\n        );\n        vec3 b = vec3(\n          getMatrixB(" + bSnippetFromOffset(0, sharedDimNearestVec4) + "),\n          getMatrixB(" + bSnippetFromOffset(1, sharedDimNearestVec4) + "),\n          getMatrixB(" + bSnippetFromOffset(2, sharedDimNearestVec4) + ")\n        );\n        result += dot(a, b);\n      }\n\n      return result;\n    }\n\n    void main() {\n      ivec2 resRC = getOutputCoords();\n      setOutput(dotARowBCol(resRC.x, resRC.y));\n    }\n    ";
                }

                return MatMulProgram;
            }());
            exports.MatMulProgram = MatMulProgram;

        }, {"../types/matmul": 61}],
        76: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var MultinomialProgram = (function () {
                function MultinomialProgram(batchSize, numOutcomes, numSamples) {
                    this.variableNames = ['probs'];
                    this.outputShape = [batchSize, numSamples];
                    this.userCode = "\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < " + (numOutcomes - 1) + "; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(" + (numOutcomes - 1) + "));\n      }\n    ";
                }

                MultinomialProgram.prototype.getCustomSetupFunc = function (seed) {
                    var _this = this;
                    return function (gpgpu, webGLProgram) {
                        if (_this.seedLoc == null) {
                            _this.seedLoc = gpgpu.getUniformLocation(webGLProgram, 'seed');
                        }
                        gpgpu.gl.uniform1f(_this.seedLoc, seed);
                    };
                };
                return MultinomialProgram;
            }());
            exports.MultinomialProgram = MultinomialProgram;

        }, {}],
        77: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var OneHotProgram = (function () {
                function OneHotProgram(numIndices, depth, onValue, offValue) {
                    this.variableNames = ['indices'];
                    this.outputShape = [numIndices, depth];
                    this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(" + offValue + "), float(" + onValue + "),\n                      float(index == coords.y)));\n      }\n    ";
                }

                OneHotProgram.prototype.getCustomSetupFunc = function (seed) {
                    var _this = this;
                    return function (gpgpu, webGLProgram) {
                        if (_this.seedLoc == null) {
                            _this.seedLoc = gpgpu.getUniformLocation(webGLProgram, 'seed');
                        }
                        gpgpu.gl.uniform1f(_this.seedLoc, seed);
                    };
                };
                return OneHotProgram;
            }());
            exports.OneHotProgram = OneHotProgram;

        }, {}],
        78: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var Pool2DProgram = (function () {
                function Pool2DProgram(convInfo, poolType, computePositions) {
                    this.variableNames = ['x'];
                    if (poolType === 'avg' && computePositions) {
                        throw new Error('Cannot compute positions for average pool.');
                    }
                    var filterHeight = convInfo.filterHeight;
                    var filterWidth = convInfo.filterWidth;
                    var strideHeight = convInfo.strideHeight;
                    var strideWidth = convInfo.strideWidth;
                    var padTop = convInfo.padInfo.top;
                    var padLeft = convInfo.padInfo.left;
                    this.outputShape = convInfo.outShape;
                    var isAvgPool = poolType === 'avg';
                    var initializationValue = '0.0';
                    if (!isAvgPool) {
                        if (poolType === 'min') {
                            initializationValue = '1.0 / 0.0';
                        } else {
                            initializationValue = '-1.0 / 0.0';
                        }
                    }
                    if (computePositions) {
                        var compareOp_1 = poolType === 'min' ? '<=' : '>=';
                        this.userCode = "\n        const ivec2 strides = ivec2(" + strideHeight + ", " + strideWidth + ");\n        const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < " + filterHeight + "; wR++) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= " + convInfo.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + filterWidth + "; wC++) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= " + convInfo.inWidth + ") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              if (isNaN(value)) {\n                setOutput(value);\n                return;\n              }\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value " + compareOp_1 + " currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = wR * " + filterWidth + " + wC;\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";
                        return;
                    }
                    var compareOp = poolType === 'min' ? 'min' : 'max';
                    var returnValue = poolType + "(" + poolType + "(" + poolType + "(" +
                        'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';
                    if (poolType === 'avg') {
                        returnValue = "avgValue / " + filterHeight * filterWidth + ".0";
                    }
                    var filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;
                    var filterWidthVec4Remainder = filterWidth % 4;
                    var updateSnippet = "\n      if (hasNaN(values)) {\n        setOutput(getNaN(values));\n        return;\n      }\n      if (" + isAvgPool + ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = " + compareOp + "(values, minMaxValue);\n      }\n    ";
                    this.userCode = "\n      const ivec2 strides = ivec2(" + strideHeight + ", " + strideWidth + ");\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n      const float initializationValue = " + initializationValue + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= " + convInfo.inWidth + ") {\n          return initializationValue;\n        }\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(" + initializationValue + ");\n        float avgValue = 0.0;\n\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= " + convInfo.inHeight + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + filterWidthNearestVec4 + "; wC += 4) {\n            int xC = xCCorner + wC;\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + 1, d),\n              getValue(batch, xR, xC + 2, d),\n              getValue(batch, xR, xC + 3, d)\n            );\n\n            " + updateSnippet + "\n          }\n\n          int xC = xCCorner + " + filterWidthNearestVec4 + ";\n          if (" + (filterWidthVec4Remainder === 1) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n            " + updateSnippet + "\n          } else if (" + (filterWidthVec4Remainder === 2) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + 1, d),\n              initializationValue,\n              initializationValue\n            );\n\n            " + updateSnippet + "\n          } else if (" + (filterWidthVec4Remainder === 3) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + 1, d),\n              getValue(batch, xR, xC + 2, d),\n              initializationValue\n            );\n\n            " + updateSnippet + "\n          }\n        }\n        setOutput(" + returnValue + ");\n      }\n    ";
                }

                return Pool2DProgram;
            }());
            exports.Pool2DProgram = Pool2DProgram;

        }, {}],
        79: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var ReduceProgram = (function () {
                function ReduceProgram(reduceInfo, reduceType) {
                    this.variableNames = ['x'];
                    var windowSize = reduceInfo.windowSize;
                    var batchSize = reduceInfo.batchSize;
                    var inSize = reduceInfo.inSize;
                    var outSize = Math.ceil(inSize / windowSize);
                    this.outputShape = [batchSize, outSize];
                    var isReduceSum = reduceType === 'sum';
                    var initializationValue = '0.0';
                    if (!isReduceSum) {
                        if (reduceType === 'min') {
                            initializationValue = '1.0 / 0.0';
                        } else {
                            initializationValue = '-1.0 / 0.0';
                        }
                    }
                    var compareOp = reduceType === 'min' ? 'min' : 'max';
                    var returnValue = reduceType + "(" + reduceType + "(" + reduceType + "(" +
                        'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';
                    if (reduceType === 'sum') {
                        returnValue = "sumValue";
                    }
                    var windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;
                    var windowSizeVec4Remainder = windowSize % 4;
                    var updateSnippet = "\n      if (" + isReduceSum + ") {\n        sumValue += dot(values, ones);\n      } else {\n        if (hasNaN(values)) {\n          setOutput(getNaN(values));\n          return;\n        }\n        minMaxValue = " + compareOp + "(values, minMaxValue);\n      }\n    ";
                    var checkOutOfBounds = '';
                    if (inSize % windowSize > 0) {
                        checkOutOfBounds = "\n        if (inIdx < 0 || inIdx >= " + inSize + ") {\n          return initializationValue;\n        }\n      ";
                    }
                    this.userCode = "\n      const float initializationValue = " + initializationValue + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        " + checkOutOfBounds + "\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + windowSize + ";\n\n        vec4 minMaxValue = vec4(" + initializationValue + ");\n        float sumValue = 0.0;\n\n        for (int i = 0; i < " + windowSizeNearestVec4 + "; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          " + updateSnippet + "\n        }\n\n        int inIdx = inOffset + " + windowSizeNearestVec4 + ";\n        if (" + (windowSizeVec4Remainder === 1) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n          " + updateSnippet + "\n        } else if (" + (windowSizeVec4Remainder === 2) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n          " + updateSnippet + "\n        } else if (" + (windowSizeVec4Remainder === 3) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n          " + updateSnippet + "\n        }\n        setOutput(" + returnValue + ");\n      }\n    ";
                }

                return ReduceProgram;
            }());
            exports.ReduceProgram = ReduceProgram;

        }, {}],
        80: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var webgl_util = require("./webgl_util");

            function getRenderRGBShader(gpgpu, destinationWidth) {
                var fragmentShaderSource = "\n    precision highp float;\n    uniform sampler2D source;\n    varying vec2 resultUV;\n\n    const float destinationWidth = " + destinationWidth + ".0;\n    const float a = 1.0;\n\n    void main() {\n      float xr = floor(resultUV.s * destinationWidth) * 3.0;\n      vec3 x = xr + vec3(0, 1, 2);\n\n      float sourceWidth = destinationWidth * 3.0;\n      vec3 u = (x + 0.5) / sourceWidth;\n      float v = 1.0 - resultUV.t;\n\n      float r = texture2D(source, vec2(u[0], v)).r;\n      float g = texture2D(source, vec2(u[1], v)).r;\n      float b = texture2D(source, vec2(u[2], v)).r;\n\n      gl_FragColor = vec4(r, g, b, a);\n    }";
                return gpgpu.createProgram(fragmentShaderSource);
            }

            exports.getRenderRGBShader = getRenderRGBShader;

            function renderToCanvas(gpgpu, renderShader, sourceTex) {
                webgl_util.bindCanvasToFramebuffer(gpgpu.gl);
                renderToFramebuffer(gpgpu, renderShader, sourceTex);
            }

            exports.renderToCanvas = renderToCanvas;

            function renderToFramebuffer(gpgpu, renderShader, sourceTex) {
                gpgpu.setProgram(renderShader);
                var sourceSamplerLocation = webgl_util.getProgramUniformLocationOrThrow(gpgpu.gl, renderShader, 'source');
                gpgpu.setInputMatrixTexture(sourceTex, sourceSamplerLocation, 0);
                gpgpu.executeProgram();
            }

            exports.renderToFramebuffer = renderToFramebuffer;

        }, {"./webgl_util": 89}],
        81: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var ResizeBilinear3DProgram = (function () {
                function ResizeBilinear3DProgram(inputShape, outputDimensionsRowCol, alignCorners) {
                    this.variableNames = ['A'];
                    this.outputShape = [];
                    var depth = inputShape[2];
                    this.outputShape =
                        [outputDimensionsRowCol[0], outputDimensionsRowCol[1], depth];
                    var effectiveInputShape = alignCorners ?
                        [inputShape[0] - 1, inputShape[1] - 1, depth] :
                        inputShape;
                    var effectiveOutputShape = alignCorners ?
                        [this.outputShape[0] - 1, this.outputShape[1] - 1, depth] :
                        this.outputShape;
                    this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " + effectiveInputShape[0] / effectiveOutputShape[0] + ",\n          " + effectiveInputShape[1] / effectiveOutputShape[1] + ");\n      const vec2 inputShapeRC = vec2(" + inputShape[0] + ".0, " + inputShape[1] + ".0);\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        ivec2 yRC = coords.xy;\n        int d = coords.z;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ";
                }

                return ResizeBilinear3DProgram;
            }());
            exports.ResizeBilinear3DProgram = ResizeBilinear3DProgram;

        }, {}],
        82: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var environment_1 = require("../../../environment");
            var util = require("../../../util");
            var broadcast_util = require("../../broadcast_util");
            var tex_util = require("./tex_util");
            var tex_util_1 = require("./tex_util");

            function makeShader(inputsInfo, outputShape, userCode, broadcast) {
                var sampleSnippet = getSampleSnippet();
                var setOutputSnippet = getSetOutputSnippet();
                var inputPrefixSnippet = inputsInfo.map(function (x) {
                    return "uniform sampler2D " + x.name + ";";
                }).join('\n');
                var inputSamplingSnippet = inputsInfo.map(function (x) {
                    return getInputSamplingSnippet(x, outputShape, broadcast);
                })
                    .join('\n');
                var outTexShape = outputShape.texShape;
                var outputSamplingSnippet = getOutputSamplingSnippet(outputShape.logicalShape, outTexShape);
                var source = [
                    SHADER_PREFIX, sampleSnippet, setOutputSnippet, inputPrefixSnippet,
                    outputSamplingSnippet, inputSamplingSnippet, userCode
                ].join('\n');
                return source;
            }

            exports.makeShader = makeShader;

            function getSampleSnippet() {
                return environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED') ?
                    FLOAT_TEXTURE_SAMPLE_SNIPPET :
                    UNSIGNED_BYTE_TEXTURE_SAMPLE_SNIPPET;
            }

            function getSetOutputSnippet() {
                return environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED') ?
                    FLOAT_TEXTURE_SETOUTPUT_SNIPPET :
                    UNSIGNED_BYTE_TEXTURE_SETOUTPUT_SNIPPET;
            }

            function getSamplerFromInInfo(inInfo) {
                var shape = inInfo.shapeInfo.logicalShape;
                switch (shape.length) {
                    case 0:
                        return getSamplerScalar(inInfo);
                    case 1:
                        return getSampler1D(inInfo);
                    case 2:
                        return getSampler2D(inInfo);
                    case 3:
                        return getSampler3D(inInfo);
                    case 4:
                        return getSampler4D(inInfo);
                    default:
                        throw new Error(shape.length + "-D input sampling" +
                            " is not yet supported");
                }
            }

            function getInputSamplingSnippet(inInfo, outShapeInfo, broadcast) {
                var res = getSamplerFlat(inInfo);
                res += getSamplerFromInInfo(inInfo);
                if (broadcast ||
                    util.arraysEqual(inInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape)) {
                    res += getSamplerAtOutputCoords(inInfo, outShapeInfo, broadcast);
                }
                return res;
            }

            function getOutputSamplingSnippet(outShape, outTexShape) {
                switch (outShape.length) {
                    case 0:
                        return getOutputScalarCoords();
                    case 1:
                        return getOutput1DCoords(outShape, outTexShape);
                    case 2:
                        return getOutput2DCoords(outShape, outTexShape);
                    case 3:
                        return getOutput3DCoords(outShape, outTexShape);
                    case 4:
                        return getOutput4DCoords(outShape, outTexShape);
                    default:
                        throw new Error(outShape.length + "-D output sampling is not yet supported");
                }
            }

            var SAMPLE_1D_SNIPPET = "\nvec2 UVfrom1D(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
            var SAMPLE_2D_SNIPPET = "\nvec2 UVfrom2D(int texNumR, int texNumC, int numC, int row, int col) {\n  int index = row * numC + col;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
            var SAMPLE_3D_SNIPPET = "\nvec2 UVfrom3D(int texNumR, int texNumC, int stride0,\n    int stride1, int row, int col, int depth) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
            var SAMPLE_4D_SNIPPET = "\nvec2 UVfrom4D(int texNumR, int texNumC, int stride0,\n    int stride1, int stride2, int row, int col, int depth,\n    int depth2) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth * stride2 + depth2;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
            var UNSIGNED_BYTE_TEXTURE_SAMPLE_SNIPPET = "\n  uniform float NaN;\n\n  const vec4 floatDeltas = vec4(\n      1.0,\n      1.0 / 255.0,\n      1.0 / (255.0 * 255.0),\n      1.0 / (255.0 * 255.0 * 255.0)\n  );\n  const float minValue = " + tex_util.FLOAT_MIN + ".0;\n  const float maxValue = " + tex_util.FLOAT_MAX + ".0;\n  const float range = (maxValue - minValue) / 255.0;\n  const vec2 dotRange = vec2(1.0, range);\n\n  float sample(sampler2D texture, vec2 uv) {\n    vec4 sampleValue = texture2D(texture, uv);\n    if (all(equal(sampleValue, vec4(" + tex_util.BYTE_NAN_VALUE + ")))) {\n      return NaN;\n    }\n\n    vec4 encValue = floor(sampleValue * 255.0 + 0.5);\n    float decodedValue = dot(encValue, floatDeltas);\n    return dot(vec2(minValue, decodedValue), dotRange);\n  }\n";
            var UNSIGNED_BYTE_TEXTURE_SETOUTPUT_SNIPPET = "\n  const vec4 floatPowers = vec4(\n    1.0,\n    255.0,\n    255.0 * 255.0,\n    255.0 * 255.0 * 255.0\n  );\n  const vec2 recipRange = vec2(1.0/range);\n  const vec2 recipRange255 = vec2(1.0/(maxValue - minValue));\n\n  void setOutput(float decodedValue) {\n    if (isNaN(decodedValue)) {\n      gl_FragColor = vec4(" + tex_util.BYTE_NAN_VALUE + ");\n      return;\n    }\n\n    float a = dot(vec2(decodedValue, -minValue), recipRange);\n    float b = fract(a) * 255.0;\n    float c = fract(b) * 255.0;\n    float d = fract(c) * 255.0;\n    gl_FragColor = floor(vec4(a, b, c, d)) / 255.0;\n\n    // TODO(dsmilkov): Version above gets better accuracy but probably slower\n    // than the version below. Benchmark to determine if the accuracy is worth\n    // the cost.\n\n    // float normValue = dot(vec2(decodedValue, -minValue), recipRange255);\n    // vec4 f = normValue * floatPowers;\n    // gl_FragColor = floor(fract(f) * 255.0) / 255.0;\n  }\n";
            var FLOAT_TEXTURE_SAMPLE_SNIPPET = "\n  float sample(sampler2D texture, vec2 uv) {\n    return texture2D(texture, uv).r;\n  }\n";
            var FLOAT_TEXTURE_SETOUTPUT_SNIPPET = "\n  void setOutput(float val) {\n    gl_FragColor = vec4(val, 0, 0, 0);\n  }\n";
            var SHADER_PREFIX = "\n  precision highp float;\n  precision highp int;\n  varying vec2 resultUV;\n  const vec2 halfCR = vec2(0.5, 0.5);\n\n  bool isNaN(float val) {\n    float v1 = val * val;\n    float v2 = val * val;\n    return v1 == v2 ? false : true;\n  }\n\n  bool hasNaN(vec4 values) {\n    vec4 v1 = values * values;\n    vec4 v2 = values * values;\n    return any(notEqual(v1, v2));\n  }\n\n  float getNaN(vec4 values) {\n    return dot(vec4(1), values);\n  }\n\n  int round(float value) {\n    return int(floor(value + 0.5));\n  }\n\n  int imod(int x, int y) {\n    return x - y * (x / y);\n  }\n\n  const vec2 randomConst = vec2(\n    23.14069263277926, // e^pi (Gelfond's constant)\n     2.665144142690225 // 2^sqrt(2) (Gelfond\u2013Schneider constant)\n  );\n\n  float random(float seed) {\n      return fract(cos(dot(resultUV * seed, randomConst)) * 12345.6789);\n  }\n\n  float sampleUVAndDepth(sampler2D texture, vec2 uv, int depth) {\n    float value;\n    if (depth == 0) {\n      value = texture2D(texture, uv).r;\n    } else if (depth == 1) {\n      value = texture2D(texture, uv).g;\n    } else if (depth == 2) {\n      value = texture2D(texture, uv).b;\n    } else if (depth == 3) {\n      value = texture2D(texture, uv).a;\n    }\n    return floor(value * 255.0 + 0.5);\n  }\n\n  " + SAMPLE_1D_SNIPPET + "\n  " + SAMPLE_2D_SNIPPET + "\n  " + SAMPLE_3D_SNIPPET + "\n  " + SAMPLE_4D_SNIPPET + "\n";

            function getOutputScalarCoords() {
                return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
            }

            function getOutput1DCoords(shape, texShape) {
                if (texShape[0] === 1) {
                    return "\n      int getOutputCoords() {\n        return int(resultUV.x * " + texShape[1] + ".0);\n      }\n    ";
                }
                if (texShape[1] === 1) {
                    return "\n      int getOutputCoords() {\n        return int(resultUV.y * " + texShape[0] + ".0);\n      }\n    ";
                }
                return "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + texShape[0] + ", " + texShape[1] + "));\n      return resTexRC.x * " + texShape[1] + " + resTexRC.y;\n    }\n  ";
            }

            function getOutput3DCoords(shape, texShape) {
                var stride0 = shape[1] * shape[2];
                var stride1 = shape[2];
                return "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + texShape[0] + ", " + texShape[1] + "));\n      int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n      int r = index / " + stride0 + ";\n      index -= r * " + stride0 + ";\n      int c = index / " + stride1 + ";\n      int d = index - c * " + stride1 + ";\n      return ivec3(r, c, d);\n    }\n  ";
            }

            function getOutput4DCoords(shape, texShape) {
                var stride2 = shape[3];
                var stride1 = shape[2] * stride2;
                var stride0 = shape[1] * stride1;
                return "\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" + texShape[0] + ", " + texShape[1] + "));\n      int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n\n      int r = index / " + stride0 + ";\n      index -= r * " + stride0 + ";\n\n      int c = index / " + stride1 + ";\n      index -= c * " + stride1 + ";\n\n      int d = index / " + stride2 + ";\n      int d2 = index - d * " + stride2 + ";\n\n      return ivec4(r, c, d, d2);\n    }\n  ";
            }

            function getOutput2DCoords(shape, texShape) {
                if (util.arraysEqual(shape, texShape)) {
                    return "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(" + texShape[0] + ", " + texShape[1] + "));\n      }\n    ";
                }
                if (shape[1] === 1) {
                    return "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + texShape[0] + ", " + texShape[1] + "));\n        int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ";
                }
                if (shape[0] === 1) {
                    return "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + texShape[0] + ", " + texShape[1] + "));\n        int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ";
                }
                return "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + texShape[0] + ", " + texShape[1] + "));\n      int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n      int r = index / " + shape[1] + ";\n      int c = index - r * " + shape[1] + ";\n      return ivec2(r, c);\n    }\n  ";
            }

            function getSamplerScalar(inputInfo) {
                var texName = inputInfo.name;
                var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
                return "\n    float " + funcName + "() {\n      return sample(" + texName + ", halfCR);\n    }\n  ";
            }

            function getSampler1D(inputInfo) {
                var texName = inputInfo.name;
                var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
                return "\n    float " + funcName + "(int index) {\n      return " + funcName + "Flat(index);\n    }\n  ";
            }

            function getSampler2D(inputInfo) {
                var shape = inputInfo.shapeInfo.logicalShape;
                var texShape = inputInfo.shapeInfo.texShape;
                var texName = inputInfo.name;
                var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
                var texNumR = texShape[0];
                var texNumC = texShape[1];
                if (util.arraysEqual(shape, texShape)) {
                    return "\n    float " + funcName + "(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(" + texNumC + ".0, " + texNumR + ".0);\n      return sample(" + texName + ", uv);\n    }\n  ";
                }
                var _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;
                var squeezedShape = newShape;
                if (squeezedShape.length < shape.length) {
                    var newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
                    var params = ['row', 'col'];
                    return "\n      " + getSamplerFromInInfo(newInputInfo) + "\n      float " + funcName + "(int row, int col) {\n        return " + funcName + "(" + getSqueezedParams(params, keptDims) + ");\n      }\n    ";
                }
                if (texNumC === 1) {
                    return "\n    float " + funcName + "(int row, int col) {\n      int index = row * " + shape[1] + " + col;\n      vec2 uv = vec2(0.5, (float(index) + 0.5) / " + texNumR + ".0);\n      return sample(" + texName + ", uv);\n    }\n  ";
                }
                if (texNumR === 1) {
                    return "\n    float " + funcName + "(int row, int col) {\n      int index = row * " + shape[1] + " + col;\n      vec2 uv = vec2((float(index) + 0.5) / " + texNumC + ".0, 0.5);\n      return sample(" + texName + ", uv);\n    }\n  ";
                }
                return "\n  float " + funcName + "(int row, int col) {\n    vec2 uv = UVfrom2D(" + texNumR + ", " + texNumC + ", " + shape[1] + ", row, col);\n    return sample(" + texName + ", uv);\n  }\n";
            }

            function getSampler3D(inputInfo) {
                var texShape = inputInfo.shapeInfo.texShape;
                var shape = inputInfo.shapeInfo.logicalShape;
                var texName = inputInfo.name;
                var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
                var texNumR = texShape[0];
                var texNumC = texShape[1];
                var stride0 = shape[1] * shape[2];
                var stride1 = shape[2];
                var texType = inputInfo.shapeInfo.textureType;
                if (texType === tex_util_1.TextureType.DEFAULT) {
                    var _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;
                    var squeezedShape = newShape;
                    if (squeezedShape.length < shape.length) {
                        var newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
                        var params = ['row', 'col', 'depth'];
                        return "\n        " + getSamplerFromInInfo(newInputInfo) + "\n        float " + funcName + "(int row, int col, int depth) {\n          return " + funcName + "(" + getSqueezedParams(params, keptDims) + ");\n        }\n      ";
                    }
                }
                if (texNumC === stride0) {
                    if (texType === tex_util_1.TextureType.DEFAULT) {
                        return "\n        float " + funcName + "(int row, int col, int depth) {\n          int texR = row;\n          int texC = col * " + stride1 + " + depth;\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(" + texNumC + ".0, " + texNumR + ".0);\n          return sample(" + texName + ", uv);\n        }\n      ";
                    } else if (texType === tex_util_1.TextureType.RGBA_COLOR) {
                        return "\n        float " + funcName + "(int row, int col, int depth) {\n          vec2 uv = (vec2(col, row) + halfCR) /\n                     vec2(" + texNumC + ".0, " + texNumR + ".0);\n          return sampleUVAndDepth(" + texName + ", uv, depth);\n        }\n      ";
                    } else {
                        throw new Error("Unknown TextureType " + texType + ".");
                    }
                }
                if (texNumC === stride1 && texType === tex_util_1.TextureType.DEFAULT) {
                    return "\n    float " + funcName + "(int row, int col, int depth) {\n      int texR = row * " + shape[1] + " + col;\n      int texC = depth;\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + texNumC + ".0, " + texNumR + ".0);\n      return sample(" + texName + ", uv);\n    }\n  ";
                }
                if (texType === tex_util_1.TextureType.DEFAULT) {
                    return "\n      float " + funcName + "(int row, int col, int depth) {\n        vec2 uv = UVfrom3D(\n            " + texNumR + ", " + texNumC + ", " + stride0 + ", " + stride1 + ", row, col, depth);\n        return sample(" + texName + ", uv);\n      }\n  ";
                } else if (texType === tex_util_1.TextureType.RGBA_COLOR) {
                    return "\n      float " + funcName + "(int row, int col, int depth) {\n        vec2 uv = UVfrom2D(" + texNumR + ", " + texNumC + ", " + shape[1] + ", row, col);\n        return sampleUVAndDepth(" + texName + ", uv, depth);\n      }\n    ";
                } else {
                    throw new Error("Unknown TextureType " + texType + ".");
                }
            }

            function getSampler4D(inputInfo) {
                var shape = inputInfo.shapeInfo.logicalShape;
                var texShape = inputInfo.shapeInfo.texShape;
                var texName = inputInfo.name;
                var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
                var texNumR = texShape[0];
                var texNumC = texShape[1];
                var stride2 = shape[3];
                var stride1 = shape[2] * stride2;
                var stride0 = shape[1] * stride1;
                var _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;
                if (newShape.length < shape.length) {
                    var newInputInfo = squeezeInputInfo(inputInfo, newShape);
                    var params = ['row', 'col', 'depth', 'depth2'];
                    return "\n      " + getSamplerFromInInfo(newInputInfo) + "\n      float " + funcName + "(int row, int col, int depth, int depth2) {\n        return " + funcName + "(" + getSqueezedParams(params, keptDims) + ");\n      }\n    ";
                }
                if (texNumC === stride0) {
                    return "\n      float " + funcName + "(int row, int col, int depth, int depth2) {\n        int texR = row;\n        int texC = col * " + stride1 + " + depth * " + stride2 + " + depth2;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + texNumC + ".0, " + texNumR + ".0);\n        return sample(" + texName + ", uv);\n      }\n    ";
                }
                if (texNumC === stride2) {
                    return "\n      float " + funcName + "(int row, int col, int depth, int depth2) {\n        int texR = row * " + shape[1] * shape[2] + " + col * " + shape[2] + " + depth;\n        int texC = depth2;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + texNumC + ".0, " + texNumR + ".0);\n        return sample(" + texName + ", uv);\n      }\n    ";
                }
                return "\n    float " + funcName + "(int row, int col, int depth, int depth2) {\n      vec2 uv = UVfrom4D(" + texNumR + ", " + texNumC + ", " + stride0 + ", " + stride1 + ",\n          " + stride2 + ", row, col, depth, depth2);\n      return sample(" + texName + ", uv);\n    }\n  ";
            }

            function getSamplerFlat(inputInfo) {
                var texName = inputInfo.name;
                var texShape = inputInfo.shapeInfo.texShape;
                var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1) + 'Flat';
                var tNumR = texShape[0];
                var tNumC = texShape[1];
                if (tNumC === 1 && tNumR === 1) {
                    return "\n      float " + funcName + "(int index) {\n        return sample(" + texName + ", halfCR);\n      }\n    ";
                }
                if (tNumC === 1) {
                    return "\n      float " + funcName + "(int index) {\n        vec2 uv = vec2(0.5, (float(index) + 0.5) / " + tNumR + ".0);\n        return sample(" + texName + ", uv);\n      }\n    ";
                }
                if (tNumR === 1) {
                    return "\n      float " + funcName + "(int index) {\n        vec2 uv = vec2((float(index) + 0.5) / " + tNumC + ".0, 0.5);\n        return sample(" + texName + ", uv);\n      }\n    ";
                }
                return "\n    float " + funcName + "(int index) {\n      vec2 uv = UVfrom1D(" + tNumR + ", " + tNumC + ", index);\n      return sample(" + texName + ", uv);\n    }\n  ";
            }

            function getBroadcastOutputCoordsSampler(inputInfo, outShapeInfo, texFuncSnippet, funcName) {
                var inRank = inputInfo.shapeInfo.logicalShape.length;
                var outRank = outShapeInfo.logicalShape.length;
                var type = 'int';
                if (outRank === 2) {
                    type = 'ivec2';
                } else if (outRank === 3) {
                    type = 'ivec3';
                } else if (outRank === 4) {
                    type = 'ivec4';
                }
                var broadcastDims = broadcast_util.getBroadcastDims(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);
                var rankDiff = outRank - inRank;
                var coordsSnippet;
                if (inRank === 0) {
                    coordsSnippet = '';
                } else if (outRank < 2 && broadcastDims.length >= 1) {
                    coordsSnippet = 'coords = 0;';
                } else {
                    coordsSnippet =
                        broadcastDims.map(function (d) {
                            return "coords[" + (d + rankDiff) + "] = 0;";
                        }).join('\n');
                }
                var unpackedCoordsSnippet = '';
                if (outRank < 2 && inRank > 0) {
                    unpackedCoordsSnippet = 'coords';
                } else {
                    unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape
                        .map(function (s, i) {
                            return "coords[" + (i + rankDiff) + "]";
                        })
                        .join(', ');
                }
                return "\n    float " + funcName + "() {\n      " + type + " coords = getOutputCoords();\n      " + coordsSnippet + "\n      return get" + texFuncSnippet + "(" + unpackedCoordsSnippet + ");\n    }\n  ";
            }

            function getSamplerAtOutputCoords(inputInfo, outShapeInfo, supportsBroadcasting) {
                var inTexShape = inputInfo.shapeInfo.texShape;
                var texName = inputInfo.name;
                var isRGBAColorTexture = inputInfo.shapeInfo.textureType === tex_util_1.TextureType.RGBA_COLOR;
                var texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);
                var funcName = 'get' + texFuncSnippet + 'AtOutCoords';
                var broadcastDims = broadcast_util.getBroadcastDims(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);
                var inRank = inputInfo.shapeInfo.logicalShape.length;
                var outRank = outShapeInfo.logicalShape.length;
                var doBroadcast = supportsBroadcasting && ((outRank > inRank) || broadcastDims.length > 0);
                var broadcastOverOuter = broadcast_util.broadcastDimsAreOuter(broadcastDims);
                if (doBroadcast && !broadcastOverOuter) {
                    return getBroadcastOutputCoordsSampler(inputInfo, outShapeInfo, texFuncSnippet, funcName);
                }
                var outTexShape = outShapeInfo.texShape;
                if (util.arraysEqual(inTexShape, outTexShape) && !isRGBAColorTexture) {
                    return "\n      float " + funcName + "() {\n        return sample(" + texName + ", resultUV);\n      }\n    ";
                }
                var inTexExpandedShape = isRGBAColorTexture ?
                    [inTexShape[0], inTexShape[1] * inputInfo.shapeInfo.logicalShape[2]] :
                    inTexShape;
                var sampleSnippet = "return sample(" + texName + ", uv);";
                var rgbaColorSnippet = '';
                if (isRGBAColorTexture) {
                    rgbaColorSnippet = "\n      int col = texC / " + inputInfo.shapeInfo.logicalShape[2] + ";\n      int texD = texC - col * " + inputInfo.shapeInfo.logicalShape[2] + ";\n      texC = col;\n    ";
                    sampleSnippet = "return sampleUVAndDepth(" + texName + ", uv, texD);";
                }
                var inSize = util.sizeFromShape(inTexExpandedShape);
                var broadcastSnippet = '';
                if (doBroadcast && broadcastOverOuter) {
                    broadcastSnippet = "\n        int mainPart = index / " + inSize + ";\n        index -= mainPart * " + inSize + ";\n      ";
                }
                return "\n    float " + funcName + "() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + outTexShape[0] + ", " + outTexShape[1] + "));\n      int index = resTexRC.x * " + outTexShape[1] + " + resTexRC.y;\n      " + broadcastSnippet + "\n      int texR = index / " + inTexExpandedShape[1] + ";\n      int texC = index - texR * " + inTexExpandedShape[1] + ";\n\n      " + rgbaColorSnippet + "\n\n      vec2 uv = (vec2(texC, texR) + halfCR) /\n                 vec2(" + inTexShape[1] + ".0, " + inTexShape[0] + ".0);\n\n      " + sampleSnippet + "\n    }\n  ";
            }

            function getCoordsDataType(rank) {
                if (rank === 1) {
                    return 'int';
                } else if (rank === 2) {
                    return 'ivec2';
                } else if (rank === 3) {
                    return 'ivec3';
                } else if (rank === 4) {
                    return 'ivec4';
                } else {
                    throw Error("GPU for rank " + rank + " is not yet supported");
                }
            }

            exports.getCoordsDataType = getCoordsDataType;

            function squeezeInputInfo(inInfo, squeezedShape) {
                var newInputInfo = JSON.parse(JSON.stringify(inInfo));
                newInputInfo.shapeInfo.logicalShape = squeezedShape;
                return newInputInfo;
            }

            function getSqueezedParams(params, keptDims) {
                return keptDims.map(function (d) {
                    return params[d];
                }).join(', ');
            }

        }, {"../../../environment": 15, "../../../util": 101, "../../broadcast_util": 90, "./tex_util": 84}],
        83: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var shader_compiler_1 = require("./shader_compiler");
            var SliceProgram = (function () {
                function SliceProgram(destSize) {
                    this.variableNames = ['source'];
                    this.outputShape = destSize;
                    this.rank = destSize.length;
                    var dtype = shader_compiler_1.getCoordsDataType(this.rank);
                    var sourceCoords = getCoords(this.rank);
                    this.userCode = "\n      uniform " + dtype + " start;\n\n      void main() {\n        " + dtype + " sourceLoc = start + getOutputCoords();\n        setOutput(getSource(" + sourceCoords + "));\n      }\n    ";
                }

                SliceProgram.prototype.getCustomSetupFunc = function (start) {
                    var _this = this;
                    if (start.length !== this.rank) {
                        throw Error("The rank (" + this.rank + ") of the program must match the " +
                            ("length of start (" + start.length + ")"));
                    }
                    return function (gpgpu, webGLProgram) {
                        if (_this.startLoc == null) {
                            _this.startLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'start');
                            if (_this.startLoc == null) {
                                return;
                            }
                        }
                        if (_this.rank === 1) {
                            gpgpu.gl.uniform1i(_this.startLoc, start[0]);
                        } else if (_this.rank === 2) {
                            gpgpu.gl.uniform2i(_this.startLoc, start[0], start[1]);
                        } else if (_this.rank === 3) {
                            gpgpu.gl.uniform3i(_this.startLoc, start[0], start[1], start[2]);
                        } else if (_this.rank === 4) {
                            gpgpu.gl.uniform4i(_this.startLoc, start[0], start[1], start[2], start[3]);
                        } else {
                            throw Error("Slicing for rank " + _this.rank + " is not yet supported");
                        }
                    };
                };
                return SliceProgram;
            }());
            exports.SliceProgram = SliceProgram;

            function getCoords(rank) {
                if (rank === 1) {
                    return 'sourceLoc';
                } else if (rank === 2) {
                    return 'sourceLoc.x, sourceLoc.y';
                } else if (rank === 3) {
                    return 'sourceLoc.x, sourceLoc.y, sourceLoc.z';
                } else if (rank === 4) {
                    return 'sourceLoc.x, sourceLoc.y, sourceLoc.z, sourceLoc.w';
                } else {
                    throw Error("Slicing for rank " + rank + " is not yet supported");
                }
            }

        }, {"./shader_compiler": 82}],
        84: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var TextureType;
            (function (TextureType) {
                TextureType[TextureType["DEFAULT"] = 0] = "DEFAULT";
                TextureType[TextureType["RGBA_COLOR"] = 1] = "RGBA_COLOR";
            })(TextureType = exports.TextureType || (exports.TextureType = {}));

            function getUnpackedMatrixTextureShapeWidthHeight(rows, columns) {
                return [columns, rows];
            }

            exports.getUnpackedMatrixTextureShapeWidthHeight = getUnpackedMatrixTextureShapeWidthHeight;

            function getUnpackedArraySizeFromMatrixSize(matrixSize, channelsPerTexture) {
                return matrixSize * channelsPerTexture;
            }

            exports.getUnpackedArraySizeFromMatrixSize = getUnpackedArraySizeFromMatrixSize;

            function getColorMatrixTextureShapeWidthHeight(rows, columns) {
                return [columns * 4, rows];
            }

            exports.getColorMatrixTextureShapeWidthHeight = getColorMatrixTextureShapeWidthHeight;

            function getMatrixSizeFromUnpackedArraySize(unpackedSize, channelsPerTexture) {
                if (unpackedSize % channelsPerTexture !== 0) {
                    throw new Error("unpackedSize (" + unpackedSize + ") must be a multiple of " +
                        ("" + channelsPerTexture));
                }
                return unpackedSize / channelsPerTexture;
            }

            exports.getMatrixSizeFromUnpackedArraySize = getMatrixSizeFromUnpackedArraySize;

            function encodeMatrixToUnpackedArray(matrix, unpackedArray, channelsPerTexture) {
                var requiredSize = getUnpackedArraySizeFromMatrixSize(matrix.length, channelsPerTexture);
                if (unpackedArray.length < requiredSize) {
                    throw new Error("unpackedArray length (" + unpackedArray.length + ") must be >= " +
                        ("" + requiredSize));
                }
                var dst = 0;
                for (var src = 0; src < matrix.length; ++src) {
                    unpackedArray[dst] = matrix[src];
                    dst += channelsPerTexture;
                }
            }

            exports.encodeMatrixToUnpackedArray = encodeMatrixToUnpackedArray;
            exports.FLOAT_MAX = 20000;
            exports.FLOAT_MIN = -exports.FLOAT_MAX;
            var FLOAT_RANGE = (exports.FLOAT_MAX - exports.FLOAT_MIN) / 255;
            var FLOAT_DELTAS = [1, 1 / 255, 1 / (255 * 255), 1 / (255 * 255 * 255)];
            var FLOAT_POWERS = [1, 255, 255 * 255];
            exports.BYTE_NAN_VALUE = 0;

            function encodeFloatArray(floatArray) {
                var uintArray = new Uint8Array(floatArray.length * 4);
                var _loop_1 = function (i) {
                    var value = floatArray[i / 4];
                    if (isNaN(value)) {
                        uintArray[i] = exports.BYTE_NAN_VALUE;
                        uintArray[i + 1] = exports.BYTE_NAN_VALUE;
                        uintArray[i + 2] = exports.BYTE_NAN_VALUE;
                        uintArray[i + 3] = exports.BYTE_NAN_VALUE;
                        return "continue";
                    }
                    var normalizedValue = (value - exports.FLOAT_MIN) / FLOAT_RANGE;
                    var enc = FLOAT_POWERS.map(function (pow) {
                        return pow * normalizedValue;
                    });
                    var buckets = enc.map(function (value) {
                        return Math.floor((value % 1) * 255);
                    });
                    uintArray[i] = Math.floor(normalizedValue);
                    uintArray[i + 1] = buckets[0];
                    uintArray[i + 2] = buckets[1];
                    uintArray[i + 3] = buckets[2];
                };
                for (var i = 0; i < uintArray.length; i += 4) {
                    _loop_1(i);
                }
                return uintArray;
            }

            exports.encodeFloatArray = encodeFloatArray;

            function decodeToFloatArray(uintArray) {
                var floatArray = new Float32Array(uintArray.length / 4);
                var _loop_2 = function (i) {
                    if (uintArray[i] === exports.BYTE_NAN_VALUE &&
                        uintArray[i + 1] === exports.BYTE_NAN_VALUE &&
                        uintArray[i + 2] === exports.BYTE_NAN_VALUE &&
                        uintArray[i + 3] === exports.BYTE_NAN_VALUE) {
                        floatArray[i / 4] = NaN;
                        return "continue";
                    }
                    var dot = 0;
                    FLOAT_DELTAS.forEach(function (delta, j) {
                        dot += delta * uintArray[i + j];
                    });
                    var value = dot * FLOAT_RANGE + exports.FLOAT_MIN;
                    floatArray[i / 4] = value;
                };
                for (var i = 0; i < uintArray.length; i += 4) {
                    _loop_2(i);
                }
                return floatArray;
            }

            exports.decodeToFloatArray = decodeToFloatArray;

            function decodeMatrixFromUnpackedArray(unpackedArray, matrix, channelsPerTexture) {
                var requiredSize = getMatrixSizeFromUnpackedArraySize(unpackedArray.length, channelsPerTexture);
                if (matrix.length < requiredSize) {
                    throw new Error("matrix length (" + matrix.length + ") must be >= " + requiredSize);
                }
                var dst = 0;
                for (var src = 0; src < unpackedArray.length; src += channelsPerTexture) {
                    matrix[dst++] = unpackedArray[src];
                }
            }

            exports.decodeMatrixFromUnpackedArray = decodeMatrixFromUnpackedArray;

            function decodeMatrixFromUnpackedColorRGBAArray(unpackedArray, matrix, channels) {
                var requiredSize = unpackedArray.length * channels / 4;
                if (matrix.length < requiredSize) {
                    throw new Error("matrix length (" + matrix.length + ") must be >= " + requiredSize);
                }
                var dst = 0;
                for (var src = 0; src < unpackedArray.length; src += 4) {
                    for (var c = 0; c < channels; c++) {
                        matrix[dst++] = unpackedArray[src + c];
                    }
                }
            }

            exports.decodeMatrixFromUnpackedColorRGBAArray = decodeMatrixFromUnpackedColorRGBAArray;

            function getPackedMatrixTextureShapeWidthHeight(rows, columns) {
                return [Math.ceil(columns / 2), Math.ceil(rows / 2)];
            }

            exports.getPackedMatrixTextureShapeWidthHeight = getPackedMatrixTextureShapeWidthHeight;

            function getPackedRGBAArraySizeFromMatrixShape(rows, columns) {
                var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
                return w * h * 4;
            }

            exports.getPackedRGBAArraySizeFromMatrixShape = getPackedRGBAArraySizeFromMatrixShape;

            function encodeMatrixToPackedRGBA(matrix, rows, columns, packedRGBA) {
                var requiredSize = getPackedRGBAArraySizeFromMatrixShape(rows, columns);
                if (packedRGBA.length < requiredSize) {
                    throw new Error("packedRGBA length (" + packedRGBA.length + ") must be >= " + requiredSize);
                }
                var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), textureWidth = _a[0],
                    textureHeight = _a[1];
                var oddWidth = (columns % 2) === 1;
                var oddHeight = (rows % 2) === 1;
                var widthInFullBlocks = Math.floor(columns / 2);
                var heightInFullBlocks = Math.floor(rows / 2);
                {
                    var dstStride = (oddWidth ? 4 : 0);
                    var oneRow = columns;
                    var dst = 0;
                    for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
                        var matrixSrcRow = (blockY * 2 * columns);
                        for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
                            var matrixSrcCol = blockX * 2;
                            var src = matrixSrcRow + matrixSrcCol;
                            packedRGBA[dst] = matrix[src];
                            packedRGBA[dst + 1] = matrix[src + 1];
                            packedRGBA[dst + 2] = matrix[src + oneRow];
                            packedRGBA[dst + 3] = matrix[src + oneRow + 1];
                            dst += 4;
                        }
                        dst += dstStride;
                    }
                }
                if (oddWidth) {
                    var src = columns - 1;
                    var dst = (textureWidth - 1) * 4;
                    var srcStride = 2 * columns;
                    var dstStride = textureWidth * 4;
                    for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
                        packedRGBA[dst] = matrix[src];
                        packedRGBA[dst + 2] = matrix[src + columns];
                        src += srcStride;
                        dst += dstStride;
                    }
                }
                if (oddHeight) {
                    var src = (rows - 1) * columns;
                    var dst = (textureHeight - 1) * textureWidth * 4;
                    for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
                        packedRGBA[dst++] = matrix[src++];
                        packedRGBA[dst++] = matrix[src++];
                        dst += 2;
                    }
                }
                if (oddWidth && oddHeight) {
                    packedRGBA[packedRGBA.length - 4] = matrix[matrix.length - 1];
                }
                return packedRGBA;
            }

            exports.encodeMatrixToPackedRGBA = encodeMatrixToPackedRGBA;

            function decodeMatrixFromPackedRGBA(packedRGBA, rows, columns, matrix) {
                var requiredSize = rows * columns;
                if (requiredSize < matrix.length) {
                    throw new Error("matrix length (" + matrix.length + ") must be >= " + requiredSize);
                }
                var oddWidth = (columns % 2) === 1;
                var oddHeight = (rows % 2) === 1;
                var widthInFullBlocks = Math.floor(columns / 2);
                var heightInFullBlocks = Math.floor(rows / 2);
                var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), textureWidth = _a[0],
                    textureHeight = _a[1];
                {
                    var srcStride = oddWidth ? 4 : 0;
                    var dstStride = columns + (oddWidth ? 1 : 0);
                    var src = 0;
                    var dstRow1 = 0;
                    var dstRow2 = columns;
                    for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
                        for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
                            matrix[dstRow1++] = packedRGBA[src++];
                            matrix[dstRow1++] = packedRGBA[src++];
                            matrix[dstRow2++] = packedRGBA[src++];
                            matrix[dstRow2++] = packedRGBA[src++];
                        }
                        src += srcStride;
                        dstRow1 += dstStride;
                        dstRow2 += dstStride;
                    }
                }
                if (oddWidth) {
                    var src = (textureWidth - 1) * 4;
                    var dst = columns - 1;
                    var srcStride = textureWidth * 4;
                    var dstStride = 2 * columns;
                    for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
                        matrix[dst] = packedRGBA[src];
                        matrix[dst + columns] = packedRGBA[src + 2];
                        src += srcStride;
                        dst += dstStride;
                    }
                }
                if (oddHeight) {
                    var src = (textureHeight - 1) * textureWidth * 4;
                    var dst = (rows - 1) * columns;
                    for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
                        matrix[dst++] = packedRGBA[src++];
                        matrix[dst++] = packedRGBA[src++];
                        src += 2;
                    }
                }
                if (oddWidth && oddHeight) {
                    matrix[matrix.length - 1] = packedRGBA[packedRGBA.length - 4];
                }
                return matrix;
            }

            exports.decodeMatrixFromPackedRGBA = decodeMatrixFromPackedRGBA;

        }, {}],
        85: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var TextureManager = (function () {
                function TextureManager(gpgpu) {
                    this.gpgpu = gpgpu;
                    this.numUsedTextures = 0;
                    this.numFreeTextures = 0;
                    this.freeTextures = {};
                    this.logEnabled = false;
                    this.usedTextureCount = {};
                }

                TextureManager.prototype.acquireTexture = function (shapeRC) {
                    var shapeKey = getKeyFromTextureShape(shapeRC);
                    if (!(shapeKey in this.freeTextures)) {
                        this.freeTextures[shapeKey] = [];
                    }
                    if (!(shapeKey in this.usedTextureCount)) {
                        this.usedTextureCount[shapeKey] = 0;
                    }
                    this.usedTextureCount[shapeKey]++;
                    if (this.freeTextures[shapeKey].length > 0) {
                        this.numFreeTextures--;
                        this.numUsedTextures++;
                        this.log();
                        return this.freeTextures[shapeKey].shift();
                    }
                    this.numUsedTextures++;
                    this.log();
                    return this.gpgpu.createMatrixTexture(shapeRC[0], shapeRC[1]);
                };
                TextureManager.prototype.releaseTexture = function (texture, shape) {
                    var shapeKey = getKeyFromTextureShape(shape);
                    if (!(shapeKey in this.freeTextures)) {
                        this.freeTextures[shapeKey] = [];
                    }
                    this.freeTextures[shapeKey].push(texture);
                    this.numFreeTextures++;
                    this.numUsedTextures--;
                    this.usedTextureCount[shapeKey]--;
                    this.log();
                };
                TextureManager.prototype.log = function () {
                    if (!this.logEnabled) {
                        return;
                    }
                    var total = this.numFreeTextures + this.numUsedTextures;
                    console.log('Free/Used', this.numFreeTextures + " / " + this.numUsedTextures, "(" + total + ")");
                };
                TextureManager.prototype.getNumUsedTextures = function () {
                    return this.numUsedTextures;
                };
                TextureManager.prototype.getNumFreeTextures = function () {
                    return this.numFreeTextures;
                };
                TextureManager.prototype.dispose = function () {
                    for (var shape in this.freeTextures) {
                        if (this.freeTextures.hasOwnProperty(shape)) {
                            for (var i = 0; i < this.freeTextures[shape].length; i++) {
                                this.gpgpu.deleteMatrixTexture(this.freeTextures[shape][i]);
                            }
                        }
                    }
                };
                return TextureManager;
            }());
            exports.TextureManager = TextureManager;

            function getKeyFromTextureShape(shapeRowsCol) {
                return shapeRowsCol[0] + "_" + shapeRowsCol[1];
            }

        }, {}],
        86: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var shader_compiler_1 = require("./shader_compiler");
            var TileProgram = (function () {
                function TileProgram(aShape, reps) {
                    this.variableNames = ['A'];
                    var outputShape = new Array(aShape.length);
                    for (var i = 0; i < outputShape.length; i++) {
                        outputShape[i] = aShape[i] * reps[i];
                    }
                    this.outputShape = outputShape;
                    this.rank = outputShape.length;
                    var dtype = shader_compiler_1.getCoordsDataType(this.rank);
                    var sourceCoords = getSourceCoords(aShape);
                    this.userCode = "\n      void main() {\n        " + dtype + " resRC = getOutputCoords();\n        setOutput(getA(" + sourceCoords + "));\n      }\n    ";
                }

                return TileProgram;
            }());
            exports.TileProgram = TileProgram;

            function getSourceCoords(aShape) {
                var rank = aShape.length;
                if (rank > 4) {
                    throw Error("Tile for rank " + rank + " is not yet supported");
                }
                if (rank === 1) {
                    return "imod(resRC, " + aShape[0] + ")";
                }
                var currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];
                var sourceCoords = [];
                for (var i = 0; i < aShape.length; i++) {
                    sourceCoords.push("imod(" + currentCoords[i] + ", " + aShape[i] + ")");
                }
                return sourceCoords.join();
            }

        }, {"./shader_compiler": 82}],
        87: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var shader_compiler_1 = require("./shader_compiler");
            var TransposeProgram = (function () {
                function TransposeProgram(aShape, newDim) {
                    this.variableNames = ['A'];
                    var outputShape = new Array(aShape.length);
                    for (var i = 0; i < outputShape.length; i++) {
                        outputShape[i] = aShape[newDim[i]];
                    }
                    this.outputShape = outputShape;
                    this.rank = outputShape.length;
                    var dtype = shader_compiler_1.getCoordsDataType(this.rank);
                    var switched = getSwitchedCoords(newDim);
                    this.userCode = "\n    void main() {\n      " + dtype + " resRC = getOutputCoords();\n      setOutput(getA(" + switched + "));\n    }\n    ";
                }

                return TransposeProgram;
            }());
            exports.TransposeProgram = TransposeProgram;

            function getSwitchedCoords(newDim) {
                var rank = newDim.length;
                if (rank > 4) {
                    throw Error("Transpose for rank " + rank + " is not yet supported");
                }
                var originalOrder = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];
                var switchedCoords = new Array(rank);
                for (var i = 0; i < newDim.length; i++) {
                    switchedCoords[newDim[i]] = originalOrder[i];
                }
                return switchedCoords.join();
            }

        }, {"./shader_compiler": 82}],
        88: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var UnaryOpProgram = (function () {
                function UnaryOpProgram(aShape, opSnippet) {
                    this.variableNames = ['A'];
                    this.outputShape = aShape;
                    this.userCode = "\n      float unaryOperation(float x) {\n        " + opSnippet + "\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ";
                }

                return UnaryOpProgram;
            }());
            exports.UnaryOpProgram = UnaryOpProgram;
            exports.CHECK_NAN_SNIPPET = "\n  if (isNaN(x)) {\n    return x;\n  }\n";
            exports.ABS = "\n  return abs(x);\n";
            exports.RELU = exports.CHECK_NAN_SNIPPET + "\n  return (x < 0.0) ? 0.0 : x;\n";
            exports.ELU = "\n  return (x >= 0.0) ? x : (exp(x) - 1.0);\n";
            exports.ELU_DER = "\n  return (x >= 0.0) ? 1.0 : exp(x);\n";
            exports.SELU = "\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = 1.7580993408473768599402175208123;\n  float scale = 1.0507009873554804934193349852946;\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n";

            function LEAKY_RELU(alpha) {
                return "\n    return (x >= 0.0) ? x : " + alpha + " * x;\n  ";
            }

            exports.LEAKY_RELU = LEAKY_RELU;

            function STEP(alpha) {
                if (alpha === void 0) {
                    alpha = 0.0;
                }
                return exports.CHECK_NAN_SNIPPET + ("\n    return x > 0.0 ? 1.0 : float(" + alpha + ");\n  ");
            }

            exports.STEP = STEP;
            exports.NEG = "\n  return -x;\n";
            exports.CEIL = "\n  return ceil(x);\n";
            exports.FLOOR = "\n  return floor(x);\n";
            exports.EXP = "\n  return exp(x);\n";
            exports.LOG = "\n  return log(x);\n";
            exports.SQRT = exports.CHECK_NAN_SNIPPET + "\n  return sqrt(x);\n";
            exports.SIGMOID = "\n  return 1.0 / (1.0 + exp(-1.0 * x));\n";
            exports.SIN = exports.CHECK_NAN_SNIPPET + "\n  return sin(x);\n";
            exports.COS = exports.CHECK_NAN_SNIPPET + "\n  return cos(x);\n";
            exports.TAN = "\n  return tan(x);\n";
            exports.ASIN = exports.CHECK_NAN_SNIPPET + "\n  return asin(x);\n";
            exports.ACOS = exports.CHECK_NAN_SNIPPET + "\n  return acos(x);\n";
            exports.ATAN = exports.CHECK_NAN_SNIPPET + "\n  return atan(x);\n";
            exports.SINH = "\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n";
            exports.COSH = "\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n";
            exports.TANH = "\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n";
            exports.SQUARE = "\n  return x * x;\n";

        }, {}],
        89: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var MAX_TEXTURE_SIZE = null;
            var util = require("../../../util");
            var environment_1 = require("../../../environment");

            function createWebGLRenderingContext(attributes) {
                var canvas = document.createElement('canvas');
                canvas.width = 1;
                canvas.height = 1;
                return createWebGLRenderingContextFromCanvas(canvas, attributes);
            }

            exports.createWebGLRenderingContext = createWebGLRenderingContext;

            function createWebGLRenderingContextFromCanvas(canvas, attributes) {
                var gl;
                var webglVersion = environment_1.ENV.get('WEBGL_VERSION');
                if (webglVersion === 2) {
                    gl = canvas.getContext('webgl2', attributes);
                } else if (webglVersion === 1) {
                    gl = (canvas.getContext('webgl', attributes) ||
                        canvas.getContext('experimental-webgl', attributes));
                }
                if (webglVersion === 0 || gl == null) {
                    throw new Error('This browser does not support WebGL.');
                }
                return gl;
            }

            exports.createWebGLRenderingContextFromCanvas = createWebGLRenderingContextFromCanvas;

            function callAndCheck(gl, func) {
                var returnValue = func();
                checkWebGLError(gl);
                return returnValue;
            }

            exports.callAndCheck = callAndCheck;
            var webGLDebugErrorCheckingEnabled = false;

            function enableDebugWebGLErrorChecking(enabled) {
                webGLDebugErrorCheckingEnabled = enabled;
            }

            exports.enableDebugWebGLErrorChecking = enableDebugWebGLErrorChecking;

            function checkWebGLError(gl) {
                if (webGLDebugErrorCheckingEnabled) {
                    var error = gl.getError();
                    if (error !== gl.NO_ERROR) {
                        throw new Error('WebGL Error: ' + getWebGLErrorMessage(gl, error));
                    }
                }
            }

            exports.checkWebGLError = checkWebGLError;

            function getWebGLErrorMessage(gl, status) {
                switch (status) {
                    case gl.NO_ERROR:
                        return 'NO_ERROR';
                    case gl.INVALID_ENUM:
                        return 'INVALID_ENUM';
                    case gl.INVALID_VALUE:
                        return 'INVALID_VALUE';
                    case gl.INVALID_OPERATION:
                        return 'INVALID_OPERATION';
                    case gl.INVALID_FRAMEBUFFER_OPERATION:
                        return 'INVALID_FRAMEBUFFER_OPERATION';
                    case gl.OUT_OF_MEMORY:
                        return 'OUT_OF_MEMORY';
                    case gl.CONTEXT_LOST_WEBGL:
                        return 'CONTEXT_LOST_WEBGL';
                    default:
                        return "Unknown error code " + status;
                }
            }

            exports.getWebGLErrorMessage = getWebGLErrorMessage;

            function getExtensionOrThrow(gl, extensionName) {
                return throwIfNull(gl, function () {
                    return gl.getExtension(extensionName);
                }, 'Extension "' + extensionName + '" not supported on this browser.');
            }

            exports.getExtensionOrThrow = getExtensionOrThrow;

            function createVertexShader(gl, vertexShaderSource) {
                var vertexShader = throwIfNull(gl, function () {
                    return gl.createShader(gl.VERTEX_SHADER);
                }, 'Unable to create vertex WebGLShader.');
                callAndCheck(gl, function () {
                    return gl.shaderSource(vertexShader, vertexShaderSource);
                });
                callAndCheck(gl, function () {
                    return gl.compileShader(vertexShader);
                });
                if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {
                    console.log(gl.getShaderInfoLog(vertexShader));
                    throw new Error('Failed to compile vertex shader.');
                }
                return vertexShader;
            }

            exports.createVertexShader = createVertexShader;

            function createFragmentShader(gl, fragmentShaderSource) {
                var fragmentShader = throwIfNull(gl, function () {
                    return gl.createShader(gl.FRAGMENT_SHADER);
                }, 'Unable to create fragment WebGLShader.');
                callAndCheck(gl, function () {
                    return gl.shaderSource(fragmentShader, fragmentShaderSource);
                });
                callAndCheck(gl, function () {
                    return gl.compileShader(fragmentShader);
                });
                if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {
                    logShaderSourceAndInfoLog(fragmentShaderSource, gl.getShaderInfoLog(fragmentShader));
                    throw new Error('Failed to compile fragment shader.');
                }
                return fragmentShader;
            }

            exports.createFragmentShader = createFragmentShader;
            var lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;

            function logShaderSourceAndInfoLog(shaderSource, shaderInfoLog) {
                var lineNumberRegexResult = lineNumberRegex.exec(shaderInfoLog);
                if (lineNumberRegexResult == null) {
                    console.log("Couldn't parse lijn number in error: " + shaderInfoLog);
                    console.log(shaderSource);
                    return;
                }
                var lineNumber = +lineNumberRegexResult[1];
                var shaderLines = shaderSource.split('\n');
                var pad = shaderLines.length.toString().length + 2;
                var linesWithLineNumbers = shaderLines.map(function (lijn, lineNumber) {
                    return util.rightPad((lineNumber + 1).toString(), pad) + lijn;
                });
                var maxLineLength = 0;
                for (var i = 0; i < linesWithLineNumbers.length; i++) {
                    maxLineLength = Math.max(linesWithLineNumbers[i].length, maxLineLength);
                }
                var beforeErrorLines = linesWithLineNumbers.slice(0, lineNumber - 1);
                var errorLine = linesWithLineNumbers.slice(lineNumber - 1, lineNumber);
                var afterErrorLines = linesWithLineNumbers.slice(lineNumber);
                console.log(beforeErrorLines.join('\n'));
                console.log(shaderInfoLog.split('\n')[0]);
                console.log("%c " + util.rightPad(errorLine[0], maxLineLength), 'border:1px solid red; background-color:#e3d2d2; color:#a61717');
                console.log(afterErrorLines.join('\n'));
            }

            function createProgram(gl) {
                return throwIfNull(gl, function () {
                    return gl.createProgram();
                }, 'Unable to create WebGLProgram.');
            }

            exports.createProgram = createProgram;

            function linkProgram(gl, program) {
                callAndCheck(gl, function () {
                    return gl.linkProgram(program);
                });
                if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
                    console.log(gl.getProgramInfoLog(program));
                    throw new Error('Failed to link vertex and fragment shaders.');
                }
            }

            exports.linkProgram = linkProgram;

            function validateProgram(gl, program) {
                callAndCheck(gl, function () {
                    return gl.validateProgram(program);
                });
                if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {
                    console.log(gl.getProgramInfoLog(program));
                    throw new Error('Shader program validation failed.');
                }
            }

            exports.validateProgram = validateProgram;

            function createStaticVertexBuffer(gl, data) {
                var buffer = throwIfNull(gl, function () {
                    return gl.createBuffer();
                }, 'Unable to create WebGLBuffer');
                callAndCheck(gl, function () {
                    return gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                });
                callAndCheck(gl, function () {
                    return gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
                });
                return buffer;
            }

            exports.createStaticVertexBuffer = createStaticVertexBuffer;

            function createStaticIndexBuffer(gl, data) {
                var buffer = throwIfNull(gl, function () {
                    return gl.createBuffer();
                }, 'Unable to create WebGLBuffer');
                callAndCheck(gl, function () {
                    return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
                });
                callAndCheck(gl, function () {
                    return gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW);
                });
                return buffer;
            }

            exports.createStaticIndexBuffer = createStaticIndexBuffer;

            function queryMaxTextureSize(gl) {
                if (MAX_TEXTURE_SIZE != null) {
                    return MAX_TEXTURE_SIZE;
                }
                MAX_TEXTURE_SIZE =
                    callAndCheck(gl, function () {
                        return gl.getParameter(gl.MAX_TEXTURE_SIZE);
                    });
                return MAX_TEXTURE_SIZE;
            }

            exports.queryMaxTextureSize = queryMaxTextureSize;

            function getChannelsPerTexture() {
                if (!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {
                    return 4;
                }
                if (environment_1.ENV.get('WEBGL_VERSION') === 2) {
                    return 1;
                }
                return 4;
            }

            exports.getChannelsPerTexture = getChannelsPerTexture;

            function createTexture(gl) {
                return throwIfNull(gl, function () {
                    return gl.createTexture();
                }, 'Unable to create WebGLTexture.');
            }

            exports.createTexture = createTexture;

            function validateTextureSize(gl, width, height) {
                var maxTextureSize = queryMaxTextureSize(gl);
                if ((width <= 0) || (height <= 0)) {
                    var requested = "[" + width + "x" + height + "]";
                    throw new Error('Requested texture size ' + requested + ' is invalid.');
                }
                if ((width > maxTextureSize) || (height > maxTextureSize)) {
                    var requested = "[" + width + "x" + height + "]";
                    var max = "[" + maxTextureSize + "x" + maxTextureSize + "]";
                    throw new Error('Requested texture size ' + requested +
                        ' greater than WebGL maximum on this browser / GPU ' + max + '.');
                }
            }

            exports.validateTextureSize = validateTextureSize;

            function createFramebuffer(gl) {
                return throwIfNull(gl, function () {
                    return gl.createFramebuffer();
                }, 'Unable to create WebGLFramebuffer.');
            }

            exports.createFramebuffer = createFramebuffer;

            function bindVertexBufferToProgramAttribute(gl, program, attribute, buffer, arrayEntriesPerItem, itemStrideInBytes, itemOffsetInBytes, attribLocations) {
                var loc = -1;
                if ((attribLocations != null) && (attribute in attribLocations)) {
                    loc = attribLocations[attribute];
                } else {
                    loc = gl.getAttribLocation(program, attribute);
                }
                if (loc === -1) {
                    return;
                }
                callAndCheck(gl, function () {
                    return gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                });
                callAndCheck(gl, function () {
                    return gl.vertexAttribPointer(loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes, itemOffsetInBytes);
                });
                callAndCheck(gl, function () {
                    return gl.enableVertexAttribArray(loc);
                });
            }

            exports.bindVertexBufferToProgramAttribute = bindVertexBufferToProgramAttribute;

            function bindTextureUnit(gl, texture, textureUnit) {
                validateTextureUnit(gl, textureUnit);
                callAndCheck(gl, function () {
                    return gl.activeTexture(gl.TEXTURE0 + textureUnit);
                });
                callAndCheck(gl, function () {
                    return gl.bindTexture(gl.TEXTURE_2D, texture);
                });
            }

            exports.bindTextureUnit = bindTextureUnit;

            function unbindTextureUnit(gl, textureUnit) {
                validateTextureUnit(gl, textureUnit);
                callAndCheck(gl, function () {
                    return gl.activeTexture(gl.TEXTURE0 + textureUnit);
                });
                callAndCheck(gl, function () {
                    return gl.bindTexture(gl.TEXTURE_2D, null);
                });
            }

            exports.unbindTextureUnit = unbindTextureUnit;

            function getProgramUniformLocationOrThrow(gl, program, uniformName) {
                return throwIfNull(gl, function () {
                    return gl.getUniformLocation(program, uniformName);
                }, 'uniform "' + uniformName + '" not present in program.');
            }

            exports.getProgramUniformLocationOrThrow = getProgramUniformLocationOrThrow;

            function bindTextureToProgramUniformSampler(gl, program, texture, uniformSamplerLocation, textureUnit) {
                callAndCheck(gl, function () {
                    return bindTextureUnit(gl, texture, textureUnit);
                });
                callAndCheck(gl, function () {
                    return gl.uniform1i(uniformSamplerLocation, textureUnit);
                });
            }

            exports.bindTextureToProgramUniformSampler = bindTextureToProgramUniformSampler;

            function bindCanvasToFramebuffer(gl) {
                callAndCheck(gl, function () {
                    return gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                });
                callAndCheck(gl, function () {
                    return gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
                });
                callAndCheck(gl, function () {
                    return gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
                });
            }

            exports.bindCanvasToFramebuffer = bindCanvasToFramebuffer;

            function bindColorTextureToFramebuffer(gl, texture, framebuffer) {
                callAndCheck(gl, function () {
                    return gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
                });
                callAndCheck(gl, function () {
                    return gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
                });
            }

            exports.bindColorTextureToFramebuffer = bindColorTextureToFramebuffer;

            function unbindColorTextureFromFramebuffer(gl, framebuffer) {
                callAndCheck(gl, function () {
                    return gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
                });
                callAndCheck(gl, function () {
                    return gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0);
                });
            }

            exports.unbindColorTextureFromFramebuffer = unbindColorTextureFromFramebuffer;

            function validateFramebuffer(gl) {
                var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
                if (status !== gl.FRAMEBUFFER_COMPLETE) {
                    throw new Error('Error binding framebuffer: ' + getFramebufferErrorMessage(gl, status));
                }
            }

            exports.validateFramebuffer = validateFramebuffer;

            function getFramebufferErrorMessage(gl, status) {
                switch (status) {
                    case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                        return 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT';
                    case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                        return 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT';
                    case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                        return 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS';
                    case gl.FRAMEBUFFER_UNSUPPORTED:
                        return 'FRAMEBUFFER_UNSUPPORTED';
                    default:
                        return "unknown error " + status;
                }
            }

            exports.getFramebufferErrorMessage = getFramebufferErrorMessage;

            function throwIfNull(gl, returnTOrNull, failureMessage) {
                var tOrNull = callAndCheck(gl, function () {
                    return returnTOrNull();
                });
                if (tOrNull == null) {
                    throw new Error(failureMessage);
                }
                return tOrNull;
            }

            function validateTextureUnit(gl, textureUnit) {
                var maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;
                var glTextureUnit = textureUnit + gl.TEXTURE0;
                if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {
                    var textureUnitRange = "[gl.TEXTURE0, gl.TEXTURE" + maxTextureUnit + "]";
                    throw new Error("textureUnit must be in " + textureUnitRange + ".");
                }
            }

            function getTextureShapeFromLogicalShape(gl, logShape) {
                if (logShape.length !== 2) {
                    var squeezeResult = util.squeezeShape(logShape);
                    logShape = squeezeResult.newShape;
                }
                var maxTexSize = queryMaxTextureSize(gl);
                var size = util.sizeFromShape(logShape);
                if (logShape.length <= 1 && size <= maxTexSize) {
                    return [size, 1];
                } else if (logShape.length === 2 && logShape[0] <= maxTexSize &&
                    logShape[1] <= maxTexSize) {
                    return logShape;
                } else if (logShape.length === 3 && logShape[0] <= maxTexSize &&
                    logShape[1] * logShape[2] <= maxTexSize) {
                    return [logShape[0], logShape[1] * logShape[2]];
                } else if (logShape.length === 4 && logShape[0] <= maxTexSize &&
                    logShape[1] * logShape[2] * logShape[3] <= maxTexSize) {
                    return [logShape[0], logShape[1] * logShape[2] * logShape[3]];
                } else {
                    return util.sizeToSquarishShape(size);
                }
            }

            exports.getTextureShapeFromLogicalShape = getTextureShapeFromLogicalShape;

        }, {"../../../environment": 15, "../../../util": 101}],
        90: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});

            function getBroadcastDims(inShape, outShape) {
                var inRank = inShape.length;
                var dims = [];
                for (var i = 0; i < inRank; i++) {
                    var dim = inRank - 1 - i;
                    var a = inShape[dim] || 1;
                    var b = outShape[outShape.length - 1 - i] || 1;
                    if (b > 1 && a === 1) {
                        dims.unshift(dim);
                    }
                }
                return dims;
            }

            exports.getBroadcastDims = getBroadcastDims;

            function broadcastDimsAreOuter(dims) {
                for (var i = 0; i < dims.length; i++) {
                    if (dims[i] !== i) {
                        return false;
                    }
                }
                return true;
            }

            exports.broadcastDimsAreOuter = broadcastDimsAreOuter;

            function assertAndGetBroadcastShape(shapeA, shapeB) {
                var result = [];
                var errMsg = "Operands could not be broadcast together with shapes " +
                    (shapeA + " and " + shapeB + ".");
                var l = Math.max(shapeA.length, shapeB.length);
                for (var i = 0; i < l; i++) {
                    var a = shapeA[shapeA.length - i - 1] || 1;
                    var b = shapeB[shapeB.length - i - 1] || 1;
                    if (a > 1 && b > 1 && a !== b) {
                        throw Error(errMsg);
                    }
                    result.unshift(Math.max(a, b));
                }
                return result;
            }

            exports.assertAndGetBroadcastShape = assertAndGetBroadcastShape;

        }, {}],
        91: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var util = require("../util");

            function assertParams(aShape, bShape, axis) {
                var aRank = aShape.length;
                var bRank = bShape.length;
                util.assert(aShape.length === bShape.length, "Error in concat" + aRank + "D: rank of x1 (" + aRank + ") and x2 (" + bRank + ") " +
                    "must be the same.");
                util.assert(axis >= 0 && axis < aRank, "Error in concat" + aRank + "D: axis must be " +
                    ("between 0 and " + (aRank - 1) + "."));
                for (var i = 0; i < aRank; i++) {
                    util.assert((i === axis) || (aShape[i] === bShape[i]), "Error in concat" + aRank + "D: Shape (" + aShape + ") does not match " +
                        ("(" + bShape + ") along the non-concatenated axis " + i + "."));
                }
            }

            exports.assertParams = assertParams;

            function computeOutShape(x1Shape, x2Shape, axis) {
                util.assert(x1Shape.length === x2Shape.length, 'x1 and x2 should have the same rank.');
                var outputShape = x1Shape.slice();
                outputShape[axis] += x2Shape[axis];
                return outputShape;
            }

            exports.computeOutShape = computeOutShape;

        }, {"../util": 101}],
        92: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var util = require("../util");

            function computePool2DInfo(inShape, filterSize, strides, pad, dataFormat) {
                if (dataFormat === void 0) {
                    dataFormat = 'channelsLast';
                }
                var _a = parseTupleParam(filterSize), filterHeight = _a[0], filterWidth = _a[1];
                var filterShape;
                if (dataFormat === 'channelsLast') {
                    filterShape = [filterHeight, filterWidth, inShape[3], inShape[3]];
                } else if (dataFormat === 'channelsFirst') {
                    filterShape = [filterHeight, filterWidth, inShape[1], inShape[1]];
                } else {
                    throw new Error("Unknown dataFormat " + dataFormat);
                }
                return computeConv2DInfo(inShape, filterShape, strides, pad, false, dataFormat);
            }

            exports.computePool2DInfo = computePool2DInfo;

            function computeConv2DInfo(inShape, filterShape, strides, pad, depthwise, dataFormat) {
                if (depthwise === void 0) {
                    depthwise = false;
                }
                if (dataFormat === void 0) {
                    dataFormat = 'channelsLast';
                }
                var _a = [-1, -1, -1, -1], batchSize = _a[0], inHeight = _a[1], inWidth = _a[2], inChannels = _a[3];
                if (dataFormat === 'channelsLast') {
                    batchSize = inShape[0], inHeight = inShape[1], inWidth = inShape[2], inChannels = inShape[3];
                } else if (dataFormat === 'channelsFirst') {
                    batchSize = inShape[0], inChannels = inShape[1], inHeight = inShape[2], inWidth = inShape[3];
                } else {
                    throw new Error("Unknown dataFormat " + dataFormat);
                }
                var filterHeight = filterShape[0], filterWidth = filterShape[1], filterChannels = filterShape[3];
                var _b = parseTupleParam(strides), strideHeight = _b[0], strideWidth = _b[1];
                var _c = getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth),
                    padInfo = _c.padInfo, outHeight = _c.outHeight, outWidth = _c.outWidth;
                var outChannels = depthwise ? filterChannels * inChannels : filterChannels;
                var outShape;
                if (dataFormat === 'channelsFirst') {
                    outShape = [batchSize, outChannels, outHeight, outWidth];
                } else if (dataFormat === 'channelsLast') {
                    outShape = [batchSize, outHeight, outWidth, outChannels];
                }
                return {
                    batchSize: batchSize,
                    dataFormat: dataFormat,
                    inHeight: inHeight,
                    inWidth: inWidth,
                    inChannels: inChannels,
                    outHeight: outHeight,
                    outWidth: outWidth,
                    outChannels: outChannels,
                    padInfo: padInfo,
                    strideHeight: strideHeight,
                    strideWidth: strideWidth,
                    filterHeight: filterHeight,
                    filterWidth: filterWidth,
                    inShape: inShape,
                    outShape: outShape,
                    filterShape: filterShape
                };
            }

            exports.computeConv2DInfo = computeConv2DInfo;

            function computeOutputShape3D(inShape, fieldSize, outDepth, stride, zeroPad) {
                if (zeroPad == null) {
                    zeroPad = computeDefaultPad(inShape, fieldSize, stride);
                }
                var inputRows = inShape[0];
                var inputCols = inShape[1];
                var outputRows = (inputRows - fieldSize + 2 * zeroPad) / stride + 1;
                util.assert(util.isInt(outputRows), "The output # of rows (" + outputRows + ") must be an integer. Change the " +
                    "stride and/or zero pad parameters");
                var outputCols = (inputCols - fieldSize + 2 * zeroPad) / stride + 1;
                util.assert(util.isInt(outputCols), "The output # of columns (" + outputCols + ") must be an integer. Change " +
                    "the stride and/or zero pad parameters");
                return [outputRows, outputCols, outDepth];
            }

            exports.computeOutputShape3D = computeOutputShape3D;

            function computeDefaultPad(inputShape, fieldSize, stride) {
                return Math.floor((inputShape[0] * (stride - 1) - stride + fieldSize) / 2);
            }

            exports.computeDefaultPad = computeDefaultPad;

            function computeWeightsShape4D(inputDepth, outputDepth, filterHeight, filterWidth) {
                return [filterHeight, filterWidth, inputDepth, outputDepth];
            }

            exports.computeWeightsShape4D = computeWeightsShape4D;

            function computeDilatedRC(rc, origStride) {
                var rowsDilated = (rc[0] - 1) * origStride + 1;
                var colsDilated = (rc[1] - 1) * origStride + 1;
                return [rowsDilated, colsDilated];
            }

            exports.computeDilatedRC = computeDilatedRC;

            function parseTupleParam(param) {
                return typeof param === 'number' ? [param, param] : param;
            }

            function getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth) {
                var padInfo;
                var outHeight;
                var outWidth;
                if (typeof pad === 'number') {
                    padInfo = {top: pad, bottom: pad, left: pad, right: pad};
                    var outShape = computeOutputShape3D([inHeight, inWidth, 1], filterHeight, 1, strideHeight, pad);
                    outHeight = outShape[0];
                    outWidth = outShape[1];
                } else if (pad === 'same') {
                    outHeight = Math.ceil(inHeight / strideHeight);
                    outWidth = Math.ceil(inWidth / strideWidth);
                    var padAlongHeight = (outHeight - 1) * strideHeight + filterHeight - inHeight;
                    var padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;
                    var top_1 = Math.floor(padAlongHeight / 2);
                    var bottom = padAlongHeight - top_1;
                    var left = Math.floor(padAlongWidth / 2);
                    var right = padAlongWidth - left;
                    padInfo = {top: top_1, bottom: bottom, left: left, right: right};
                } else if (pad === 'valid') {
                    padInfo = {top: 0, bottom: 0, left: 0, right: 0};
                    outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);
                    outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);
                } else {
                    throw Error("Unknown padding parameter: " + pad);
                }
                return {padInfo: padInfo, outHeight: outHeight, outWidth: outWidth};
            }

        }, {"../util": 101}],
        93: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var environment_1 = require("../environment");
            var ndarray_1 = require("./ndarray");
            var SquareCostFunc = (function () {
                function SquareCostFunc() {
                    this.halfOne = environment_1.ENV.math.keep(ndarray_1.Scalar.new(0.5));
                }

                SquareCostFunc.prototype.cost = function (math, x1, x2) {
                    var diff = math.subStrict(x1, x2);
                    var diffSquared = math.elementWiseMul(diff, diff);
                    var result = math.scalarTimesArray(this.halfOne, diffSquared);
                    diff.dispose();
                    diffSquared.dispose();
                    return result;
                };
                SquareCostFunc.prototype.der = function (math, x1, x2) {
                    return math.subStrict(x1, x2);
                };
                SquareCostFunc.prototype.dispose = function () {
                    this.halfOne.dispose();
                };
                return SquareCostFunc;
            }());
            exports.SquareCostFunc = SquareCostFunc;

        }, {"../environment": 15, "./ndarray": 95}],
        94: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var environment_1 = require("../environment");
            var util = require("../util");
            var axis_util = require("./axis_util");
            var backend_engine_1 = require("./backends/backend_engine");
            var matmul_1 = require("./backends/types/matmul");
            var broadcast_util = require("./broadcast_util");
            var concat_util = require("./concat_util");
            var conv_util = require("./conv_util");
            var ndarray_1 = require("./ndarray");
            var slice_util = require("./slice_util");
            var NDArrayMath = (function () {
                function NDArrayMath(backend, safeMode) {
                    this.safeMode = safeMode;
                    this.numArrays = 0;
                    this.customBackend = false;
                    this.ndarrayScopes = [];
                    this.ndarraysToKeep = [];
                    this.activeScopeNDArraysToKeep = [];
                    if (typeof backend === 'string') {
                        this.backend = environment_1.ENV.getBackend(backend);
                    } else {
                        this.customBackend = true;
                        this.backend = backend;
                    }
                    this.backendEngine = new backend_engine_1.BackendEngine(this.backend);
                }

                NDArrayMath.prototype.time = function (query) {
                    return this.backend.time(query);
                };
                NDArrayMath.prototype.getNumArrays = function () {
                    return this.numArrays;
                };
                NDArrayMath.prototype.register = function (a) {
                    this.track(a);
                    this.numArrays++;
                };
                NDArrayMath.prototype.writePixels = function (id, pixels, numChannels) {
                    this.backend.writePixels(id, pixels, numChannels);
                };
                NDArrayMath.prototype.write = function (id, values, dtype, shape) {
                    this.backend.write(id, values, dtype, shape);
                };
                NDArrayMath.prototype.readSync = function (id) {
                    return this.backend.readSync(id);
                };
                NDArrayMath.prototype.read = function (id) {
                    return this.backend.read(id);
                };
                NDArrayMath.prototype.scope = function (scopeFn) {
                    var _this = this;
                    this.startScope();
                    var keepFn = function (ndarray) {
                        return _this.keep(ndarray);
                    };
                    var trackFn = function (ndarray) {
                        return ndarray;
                    };
                    var result = scopeFn(keepFn, trackFn);
                    if (result instanceof Promise) {
                        result.then(function (r) {
                            return _this.endScope(r);
                        });
                        return result;
                    } else {
                        this.endScope(result);
                        return result;
                    }
                };
                NDArrayMath.prototype.enableDebugMode = function () {
                    this.backendEngine.enableDebugMode();
                    console.warn('Debugging mode is ON. The output of every math call will ' +
                        'be downloaded to CPU and checked for NaNs. ' +
                        'This significantly impacts performance.');
                };
                NDArrayMath.prototype.startScope = function () {
                    var newScope = [];
                    this.ndarrayScopes.push(newScope);
                    this.activeScope = newScope;
                    var newNDArraysToKeep = [];
                    this.ndarraysToKeep.push(newNDArraysToKeep);
                    this.activeScopeNDArraysToKeep = newNDArraysToKeep;
                };
                NDArrayMath.prototype.extractNDArraysFromScopeResult = function (result) {
                    if (result == null) {
                        return [];
                    }
                    if (result instanceof ndarray_1.NDArray) {
                        return [result];
                    }
                    var list = [];
                    var resultObj = result;
                    for (var k in resultObj) {
                        var val = resultObj[k];
                        if (val instanceof ndarray_1.NDArray) {
                            list.push(val);
                        }
                    }
                    return list;
                };
                NDArrayMath.prototype.endScope = function (result) {
                    var _this = this;
                    var arraysToKeep = this.activeScopeNDArraysToKeep;
                    var resultArrays = this.extractNDArraysFromScopeResult(result);
                    arraysToKeep = arraysToKeep.concat(resultArrays);
                    for (var i = 0; i < this.activeScope.length; i++) {
                        var ndarray = this.activeScope[i];
                        if (this.isNDArrayDataInList(ndarray, arraysToKeep)) {
                            continue;
                        }
                        ndarray.dispose();
                    }
                    this.ndarrayScopes.pop();
                    this.activeScope = this.ndarrayScopes.length === 0 ?
                        null :
                        this.ndarrayScopes[this.ndarrayScopes.length - 1];
                    resultArrays.forEach(function (val) {
                        if (!_this.isNDArrayDataInList(val, _this.activeScopeNDArraysToKeep)) {
                            _this.track(val);
                        }
                    });
                    this.ndarraysToKeep.pop();
                    this.activeScopeNDArraysToKeep = this.ndarraysToKeep.length === 0 ?
                        null :
                        this.ndarraysToKeep[this.ndarraysToKeep.length - 1];
                };
                NDArrayMath.prototype.isNDArrayDataInList = function (ndarray, ndarrayList) {
                    for (var i = 0; i < ndarrayList.length; i++) {
                        if (ndarrayList[i].id === ndarray.id) {
                            return true;
                        }
                    }
                    return false;
                };
                NDArrayMath.prototype.keep = function (result) {
                    if (this.activeScope == null) {
                        if (this.safeMode) {
                            throw new Error('You are using math in safe mode. Enclose all ' +
                                'math.method() calls inside a scope: ' +
                                'math.scope(() => {math.method();...}) to avoid memory ' +
                                'leaks.');
                        }
                        return result;
                    }
                    this.activeScopeNDArraysToKeep.push(result);
                    return result;
                };
                NDArrayMath.prototype.track = function (result) {
                    if (this.activeScope == null) {
                        if (this.safeMode) {
                            throw new Error('You are using math in safe mode. Enclose all ' +
                                'math.method() calls inside a scope: ' +
                                'math.scope(() => {math.method();...}) to avoid memory ' +
                                'leaks.');
                        }
                        return result;
                    }
                    this.activeScope.push(result);
                    return result;
                };
                NDArrayMath.prototype.dispose = function () {
                    if (this.customBackend) {
                        this.backend.dispose();
                    }
                };
                NDArrayMath.prototype.matMul = function (a, b, aOrientation, bOrientation) {
                    var _this = this;
                    if (aOrientation === void 0) {
                        aOrientation = matmul_1.MatrixOrientation.REGULAR;
                    }
                    if (bOrientation === void 0) {
                        bOrientation = matmul_1.MatrixOrientation.REGULAR;
                    }
                    var innerShapeA = (aOrientation === matmul_1.MatrixOrientation.REGULAR) ? a.shape[1] : a.shape[0];
                    var innerShapeB = (bOrientation === matmul_1.MatrixOrientation.REGULAR) ? b.shape[0] : b.shape[1];
                    util.assert(a.rank === 2 && b.rank === 2, "Error in matMul: inputs must be rank 2, got ranks " + a.rank +
                        (" and " + b.rank + "."));
                    util.assert(innerShapeA === innerShapeB, "Error in matMul: inner shapes (" + innerShapeA + ") and (" +
                        (innerShapeB + ") of NDArrays with shapes " + a.shape + " and ") +
                        (b.shape + " and orientations " + matmul_1.MatrixOrientation[aOrientation]) +
                        (" and " + matmul_1.MatrixOrientation[bOrientation] + " must match."));
                    return this.backendEngine.executeKernel('MatMul', {
                        inputs: {a: a, b: b},
                        args: {aOrientation: aOrientation, bOrientation: bOrientation}
                    }, function (dy, y) {
                        return {
                            a: function () {
                                return _this.matMul(dy, b, matmul_1.MatrixOrientation.REGULAR, matmul_1.MatrixOrientation.TRANSPOSED);
                            },
                            b: function () {
                                return _this.matMul(a, dy, matmul_1.MatrixOrientation.TRANSPOSED, matmul_1.MatrixOrientation.REGULAR);
                            }
                        };
                    });
                };
                NDArrayMath.prototype.executeOp = function (name, f) {
                    return f();
                };
                NDArrayMath.prototype.vectorTimesMatrix = function (v, matrix) {
                    util.assert(v.rank === 1, "Error in vectorTimesMatrix: first input must be rank 1, but got " +
                        ("rank " + v.rank + "."));
                    util.assert(matrix.rank === 2, "Error in vectorTimesMatrix: second input must be rank 2, but got " +
                        ("rank " + matrix.rank + "."));
                    util.assert(v.size === matrix.shape[0], "Error in vectorTimesMatrix: size of vector (" + v.size + ") " +
                        ("must match first dimension of matrix (" + matrix.shape[0] + ")"));
                    return this.matMul(v.as2D(1, -1), matrix).as1D();
                };
                NDArrayMath.prototype.matrixTimesVector = function (matrix, v) {
                    util.assert(v.rank === 1, "Error in matrixTimesVector: second input must rank 1, but got " +
                        ("rank " + v.rank + "."));
                    util.assert(matrix.rank === 2, "Error in matrixTimesVector: first input must be a rank 2, but got " +
                        ("rank " + matrix.rank + "."));
                    util.assert(v.size === matrix.shape[1], "Error in matrixTimesVector: size of first rank 1 input " + v.size + " " +
                        "must match inner dimension of second rank 2 input, but got " +
                        ("shape " + matrix.shape + "."));
                    return this.matMul(matrix, v.as2D(-1, 1)).as1D();
                };
                NDArrayMath.prototype.dotProduct = function (v1, v2) {
                    util.assert(v1.rank === 1 && v2.rank === 1, "Error in dotProduct: inputs must be rank 1, but got ranks " +
                        (v1.rank + " and " + v2.rank + "."));
                    util.assert(v1.size === v2.size, "Error in dotProduct: size of inputs (" + v1.size + ") and (" +
                        (v2.size + ") must match."));
                    return this.matMul(v1.as2D(1, -1), v2.as2D(-1, 1)).asScalar();
                };
                NDArrayMath.prototype.outerProduct = function (v1, v2) {
                    util.assert(v1.rank === 1 && v2.rank === 1, "Error in outerProduct: inputs must be rank 1, but got ranks " +
                        (v1.rank + " and " + v2.rank + "."));
                    return this.matMul(v1.as2D(-1, 1), v2.as2D(1, -1));
                };
                NDArrayMath.prototype.clone = function (x) {
                    return this.backendEngine.executeKernel('Clone', {inputs: {x: x}});
                };
                NDArrayMath.prototype.reshape = function (ndarray, newShape) {
                    console.warn('math.reshape() is deprecated. Please call reshape() ' +
                        'directly on the ndarray object');
                    return ndarray.reshape(newShape);
                };
                NDArrayMath.prototype.slice1D = function (x, begin, size) {
                    slice_util.assertParamsValid(x, [begin], [size]);
                    return this.backendEngine.executeKernel('Slice1D', {
                        inputs: {x: x},
                        args: {begin: begin, size: size}
                    });
                };
                NDArrayMath.prototype.slice2D = function (x, begin, size) {
                    slice_util.assertParamsValid(x, begin, size);
                    return this.backendEngine.executeKernel('Slice2D', {
                        inputs: {x: x},
                        args: {begin: begin, size: size}
                    });
                };
                NDArrayMath.prototype.slice3D = function (x, begin, size) {
                    slice_util.assertParamsValid(x, begin, size);
                    return this.backendEngine.executeKernel('Slice3D', {
                        inputs: {x: x},
                        args: {begin: begin, size: size}
                    });
                };
                NDArrayMath.prototype.slice4D = function (x, begin, size) {
                    slice_util.assertParamsValid(x, begin, size);
                    return this.backendEngine.executeKernel('Slice4D', {
                        inputs: {x: x},
                        args: {begin: begin, size: size}
                    });
                };
                NDArrayMath.prototype.concat1D = function (a, b) {
                    concat_util.assertParams(a.shape, b.shape, 0);
                    return this.backendEngine.executeKernel('Concat1D', {inputs: {a: a, b: b}});
                };
                NDArrayMath.prototype.concat2D = function (a, b, axis) {
                    concat_util.assertParams(a.shape, b.shape, axis);
                    return this.backendEngine.executeKernel('Concat2D', {inputs: {a: a, b: b}, args: {axis: axis}});
                };
                NDArrayMath.prototype.concat3D = function (a, b, axis) {
                    concat_util.assertParams(a.shape, b.shape, axis);
                    return this.backendEngine.executeKernel('Concat3D', {inputs: {a: a, b: b}, args: {axis: axis}});
                };
                NDArrayMath.prototype.concat4D = function (a, b, axis) {
                    concat_util.assertParams(a.shape, b.shape, axis);
                    return this.backendEngine.executeKernel('Concat4D', {inputs: {a: a, b: b}, args: {axis: axis}});
                };
                NDArrayMath.prototype.logSumExp = function (input, axis, keepDims) {
                    var _this = this;
                    if (axis === void 0) {
                        axis = null;
                    }
                    if (keepDims === void 0) {
                        keepDims = false;
                    }
                    var axes = axis_util.parseAxisParam(axis, input.shape);
                    return this.executeOp('logSumExp', function () {
                        var xMax = _this.max(input, axes, true);
                        var a = _this.subtract(input, xMax);
                        var b = _this.exp(a);
                        var c = _this.sum(b, axes);
                        var d = _this.log(c);
                        var res = _this.add(xMax.reshape(d.shape), d);
                        if (keepDims) {
                            var newShape = axis_util.expandShapeToKeepDim(res.shape, axes);
                            return res.reshape(newShape);
                        }
                        return res;
                    });
                };
                NDArrayMath.prototype.sum = function (x, axis, keepDims) {
                    var _this = this;
                    if (axis === void 0) {
                        axis = null;
                    }
                    if (keepDims === void 0) {
                        keepDims = false;
                    }
                    var origAxes = axis_util.parseAxisParam(axis, x.shape);
                    var axes = origAxes;
                    var permutedAxes = axis_util.getPermutedAxes(axes, x.rank);
                    return this.executeOp('sum', function () {
                        if (permutedAxes != null) {
                            x = _this.transpose(x, permutedAxes);
                            axes = axis_util.getInnerMostAxes(axes.length, x.rank);
                        }
                        var res = _this.backendEngine.executeKernel('Sum', {
                            inputs: {x: x},
                            args: {axes: axes}
                        }, function (dy, y) {
                            return {
                                x: function () {
                                    if (axis != null) {
                                        throw new Error("Gradients for sum with axis reduction not yet " +
                                            "supported.");
                                    }
                                    return _this.multiply(dy, ndarray_1.NDArray.onesLike(x));
                                }
                            };
                        });
                        if (keepDims) {
                            var newShape = axis_util.expandShapeToKeepDim(res.shape, origAxes);
                            return res.reshape(newShape);
                        }
                        return res;
                    });
                };
                NDArrayMath.prototype.mean = function (x, axis, keepDims) {
                    var _this = this;
                    if (axis === void 0) {
                        axis = null;
                    }
                    if (keepDims === void 0) {
                        keepDims = false;
                    }
                    var axes = axis_util.parseAxisParam(axis, x.shape);
                    var shapes = axis_util.computeOutAndReduceShapes(x.shape, axes);
                    var reduceShape = shapes[1];
                    var reduceSize = util.sizeFromShape(reduceShape);
                    return this.executeOp('mean', function () {
                        return _this.scope(function (keep) {
                            var res = _this.divide(x, ndarray_1.Scalar.new(reduceSize));
                            return _this.sum(res, axis, keepDims);
                        });
                    });
                };
                NDArrayMath.prototype.argMin = function (x, axis) {
                    var _this = this;
                    if (axis === void 0) {
                        axis = null;
                    }
                    var axes = axis_util.parseAxisParam(axis, x.shape);
                    var permutedAxes = axis_util.getPermutedAxes(axes, x.rank);
                    return this.executeOp('argMin', function () {
                        if (permutedAxes != null) {
                            x = _this.transpose(x, permutedAxes);
                            axes = axis_util.getInnerMostAxes(axes.length, x.rank);
                        }
                        return _this.backendEngine.executeKernel('ArgMin', {inputs: {x: x}, args: {axes: axes}});
                    });
                };
                NDArrayMath.prototype.argMax = function (x, axis) {
                    var _this = this;
                    if (axis === void 0) {
                        axis = null;
                    }
                    var axes = axis_util.parseAxisParam(axis, x.shape);
                    var permutedAxes = axis_util.getPermutedAxes(axes, x.rank);
                    return this.executeOp('argMax', function () {
                        if (permutedAxes != null) {
                            x = _this.transpose(x, permutedAxes);
                            axes = axis_util.getInnerMostAxes(axes.length, x.rank);
                        }
                        return _this.backendEngine.executeKernel('ArgMax', {inputs: {x: x}, args: {axes: axes}});
                    });
                };
                NDArrayMath.prototype.argMaxEquals = function (x1, x2) {
                    var _this = this;
                    util.assertShapesMatch(x1.shape, x2.shape, 'Error in argMaxEquals: ');
                    return this.executeOp('argMaxEquals', function () {
                        return _this.scope(function () {
                            return _this.equal(_this.argMax(x1), _this.argMax(x2));
                        });
                    });
                };
                NDArrayMath.prototype.equal = function (a, b) {
                    return this.backendEngine.executeKernel('Equal', {inputs: {a: a, b: b}});
                };
                NDArrayMath.prototype.equalStrict = function (a, b) {
                    util.assertShapesMatch(a.shape, b.shape, 'Error in equalStrict: ');
                    return this.equal(a, b);
                };
                NDArrayMath.prototype.topK = function (x, k) {
                    var _this = this;
                    util.assert(k <= x.size, "Error in topK: k value (" + k + ") must be less than size of input " +
                        ("ndarray, got shape " + x.shape + "."));
                    var values;
                    var indices;
                    this.executeOp('topK', function () {
                        values = _this.backendEngine.executeKernel('TopKValues', {inputs: {x: x}, args: {k: k}});
                        indices = _this.backendEngine.executeKernel('TopKIndices', {inputs: {x: x}, args: {k: k}});
                        return values;
                    });
                    var result = {values: values, indices: indices};
                    return result;
                };
                NDArrayMath.prototype.min = function (x, axis, keepDims) {
                    var _this = this;
                    if (axis === void 0) {
                        axis = null;
                    }
                    if (keepDims === void 0) {
                        keepDims = false;
                    }
                    var origAxes = axis_util.parseAxisParam(axis, x.shape);
                    var axes = origAxes;
                    var permutedAxes = axis_util.getPermutedAxes(axes, x.rank);
                    return this.executeOp('min', function () {
                        if (permutedAxes != null) {
                            x = _this.transpose(x, permutedAxes);
                            axes = axis_util.getInnerMostAxes(axes.length, x.rank);
                        }
                        var res = _this.backendEngine.executeKernel('Min', {inputs: {x: x}, args: {axes: axes}});
                        if (keepDims) {
                            var newShape = axis_util.expandShapeToKeepDim(res.shape, origAxes);
                            return res.reshape(newShape);
                        }
                        return res;
                    });
                };
                NDArrayMath.prototype.max = function (x, axis, keepDims) {
                    var _this = this;
                    if (axis === void 0) {
                        axis = null;
                    }
                    if (keepDims === void 0) {
                        keepDims = false;
                    }
                    var origAxes = axis_util.parseAxisParam(axis, x.shape);
                    var axes = origAxes;
                    var permutedAxes = axis_util.getPermutedAxes(axes, x.rank);
                    return this.executeOp('max', function () {
                        if (permutedAxes != null) {
                            x = _this.transpose(x, permutedAxes);
                            axes = axis_util.getInnerMostAxes(axes.length, x.rank);
                        }
                        var res = _this.backendEngine.executeKernel('Max', {inputs: {x: x}, args: {axes: axes}});
                        if (keepDims) {
                            var newShape = axis_util.expandShapeToKeepDim(res.shape, origAxes);
                            return res.reshape(newShape);
                        }
                        return res;
                    });
                };
                NDArrayMath.prototype.softmax = function (logits, dim) {
                    var _this = this;
                    if (dim === void 0) {
                        dim = -1;
                    }
                    if (dim === -1) {
                        dim = logits.rank - 1;
                    }
                    if (dim !== logits.rank - 1) {
                        throw Error('Softmax along a non-last dimension is not yet supported. ' +
                            ("Logits was rank " + logits.rank + " and dim was " + dim));
                    }
                    return this.executeOp('softmax', function () {
                        return _this.scope(function () {
                            var lse = _this.logSumExp(logits, [dim], true);
                            var logResult = _this.subtract(logits, lse);
                            return _this.exp(logResult);
                        });
                    });
                };
                NDArrayMath.prototype.switchDim = function (a, newDim) {
                    return this.transpose(a, newDim);
                };
                NDArrayMath.prototype.tile = function (x, reps) {
                    util.assert(x.rank === reps.length, "Error in transpose: rank of input " + x.rank + " " +
                        ("must match length of reps " + reps + "."));
                    return this.backendEngine.executeKernel('Tile', {inputs: {x: x}, args: {reps: reps}});
                };
                NDArrayMath.prototype.transpose = function (x, perm) {
                    if (perm == null) {
                        perm = x.shape.map(function (s, i) {
                            return i;
                        }).reverse();
                    }
                    util.assert(x.rank === perm.length, "Error in transpose: rank of input " + x.rank + " " +
                        ("must match length of perm " + perm + "."));
                    return this.backendEngine.executeKernel('Transpose', {inputs: {x: x}, args: {perm: perm}});
                };
                NDArrayMath.prototype.scalarPlusArray = function (c, a) {
                    util.assert(c.size === 1, "Error in scalarPlusArray: first argument must be rank 0, but got " +
                        ("rank " + c.rank + "."));
                    return this.add(c, a);
                };
                NDArrayMath.prototype.scalarMinusArray = function (c, a) {
                    util.assert(c.size === 1, "Error in scalarMinusArray: first argument must be rank 0, but got " +
                        ("rank " + c.rank + "."));
                    return this.subtract(c, a);
                };
                NDArrayMath.prototype.arrayMinusScalar = function (a, c) {
                    util.assert(c.size === 1, "Error in arrayMinusScalar: second argument must be rank 0, but " +
                        ("got rank " + c.rank + "."));
                    return this.subtract(a, c);
                };
                NDArrayMath.prototype.neg = function (x) {
                    return this.backendEngine.executeKernel('Neg', {inputs: {x: x}});
                };
                NDArrayMath.prototype.add = function (a, b) {
                    broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
                    return this.backendEngine.executeKernel('Add', {inputs: {a: a, b: b}});
                };
                NDArrayMath.prototype.addStrict = function (a, b) {
                    util.assertShapesMatch(a.shape, b.shape, 'Error in addStrict: ');
                    return this.add(a, b);
                };
                NDArrayMath.prototype.subtract = function (a, b) {
                    broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
                    return this.backendEngine.executeKernel('Sub', {inputs: {a: a, b: b}});
                };
                NDArrayMath.prototype.pow = function (a, b) {
                    util.assert(b.dtype === 'int32', 'only supports int32 data type for the exponent parameter.');
                    broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
                    return this.backendEngine.executeKernel('Pow', {inputs: {a: a, b: b}});
                };
                NDArrayMath.prototype.powStrict = function (a, b) {
                    util.assertShapesMatch(a.shape, b.shape, 'Error in powStrict: ');
                    return this.pow(a, b);
                };
                NDArrayMath.prototype.sub = function (a, b) {
                    return this.subtract(a, b);
                };
                NDArrayMath.prototype.subStrict = function (a, b) {
                    util.assertShapesMatch(a.shape, b.shape, 'Error in subStrict: ');
                    return this.subtract(a, b);
                };
                NDArrayMath.prototype.multiply = function (a, b) {
                    broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
                    return this.backendEngine.executeKernel('Mul', {inputs: {a: a, b: b}});
                };
                NDArrayMath.prototype.elementWiseMul = function (a, b) {
                    return this.multiplyStrict(a, b);
                };
                NDArrayMath.prototype.multiplyStrict = function (a, b) {
                    util.assertShapesMatch(a.shape, b.shape, 'Error in multiplyStrict: ');
                    return this.multiply(a, b);
                };
                NDArrayMath.prototype.divide = function (a, b) {
                    broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
                    return this.backendEngine.executeKernel('Div', {inputs: {a: a, b: b}});
                };
                NDArrayMath.prototype.divideStrict = function (a, b) {
                    util.assertShapesMatch(a.shape, b.shape, 'Error in divideStrict: ');
                    return this.divide(a, b);
                };
                NDArrayMath.prototype.scalarDividedByArray = function (c, a) {
                    util.assert(c.size === 1, "Error in scalarDividedByArray: first argument must be rank 0, but " +
                        ("got NDArray of rank " + c.rank + "."));
                    return this.divide(c, a);
                };
                NDArrayMath.prototype.arrayDividedByScalar = function (a, c) {
                    util.assert(c.size === 1, "Error in arrayDividedByScalar: second argument must be rank 0, " +
                        ("but got NDArray of rank " + c.rank + "."));
                    return this.divide(a, c);
                };
                NDArrayMath.prototype.ceil = function (x) {
                    return this.backendEngine.executeKernel('Ceil', {inputs: {x: x}});
                };
                NDArrayMath.prototype.floor = function (x) {
                    return this.backendEngine.executeKernel('Floor', {inputs: {x: x}});
                };
                NDArrayMath.prototype.exp = function (x) {
                    return this.backendEngine.executeKernel('Exp', {inputs: {x: x}});
                };
                NDArrayMath.prototype.log = function (x) {
                    return this.backendEngine.executeKernel('Log', {inputs: {x: x}});
                };
                NDArrayMath.prototype.sqrt = function (x) {
                    return this.backendEngine.executeKernel('Sqrt', {inputs: {x: x}});
                };
                NDArrayMath.prototype.square = function (x) {
                    return this.backendEngine.executeKernel('Square', {inputs: {x: x}});
                };
                NDArrayMath.prototype.abs = function (x) {
                    return this.backendEngine.executeKernel('Abs', {inputs: {x: x}});
                };
                NDArrayMath.prototype.clip = function (x, min, max) {
                    util.assert((min <= max), "Error in clip: min (" + min + ") must be" +
                        ("less than or equal to max (" + max + ")."));
                    return this.backendEngine.executeKernel('Clip', {inputs: {x: x}, args: {min: min, max: max}});
                };
                NDArrayMath.prototype.relu = function (x) {
                    var _this = this;
                    return this.backendEngine.executeKernel('Relu', {inputs: {x: x}}, function (dy, y) {
                        return {
                            x: function () {
                                return _this.step(x);
                            }
                        };
                    });
                };
                NDArrayMath.prototype.elu = function (x) {
                    return this.backendEngine.executeKernel('Elu', {inputs: {x: x}});
                };
                NDArrayMath.prototype.eluDer = function (x) {
                    return this.backendEngine.executeKernel('EluDer', {inputs: {x: x}});
                };
                NDArrayMath.prototype.selu = function (x) {
                    return this.backendEngine.executeKernel('Selu', {inputs: {x: x}});
                };
                NDArrayMath.prototype.leakyRelu = function (x, alpha) {
                    if (alpha === void 0) {
                        alpha = 0.2;
                    }
                    return this.backendEngine.executeKernel('LeakyRelu', {inputs: {x: x}, args: {alpha: alpha}});
                };
                NDArrayMath.prototype.prelu = function (x, alpha) {
                    return this.backendEngine.executeKernel('PReLU', {inputs: {x: x, alpha: alpha}});
                };
                NDArrayMath.prototype.preluDer = function (x, alpha) {
                    return this.backendEngine.executeKernel('PReLUDer', {inputs: {x: x, alpha: alpha}});
                };
                NDArrayMath.prototype.sigmoid = function (x) {
                    return this.backendEngine.executeKernel('Sigmoid', {inputs: {x: x}});
                };
                NDArrayMath.prototype.sin = function (x) {
                    return this.backendEngine.executeKernel('Sin', {inputs: {x: x}});
                };
                NDArrayMath.prototype.cos = function (x) {
                    return this.backendEngine.executeKernel('Cos', {inputs: {x: x}});
                };
                NDArrayMath.prototype.tan = function (x) {
                    return this.backendEngine.executeKernel('Tan', {inputs: {x: x}});
                };
                NDArrayMath.prototype.asin = function (x) {
                    return this.backendEngine.executeKernel('Asin', {inputs: {x: x}});
                };
                NDArrayMath.prototype.acos = function (x) {
                    return this.backendEngine.executeKernel('Acos', {inputs: {x: x}});
                };
                NDArrayMath.prototype.atan = function (x) {
                    return this.backendEngine.executeKernel('Atan', {inputs: {x: x}});
                };
                NDArrayMath.prototype.sinh = function (x) {
                    return this.backendEngine.executeKernel('Sinh', {inputs: {x: x}});
                };
                NDArrayMath.prototype.cosh = function (x) {
                    return this.backendEngine.executeKernel('Cosh', {inputs: {x: x}});
                };
                NDArrayMath.prototype.tanh = function (x) {
                    return this.backendEngine.executeKernel('Tanh', {inputs: {x: x}});
                };
                NDArrayMath.prototype.step = function (x, alpha) {
                    if (alpha === void 0) {
                        alpha = 0.0;
                    }
                    return this.backendEngine.executeKernel('Step', {inputs: {x: x}, args: {alpha: alpha}});
                };
                NDArrayMath.prototype.scaledArrayAdd = function (c1, a, c2, b) {
                    var _this = this;
                    util.assert(c1.size === 1, "Error in scaledArrayAdd: first argument must rank 0, but got " +
                        (" rank " + c1.rank + "."));
                    util.assert(c2.size === 1, "Error in scaledArrayAdd: third argument must be rank 0, but got " +
                        ("NDArray of rank " + c2.rank + "."));
                    util.assertShapesMatch(a.shape, b.shape, 'Error in scaledArrayAdd: ');
                    return this.executeOp('scaledArrayAdd', function () {
                        return _this.scope(function () {
                            return _this.add(_this.multiply(c1, a), _this.multiply(c2, b));
                        });
                    });
                };
                NDArrayMath.prototype.scalarTimesArray = function (c, a) {
                    util.assert(c.size === 1, "Error in arrayDividedByScalar: first argument must be rank 0, but " +
                        ("got rank " + c.rank + "."));
                    return this.multiply(c, a);
                };
                NDArrayMath.prototype.elementWiseMulBroadcast = function (a, b) {
                    util.assert(a.rank === 2, "Error in elementWiseMulBroadcast: first argument must be " +
                        ("rank 2, but got rank " + a.rank + "."));
                    util.assert(b.rank === 2, "Error in elementWiseMulBroadcast: second argument must be " +
                        ("rank 2, but got rank " + b.rank + "."));
                    return this.multiply(a, b);
                };
                NDArrayMath.prototype.conv1d = function (input, filter, bias, stride, pad) {
                    var _this = this;
                    var input3D = input;
                    var reshapedTo3D = false;
                    if (input.rank === 2) {
                        reshapedTo3D = true;
                        input3D = input.as3D(1, input.shape[0], input.shape[1]);
                    }
                    util.assert(input3D.rank === 3, "Error in conv1d: input must be rank 3, but got rank " + input3D.rank + ".");
                    util.assert(filter.rank === 3, "Error in conv1d: filter must be rank 3, but got rank " +
                        (filter.rank + "."));
                    if (bias != null) {
                        util.assert(bias.rank === 1, "Error in conv1d: bias must be rank 1, but got rank " +
                            (bias.rank + "."));
                    }
                    util.assert(input3D.shape[2] === filter.shape[1], "Error in conv1d: depth of input (" + input3D.shape[2] + ") must match  " +
                        ("input depth for filter " + filter.shape[1] + "."));
                    var filter4D = filter.as4D(1, filter.shape[0], filter.shape[1], filter.shape[2]);
                    var input4D = input3D.as4D(input3D.shape[0], 1, input3D.shape[1], input3D.shape[2]);
                    var strides = [1, stride];
                    return this.executeOp('Conv1D', function () {
                        var res = _this.conv2d(input4D, filter4D, bias, strides, pad);
                        if (reshapedTo3D) {
                            return res.as2D(res.shape[2], res.shape[3]);
                        }
                        return res.as3D(res.shape[0], res.shape[2], res.shape[3]);
                    });
                };
                NDArrayMath.prototype.conv2d = function (input, filter, bias, strides, pad) {
                    var _this = this;
                    var input4D = input;
                    var reshapedTo4D = false;
                    if (input.rank === 3) {
                        reshapedTo4D = true;
                        input4D = input.as4D(1, input.shape[0], input.shape[1], input.shape[2]);
                    }
                    util.assert(input4D.rank === 4, "Error in conv2d: input must be rank 4, but got rank " + input4D.rank + ".");
                    util.assert(filter.rank === 4, "Error in conv2d: filter must be rank 4, but got rank " +
                        (filter.rank + "."));
                    if (bias != null) {
                        util.assert(bias.rank === 1, "Error in conv2d: bias must be rank 1, but got rank " +
                            (bias.rank + "."));
                    }
                    util.assert(input4D.shape[3] === filter.shape[2], "Error in conv2d: depth of input (" + input4D.shape[3] + ") must match  " +
                        ("input depth for filter " + filter.shape[2] + "."));
                    var convInfo = conv_util.computeConv2DInfo(input4D.shape, filter.shape, strides, pad);
                    return this.executeOp('Conv2D', function () {
                        var res = _this.backendEngine.executeKernel('Conv2D', {
                            inputs: {
                                x: input4D,
                                filter: filter,
                                bias: bias
                            }, args: {convInfo: convInfo}
                        });
                        if (reshapedTo4D) {
                            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
                        }
                        return res;
                    });
                };
                NDArrayMath.prototype.conv2dDerInput = function (inShape, dy, filter, strides, pad) {
                    var _this = this;
                    util.assert(inShape.length === dy.rank, "Length of inShape " +
                        ("(" + inShape.length + ") and rank of dy (" + dy.rank + ") must match"));
                    var inShape4D = inShape;
                    var dy4D = dy;
                    var reshapedTo4D = false;
                    if (dy.rank === 3) {
                        reshapedTo4D = true;
                        dy4D = dy.as4D(1, dy.shape[0], dy.shape[1], dy.shape[2]);
                        inShape4D = [1, inShape[0], inShape[1], inShape[2]];
                    }
                    var inDepth = inShape4D[3];
                    var outDepth = dy4D.shape[3];
                    util.assert(inShape4D.length === 4, "Error in conv2dDerInput: inShape must be length 4, but got length " +
                        (inShape4D.length + "."));
                    util.assert(dy4D.rank === 4, "Error in conv2dDerInput: dy must be rank 4, but got " +
                        ("rank " + dy4D.rank));
                    util.assert(filter.rank === 4, "Error in conv2dDerInput: filter must be rank 4, but got " +
                        ("rank " + filter.rank));
                    util.assert(inDepth === filter.shape[2], "Error in conv2dDerInput: depth of input (" + inDepth + ") must " +
                        ("match input depth for filter " + filter.shape[2] + "."));
                    util.assert(outDepth === filter.shape[3], "Error in conv2dDerInput: depth of output (" + outDepth + ") must" +
                        ("match output depth for filter " + filter.shape[3] + "."));
                    var convInfo = conv_util.computeConv2DInfo(inShape4D, filter.shape, strides, pad);
                    return this.executeOp('conv2dDerInput', function () {
                        var res = _this.backendEngine.executeKernel('Conv2DDerInput', {
                            inputs: {
                                dy: dy4D,
                                filter: filter
                            }, args: {convInfo: convInfo}
                        });
                        if (reshapedTo4D) {
                            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
                        }
                        return res;
                    });
                };
                NDArrayMath.prototype.conv2dDerBias = function (dy) {
                    var dy4D = dy;
                    if (dy.rank === 3) {
                        dy4D = dy.as4D(1, dy.shape[0], dy.shape[1], dy.shape[2]);
                    }
                    return this.backendEngine.executeKernel('Conv2DDerBias', {inputs: {dy: dy4D}});
                };
                NDArrayMath.prototype.conv2dDerFilter = function (input, dy, filterShape, strides, pad) {
                    var input4D = input;
                    if (input.rank === 3) {
                        input4D = input.as4D(1, input.shape[0], input.shape[1], input.shape[2]);
                    }
                    var dy4D = dy;
                    if (dy4D.rank === 3) {
                        dy4D = dy.as4D(1, dy.shape[0], dy.shape[1], dy.shape[2]);
                    }
                    util.assert(input4D.rank === 4, "Error in conv2dDerFilter: input must be rank 4, but got shape " +
                        (input4D.shape + "."));
                    util.assert(dy4D.rank === 4, "Error in conv2dDerFilter: dy must be rank 4, but got shape " +
                        (dy4D.shape + "."));
                    util.assert(filterShape.length === 4, "Error in conv2dDerFilter: filterShape must be length 4, but got " +
                        (filterShape + "."));
                    util.assert(input4D.shape[3] === filterShape[2], "Error in conv2dDerFilter: depth of input " + input4D.shape[3] + ") must " +
                        ("match input depth in filter (" + filterShape[2] + "."));
                    util.assert(dy4D.shape[3] === filterShape[3], "Error in conv2dDerFilter: depth of dy (" + dy4D.shape[3] + ") must " +
                        ("match output depth for filter (" + filterShape[3] + ")."));
                    var convInfo = conv_util.computeConv2DInfo(input4D.shape, filterShape, strides, pad);
                    return this.backendEngine.executeKernel('Conv2DDerFilter', {
                        inputs: {x: input4D, dy: dy4D},
                        args: {convInfo: convInfo}
                    });
                };
                NDArrayMath.prototype.conv2dTranspose = function (x, filter, outputShape, strides, pad) {
                    return this.conv2dDerInput(outputShape, x, filter, strides, pad);
                };
                NDArrayMath.prototype.depthwiseConv2D = function (input, filter, strides, pad, rates) {
                    var _this = this;
                    if (rates === void 0) {
                        rates = [1, 1];
                    }
                    var input4D = input;
                    var reshapedTo4D = false;
                    if (input.rank === 3) {
                        reshapedTo4D = true;
                        input4D = input.as4D(1, input.shape[0], input.shape[1], input.shape[2]);
                    }
                    util.assert(input4D.rank === 4, "Error in depthwiseConv2D: input must be rank 4, but got " +
                        ("rank " + input4D.rank + "."));
                    util.assert(filter.rank === 4, "Error in depthwiseConv2D: filter must be rank 4, but got rank " +
                        (filter.rank + "."));
                    util.assert(input4D.shape[3] === filter.shape[2], "Error in depthwiseConv2D: number of input channels " +
                        ("(" + input4D.shape[3] + ") must match the inChannels dimension in ") +
                        ("filter " + filter.shape[2] + "."));
                    rates = rates || [1, 1];
                    var _a = parseTupleParam(rates), rateHeight = _a[0], rateWidth = _a[1];
                    util.assert(rateHeight === 1 && rateWidth === 1, 'Error in depthwiseConv2D: rates greater than 1 are not yet ' +
                        ("supported. Got rates '" + rates + "'"));
                    var convInfo = conv_util.computeConv2DInfo(input4D.shape, filter.shape, strides, pad, true);
                    return this.executeOp('depthwiseConv2D', function () {
                        var res = _this.backendEngine.executeKernel('DepthwiseConv2D', {
                            inputs: {
                                x: input4D,
                                filter: filter
                            }, args: {convInfo: convInfo}
                        });
                        if (reshapedTo4D) {
                            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
                        }
                        return res;
                    });
                };
                NDArrayMath.prototype.maxPool = function (input, filterSize, strides, pad) {
                    var _this = this;
                    var input4D = input;
                    var reshapedTo4D = false;
                    if (input.rank === 3) {
                        reshapedTo4D = true;
                        input4D = input.as4D(1, input.shape[0], input.shape[1], input.shape[2]);
                    }
                    util.assert(input4D.rank === 4, "Error in maxPool: input must be rank 4 but got rank " + input4D.rank + ".");
                    var convInfo = conv_util.computePool2DInfo(input4D.shape, filterSize, strides, pad);
                    return this.executeOp('maxPool', function () {
                        var res = _this.backendEngine.executeKernel('MaxPool', {
                            inputs: {x: input4D},
                            args: {convInfo: convInfo}
                        });
                        if (reshapedTo4D) {
                            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
                        }
                        return res;
                    });
                };
                NDArrayMath.prototype.maxPoolBackprop = function (dy, input, filterSize, strides, pad) {
                    var _this = this;
                    util.assert(input.rank === dy.rank, "Rank of input (" + input.rank + ") does not match rank of dy (" + dy.rank + ")");
                    var input4D = input;
                    var dy4D = dy;
                    var reshapedTo4D = false;
                    if (input.rank === 3) {
                        reshapedTo4D = true;
                        input4D = input.as4D(1, input.shape[0], input.shape[1], input.shape[2]);
                        dy4D = dy.as4D(1, dy.shape[0], dy.shape[1], dy.shape[2]);
                    }
                    util.assert(dy4D.rank === 4, "Error in maxPoolBackprop: dy must be rank 4 but got rank " +
                        (dy4D.rank + "."));
                    util.assert(input4D.rank === 4, "Error in maxPoolBackprop: input must be rank 4 but got rank " +
                        (input4D.rank + "."));
                    var convInfo = conv_util.computePool2DInfo(input4D.shape, filterSize, strides, pad);
                    return this.executeOp('maxPoolBackprop', function () {
                        var res = _this.backendEngine.executeKernel('MaxPoolBackprop', {
                            inputs: {dy: dy4D, x: input4D},
                            args: {convInfo: convInfo}
                        });
                        if (reshapedTo4D) {
                            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
                        }
                        return res;
                    });
                };
                NDArrayMath.prototype.minPool = function (input, filterSize, strides, pad) {
                    var _this = this;
                    var input4D = input;
                    var reshapedTo4D = false;
                    if (input.rank === 3) {
                        reshapedTo4D = true;
                        input4D = input.as4D(1, input.shape[0], input.shape[1], input.shape[2]);
                    }
                    util.assert(input4D.rank === 4, "Error in minPool: x must be rank 4 but got rank " + input4D.rank + ".");
                    var convInfo = conv_util.computePool2DInfo(input4D.shape, filterSize, strides, pad);
                    return this.executeOp('minPool', function () {
                        var res = _this.backendEngine.executeKernel('MinPool', {
                            inputs: {x: input4D},
                            args: {convInfo: convInfo}
                        });
                        if (reshapedTo4D) {
                            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
                        }
                        return res;
                    });
                };
                NDArrayMath.prototype.avgPool = function (input, filterSize, strides, pad) {
                    var _this = this;
                    var input4D = input;
                    var reshapedTo4D = false;
                    if (input.rank === 3) {
                        reshapedTo4D = true;
                        input4D = input.as4D(1, input.shape[0], input.shape[1], input.shape[2]);
                    }
                    util.assert(input4D.rank === 4, "Error in avgPool: x must be rank 4 but got rank " + input4D.rank + ".");
                    var convInfo = conv_util.computePool2DInfo(input4D.shape, filterSize, strides, pad);
                    return this.executeOp('avgPool', function () {
                        var res = _this.backendEngine.executeKernel('AvgPool', {
                            inputs: {x: input4D},
                            args: {convInfo: convInfo}
                        });
                        if (reshapedTo4D) {
                            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
                        }
                        return res;
                    });
                };
                NDArrayMath.prototype.resizeBilinear3D = function (x, newShape2D, alignCorners) {
                    if (alignCorners === void 0) {
                        alignCorners = false;
                    }
                    util.assert(x.rank === 3, "Error in resizeBilinear3D: x must be rank 3 but got rank " + x.rank + ".");
                    util.assert(newShape2D.length === 2, "Error in resizeBilinear3D: new shape must 2D, but got shape " +
                        (newShape2D + "."));
                    return this.backendEngine.executeKernel('ResizeBilinear3D', {
                        inputs: {x: x},
                        args: {newShape2D: newShape2D, alignCorners: alignCorners}
                    });
                };
                NDArrayMath.prototype.batchNormalization2D = function (x, mean, variance, varianceEpsilon, scale, offset) {
                    if (varianceEpsilon === void 0) {
                        varianceEpsilon = .001;
                    }
                    util.assert(x.rank === 2, "Error in batchNormalization3D: x must be rank 3 but got rank " +
                        (x.rank + "."));
                    util.assert(mean.rank === 2 || mean.rank === 1, "Error in batchNormalization2D: mean must be rank 2 or rank 1 but " +
                        ("got rank " + mean.rank + "."));
                    util.assert(variance.rank === 2 || variance.rank === 1, "Error in batchNormalization2D: variance must be rank 2 or rank 1 " +
                        ("but got rank " + variance.rank + "."));
                    if (scale != null) {
                        util.assert(scale.rank === 2 || scale.rank === 1, "Error in batchNormalization2D: scale must be rank 2 or rank 1 " +
                            ("but got rank " + scale.rank + "."));
                    }
                    if (offset != null) {
                        util.assert(offset.rank === 2 || offset.rank === 1, "Error in batchNormalization2D: offset must be rank 2 or rank 1 " +
                            ("but got rank " + offset.rank + "."));
                    }
                    return this.backendEngine.executeKernel('BatchNorm2D', {
                        inputs: {
                            x: x,
                            mean: mean,
                            variance: variance,
                            scale: scale,
                            offset: offset
                        }, args: {varianceEpsilon: varianceEpsilon}
                    });
                };
                NDArrayMath.prototype.batchNormalization3D = function (x, mean, variance, varianceEpsilon, scale, offset) {
                    if (varianceEpsilon === void 0) {
                        varianceEpsilon = .001;
                    }
                    util.assert(x.rank === 3, "Error in batchNormalization3D: x must be rank 3 but got rank " +
                        (x.rank + "."));
                    util.assert(mean.rank === 3 || mean.rank === 1, "Error in batchNormalization3D: mean must be rank 3 or rank 1 but " +
                        ("got rank " + mean.rank + "."));
                    util.assert(variance.rank === 3 || variance.rank === 1, "Error in batchNormalization3D: variance must be rank 3 or rank 1 " +
                        ("but got rank " + variance.rank + "."));
                    if (scale != null) {
                        util.assert(scale.rank === 3 || scale.rank === 1, "Error in batchNormalization3D: scale must be rank 3 or rank 1 " +
                            ("but got rank " + scale.rank + "."));
                    }
                    if (offset != null) {
                        util.assert(offset.rank === 3 || offset.rank === 1, "Error in batchNormalization3D: offset must be rank 3 or rank 1 " +
                            ("but got rank " + offset.rank + "."));
                    }
                    return this.backendEngine.executeKernel('BatchNorm3D', {
                        inputs: {
                            x: x,
                            mean: mean,
                            variance: variance,
                            scale: scale,
                            offset: offset
                        }, args: {varianceEpsilon: varianceEpsilon}
                    });
                };
                NDArrayMath.prototype.multiRNNCell = function (lstmCells, data, c, h) {
                    var res = this.scope(function () {
                        var input = data;
                        var newStates = [];
                        for (var i = 0; i < lstmCells.length; i++) {
                            var output = lstmCells[i](input, c[i], h[i]);
                            newStates.push(output[0]);
                            newStates.push(output[1]);
                            input = output[1];
                        }
                        return newStates;
                    });
                    var newC = [];
                    var newH = [];
                    for (var i = 0; i < res.length; i += 2) {
                        newC.push(res[i]);
                        newH.push(res[i + 1]);
                    }
                    return [newC, newH];
                };
                NDArrayMath.prototype.basicLSTMCell = function (forgetBias, lstmKernel, lstmBias, data, c, h) {
                    var _this = this;
                    var res = this.scope(function () {
                        var combined = _this.concat2D(data, h, 1);
                        var weighted = _this.matMul(combined, lstmKernel);
                        var res = _this.add(weighted, lstmBias);
                        var batchSize = res.shape[0];
                        var sliceCols = res.shape[1] / 4;
                        var sliceSize = [batchSize, sliceCols];
                        var i = _this.slice2D(res, [0, 0], sliceSize);
                        var j = _this.slice2D(res, [0, sliceCols], sliceSize);
                        var f = _this.slice2D(res, [0, sliceCols * 2], sliceSize);
                        var o = _this.slice2D(res, [0, sliceCols * 3], sliceSize);
                        var newC = _this.addStrict(_this.multiplyStrict(c, _this.sigmoid(_this.scalarPlusArray(forgetBias, f))), _this.multiplyStrict(_this.sigmoid(i), _this.tanh(j)));
                        var newH = _this.multiplyStrict(_this.tanh(newC), _this.sigmoid(o));
                        return [newC, newH];
                    });
                    return [res[0], res[1]];
                };
                NDArrayMath.prototype.multinomial = function (probabilities, numSamples, seed) {
                    var _this = this;
                    var numOutcomes = probabilities.size;
                    if (numOutcomes < 2) {
                        throw new Error("Error in multinomial: you need at least 2 outcomes, but got " +
                            (numOutcomes + "."));
                    }
                    if (probabilities.rank > 2) {
                        throw new Error("Rank of probabilities must be 1 or 2, but is " + probabilities.rank);
                    }
                    seed = seed || Math.random();
                    var origRank = probabilities.rank;
                    if (probabilities.rank === 1) {
                        probabilities = probabilities.as2D(1, -1);
                    }
                    return this.executeOp('multinomial', function () {
                        var res = _this.backendEngine.executeKernel('Multinomial', {
                            inputs: {probs: probabilities},
                            args: {numSamples: numSamples, seed: seed}
                        });
                        if (origRank === 1) {
                            return res.as1D();
                        }
                        return res;
                    });
                };
                NDArrayMath.prototype.oneHot = function (indices, depth, onValue, offValue) {
                    if (onValue === void 0) {
                        onValue = 1;
                    }
                    if (offValue === void 0) {
                        offValue = 0;
                    }
                    if (depth < 2) {
                        throw new Error("Error in oneHot: depth must be >=2, but it is " + depth);
                    }
                    return this.backendEngine.executeKernel('OneHot', {
                        inputs: {indices: indices},
                        args: {depth: depth, onValue: onValue, offValue: offValue}
                    });
                };
                NDArrayMath.prototype.moments = function (x, axis, keepDims) {
                    var _this = this;
                    if (axis === void 0) {
                        axis = null;
                    }
                    if (keepDims === void 0) {
                        keepDims = false;
                    }
                    var axes = axis_util.parseAxisParam(axis, x.shape);
                    var result = this.scope(function () {
                        var mean = _this.mean(x, axes, keepDims);
                        var keepDimsShape = mean.shape;
                        if (!keepDims) {
                            keepDimsShape = axis_util.expandShapeToKeepDim(mean.shape, axes);
                        }
                        var devSquared = _this.square(_this.subtract(x, mean.reshape(keepDimsShape)));
                        var variance = _this.mean(devSquared, axes, keepDims);
                        return {mean: mean, variance: variance};
                    });
                    return result;
                };
                NDArrayMath.prototype.norm = function (x, ord, axis, keepDims) {
                    var _this = this;
                    if (ord === void 0) {
                        ord = 'euclidean';
                    }
                    if (axis === void 0) {
                        axis = null;
                    }
                    if (keepDims === void 0) {
                        keepDims = false;
                    }
                    return this.scope(function () {
                        var norm = _this.normInternal(x, ord, axis);
                        var keepDimsShape = norm.shape;
                        if (keepDims) {
                            var axes = axis_util.parseAxisParam(axis, x.shape);
                            keepDimsShape = axis_util.expandShapeToKeepDim(norm.shape, axes);
                        }
                        return norm.reshape(keepDimsShape);
                    });
                };
                NDArrayMath.prototype.normInternal = function (x, p, axis) {
                    if (axis === void 0) {
                        axis = null;
                    }
                    if (x.rank === 0) {
                        return this.abs(x);
                    }
                    if (x.rank !== 1 && axis === null) {
                        return this.normInternal(x.reshape([-1]), p, axis);
                    }
                    if (x.rank === 1 || typeof axis === 'number' ||
                        axis instanceof Array && axis.length === 1) {
                        if (p === 1) {
                            return this.sum(this.abs(x), axis);
                        }
                        if (p === Infinity) {
                            return this.max(this.abs(x), axis);
                        }
                        if (p === -Infinity) {
                            return this.min(this.abs(x), axis);
                        }
                        if (p === 'euclidean' || p === 2) {
                            return this.sqrt(this.sum(this.pow(this.abs(x), ndarray_1.Scalar.new(2, 'int32')), axis));
                        }
                        throw new Error("Error in norm: invalid ord value: " + p);
                    }
                    if (axis instanceof Array && axis.length === 2) {
                        if (p === 1) {
                            return this.max(this.sum(this.abs(x), axis[0]), axis[1] - 1);
                        }
                        if (p === Infinity) {
                            return this.max(this.sum(this.abs(x), axis[1]), axis[0]);
                        }
                        if (p === -Infinity) {
                            return this.min(this.sum(this.abs(x), axis[1]), axis[0]);
                        }
                        if (p === 'fro' || p === 'euclidean') {
                            return this.sqrt(this.sum(this.pow(x, ndarray_1.Scalar.new(2, 'int32')), axis));
                        }
                        throw new Error("Error in norm: invalid ord value: " + p);
                    }
                    throw new Error("Error in norm: invalid axis: " + axis);
                };
                NDArrayMath.prototype.gradientWrt = function (y, x) {
                    var xIsArray = x instanceof ndarray_1.NDArray;
                    var xs = [];
                    var xKeys;
                    if (xIsArray) {
                        xs.push(x);
                    } else {
                        var xMap = x;
                        xKeys = Object.keys(xMap);
                        for (var i = 0; i < xKeys.length; i++) {
                            xs.push(xMap[xKeys[i]]);
                        }
                    }
                    var gradients = this.backendEngine.gradientWrt(y, xs);
                    if (xIsArray) {
                        return gradients[0];
                    } else {
                        var result = {};
                        for (var i = 0; i < xKeys.length; i++) {
                            result[xKeys[i]] = gradients[i];
                        }
                        return result;
                    }
                };
                NDArrayMath.prototype.disposeData = function (id) {
                    this.backend.disposeData(id);
                    this.numArrays--;
                };
                return NDArrayMath;
            }());
            exports.NDArrayMath = NDArrayMath;

            function parseTupleParam(param) {
                return typeof param === 'number' ? [param, param] : param;
            }

        }, {
            "../environment": 15,
            "../util": 101,
            "./axis_util": 54,
            "./backends/backend_engine": 56,
            "./backends/types/matmul": 61,
            "./broadcast_util": 90,
            "./concat_util": 91,
            "./conv_util": 92,
            "./ndarray": 95,
            "./slice_util": 98
        }],
        95: [function (require, module, exports) {
            "use strict";
            var __extends = (this && this.__extends) || (function () {
                var extendStatics = Object.setPrototypeOf ||
                    ({__proto__: []} instanceof Array && function (d, b) {
                        d.__proto__ = b;
                    }) ||
                    function (d, b) {
                        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                    };
                return function (d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d;
                    }

                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            })();
            var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) {
                        try {
                            step(generator.next(value));
                        } catch (e) {
                            reject(e);
                        }
                    }

                    function rejected(value) {
                        try {
                            step(generator["throw"](value));
                        } catch (e) {
                            reject(e);
                        }
                    }

                    function step(result) {
                        result.done ? resolve(result.value) : new P(function (resolve) {
                            resolve(result.value);
                        }).then(fulfilled, rejected);
                    }

                    step((generator = generator.apply(thisArg, _arguments || [])).next());
                });
            };
            var __generator = (this && this.__generator) || function (thisArg, body) {
                var _ = {
                    label: 0, sent: function () {
                        if (t[0] & 1) throw t[1];
                        return t[1];
                    }, trys: [], ops: []
                }, f, y, t, g;
                return g = {
                    next: verb(0),
                    "throw": verb(1),
                    "return": verb(2)
                }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
                    return this;
                }), g;

                function verb(n) {
                    return function (v) {
                        return step([n, v]);
                    };
                }

                function step(op) {
                    if (f) throw new TypeError("Generator is already executing.");
                    while (_) try {
                        if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                        if (y = 0, t) op = [0, t.value];
                        switch (op[0]) {
                            case 0:
                            case 1:
                                t = op;
                                break;
                            case 4:
                                _.label++;
                                return {value: op[1], done: false};
                            case 5:
                                _.label++;
                                y = op[1];
                                op = [0];
                                continue;
                            case 7:
                                op = _.ops.pop();
                                _.trys.pop();
                                continue;
                            default:
                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                    _ = 0;
                                    continue;
                                }
                                if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                    _.label = op[1];
                                    break;
                                }
                                if (op[0] === 6 && _.label < t[1]) {
                                    _.label = t[1];
                                    t = op;
                                    break;
                                }
                                if (t && _.label < t[2]) {
                                    _.label = t[2];
                                    _.ops.push(op);
                                    break;
                                }
                                if (t[2]) _.ops.pop();
                                _.trys.pop();
                                continue;
                        }
                        op = body.call(thisArg, _);
                    } catch (e) {
                        op = [6, e];
                        y = 0;
                    } finally {
                        f = t = 0;
                    }
                    if (op[0] & 5) throw op[1];
                    return {value: op[0] ? op[1] : void 0, done: true};
                }
            };
            Object.defineProperty(exports, "__esModule", {value: true});
            var environment_1 = require("../environment");
            var util = require("../util");
            var rand_1 = require("./rand");
            var DType;
            (function (DType) {
                DType["float32"] = "float32";
                DType["int32"] = "int32";
                DType["bool"] = "bool";
            })(DType = exports.DType || (exports.DType = {}));
            var NDArray = (function () {
                function NDArray(shape, dtype, values, id, math) {
                    this.isDisposed = false;
                    this.math = math || environment_1.ENV.math;
                    this.size = util.sizeFromShape(shape);
                    if (values != null) {
                        util.assert(this.size === values.length, "Constructing ndarray of shape (" + this.size + ") should match the " +
                            ("length of values (" + values.length + ")"));
                    }
                    this.shape = shape;
                    this.dtype = dtype || 'float32';
                    var dim = this.shape.length;
                    if (dim < 2) {
                        this.strides = [];
                    } else {
                        this.strides = new Array(dim - 1);
                        this.strides[dim - 2] = this.shape[dim - 1];
                        for (var i = dim - 3; i >= 0; --i) {
                            this.strides[i] = this.strides[i + 1] * this.shape[i + 1];
                        }
                    }
                    this.id = id;
                    if (this.id == null) {
                        this.id = NDArray.nextId++;
                        this.math.register(this);
                        this.math.write(this.id, values, this.dtype, this.shape);
                    }
                }

                NDArray.ones = function (shape, dtype) {
                    var values = makeOnesTypedArray(util.sizeFromShape(shape), dtype);
                    return NDArray.make(shape, {values: values}, dtype);
                };
                NDArray.zeros = function (shape, dtype) {
                    var values = makeZerosTypedArray(util.sizeFromShape(shape), dtype);
                    return NDArray.make(shape, {values: values}, dtype);
                };
                NDArray.onesLike = function (another) {
                    return NDArray.ones(another.shape, another.dtype);
                };
                NDArray.zerosLike = function (another) {
                    return NDArray.zeros(another.shape, another.dtype);
                };
                NDArray.like = function (another) {
                    var newValues = copyTypedArray(another.getValues(), another.dtype);
                    return NDArray.make(another.shape, {values: newValues}, another.dtype);
                };
                NDArray.make = function (shape, data, dtype, math) {
                    switch (shape.length) {
                        case 0:
                            return new Scalar(shape, dtype, data.values, data.id, math);
                        case 1:
                            return new Array1D(shape, dtype, data.values, data.id, math);
                        case 2:
                            return new Array2D(shape, dtype, data.values, data.id, math);
                        case 3:
                            return new Array3D(shape, dtype, data.values, data.id, math);
                        case 4:
                            return new Array4D(shape, dtype, data.values, data.id, math);
                        default:
                            return new NDArray(shape, dtype, data.values, data.id, math);
                    }
                };
                NDArray.fromPixels = function (pixels, numChannels, math) {
                    if (numChannels === void 0) {
                        numChannels = 3;
                    }
                    if (numChannels > 4) {
                        throw new Error('Cannot construct NDArray with more than 4 channels from pixels.');
                    }
                    var ndarrayData = {};
                    var shape = [pixels.height, pixels.width, numChannels];
                    var res = NDArray.make(shape, ndarrayData, 'int32');
                    math = math || environment_1.ENV.math;
                    math.writePixels(res.id, pixels, numChannels);
                    return res;
                };
                NDArray.prototype.reshape = function (newShape) {
                    this.throwIfDisposed();
                    newShape = util.inferFromImplicitShape(newShape, this.size);
                    if (util.arraysEqual(this.shape, newShape)) {
                        return this;
                    }
                    var data = {id: this.id};
                    util.assert(this.size === util.sizeFromShape(newShape), 'new shape and old shape must have the same number of elements.');
                    return NDArray.make(newShape, data, this.dtype);
                };
                NDArray.prototype.flatten = function () {
                    this.throwIfDisposed();
                    if (this instanceof Array1D) {
                        return this;
                    }
                    return this.as1D();
                };
                NDArray.prototype.asScalar = function () {
                    this.throwIfDisposed();
                    util.assert(this.size === 1, 'The array must have only 1 element.');
                    return this.reshape([]);
                };
                NDArray.prototype.as1D = function () {
                    this.throwIfDisposed();
                    return this.reshape([this.size]);
                };
                NDArray.prototype.as2D = function (rows, columns) {
                    this.throwIfDisposed();
                    return this.reshape([rows, columns]);
                };
                NDArray.prototype.as3D = function (rows, columns, depth) {
                    this.throwIfDisposed();
                    return this.reshape([rows, columns, depth]);
                };
                NDArray.prototype.as4D = function (rows, columns, depth, depth2) {
                    this.throwIfDisposed();
                    return this.reshape([rows, columns, depth, depth2]);
                };
                NDArray.prototype.asType = function (dtype) {
                    this.throwIfDisposed();
                    if (this.dtype === dtype) {
                        return this;
                    }
                    var vals = this.dataSync();
                    var newVals = toTypedArray(vals, dtype);
                    return NDArray.make(this.shape, {values: newVals}, dtype);
                };
                Object.defineProperty(NDArray.prototype, "rank", {
                    get: function () {
                        return this.shape.length;
                    },
                    enumerable: true,
                    configurable: true
                });
                NDArray.prototype.get = function () {
                    var locs = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        locs[_i] = arguments[_i];
                    }
                    var index = locs[locs.length - 1];
                    for (var i = 0; i < locs.length - 1; ++i) {
                        index += this.strides[i] * locs[i];
                    }
                    return this.getValues()[index];
                };
                NDArray.prototype.add = function (value) {
                    var locs = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        locs[_i - 1] = arguments[_i];
                    }
                    this.set.apply(this, [this.get.apply(this, locs) + value].concat(locs));
                };
                NDArray.prototype.set = function (value) {
                    var locs = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        locs[_i - 1] = arguments[_i];
                    }
                    this.throwIfDisposed();
                    util.assert(locs.length === this.rank, "The number of provided coordinates (" + locs.length + ") must " +
                        ("match the rank (" + this.rank + ")"));
                    var index = locs.length > 0 ? locs[locs.length - 1] : 0;
                    for (var i = 0; i < locs.length - 1; ++i) {
                        index += this.strides[i] * locs[i];
                    }
                    var vals = this.getValues();
                    vals[index] = value;
                    this.math.disposeData(this.id);
                    this.math.write(this.id, vals, this.dtype, this.shape);
                };
                NDArray.prototype.val = function () {
                    var locs = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        locs[_i] = arguments[_i];
                    }
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    this.throwIfDisposed();
                                    return [4, this.data()];
                                case 1:
                                    _a.sent();
                                    return [2, this.get.apply(this, locs)];
                            }
                        });
                    });
                };
                NDArray.prototype.locToIndex = function (locs) {
                    this.throwIfDisposed();
                    var index = locs[locs.length - 1];
                    for (var i = 0; i < locs.length - 1; ++i) {
                        index += this.strides[i] * locs[i];
                    }
                    return index;
                };
                NDArray.prototype.indexToLoc = function (index) {
                    this.throwIfDisposed();
                    var locs = new Array(this.shape.length);
                    for (var i = 0; i < locs.length - 1; ++i) {
                        locs[i] = Math.floor(index / this.strides[i]);
                        index -= locs[i] * this.strides[i];
                    }
                    locs[locs.length - 1] = index;
                    return locs;
                };
                NDArray.prototype.fill = function (value) {
                    this.throwIfDisposed();
                    var vals = this.getValues();
                    vals.fill(value);
                    this.math.disposeData(this.id);
                    this.math.write(this.id, vals, this.dtype, this.shape);
                };
                NDArray.prototype.getValues = function () {
                    return this.dataSync();
                };
                NDArray.prototype.getValuesAsync = function () {
                    return this.data();
                };
                NDArray.prototype.data = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            this.throwIfDisposed();
                            return [2, this.math.read(this.id)];
                        });
                    });
                };
                NDArray.prototype.dataSync = function () {
                    this.throwIfDisposed();
                    return this.math.readSync(this.id);
                };
                NDArray.prototype.dispose = function () {
                    this.isDisposed = true;
                    this.math.disposeData(this.id);
                };
                NDArray.prototype.equals = function (t) {
                    this.throwIfDisposed();
                    return this.dtype === t.dtype && util.arraysEqual(this.shape, t.shape) &&
                        util.arraysEqual(this.getValues(), t.getValues());
                };
                NDArray.rand = function (shape, randFunction, dtype) {
                    var size = util.sizeFromShape(shape);
                    var values = null;
                    if (dtype == null || dtype === 'float32') {
                        values = new Float32Array(size);
                    } else if (dtype === 'int32') {
                        values = new Int32Array(size);
                    } else if (dtype === 'bool') {
                        values = new Uint8Array(size);
                    } else {
                        throw new Error("Unknown data type " + dtype);
                    }
                    for (var i = 0; i < size; i++) {
                        values[i] = randFunction();
                    }
                    return NDArray.make(shape, {values: values}, dtype);
                };
                NDArray.randNormal = function (shape, mean, stdDev, dtype, seed) {
                    if (mean === void 0) {
                        mean = 0;
                    }
                    if (stdDev === void 0) {
                        stdDev = 1;
                    }
                    if (dtype != null && dtype === 'bool') {
                        throw new Error("Unsupported data type " + dtype);
                    }
                    var randGauss = new rand_1.MPRandGauss(mean, stdDev, dtype, false, seed);
                    return NDArray.rand(shape, function () {
                        return randGauss.nextValue();
                    }, dtype);
                };
                NDArray.randTruncatedNormal = function (shape, mean, stdDev, dtype, seed) {
                    if (mean === void 0) {
                        mean = 0;
                    }
                    if (stdDev === void 0) {
                        stdDev = 1;
                    }
                    if (dtype != null && dtype === 'bool') {
                        throw new Error("Unsupported data type " + dtype);
                    }
                    var randGauss = new rand_1.MPRandGauss(mean, stdDev, dtype, true, seed);
                    return NDArray.rand(shape, function () {
                        return randGauss.nextValue();
                    }, dtype);
                };
                NDArray.randUniform = function (shape, a, b, dtype) {
                    return NDArray.rand(shape, function () {
                        return util.randUniform(a, b);
                    }, dtype);
                };
                NDArray.prototype.throwIfDisposed = function () {
                    if (this.isDisposed) {
                        throw new Error("NDArray is disposed.");
                    }
                };
                NDArray.nextId = 0;
                return NDArray;
            }());
            exports.NDArray = NDArray;
            var Scalar = (function (_super) {
                __extends(Scalar, _super);

                function Scalar() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }

                Scalar.new = function (value, dtype) {
                    var values = [value];
                    return new Scalar([], dtype, toTypedArray(values, dtype));
                };
                Scalar.prototype.get = function () {
                    return this.getValues()[0];
                };
                Scalar.prototype.val = function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    return [4, this.data()];
                                case 1:
                                    _a.sent();
                                    return [2, this.get()];
                            }
                        });
                    });
                };
                Scalar.prototype.add = function (value) {
                    this.getValues()[0] += value;
                };
                Scalar.prototype.asType = function (dtype) {
                    return _super.prototype.asType.call(this, dtype);
                };
                Scalar.prototype.locToIndex = function (loc) {
                    return 0;
                };
                Scalar.prototype.indexToLoc = function (index) {
                    return [];
                };
                return Scalar;
            }(NDArray));
            exports.Scalar = Scalar;
            var Array1D = (function (_super) {
                __extends(Array1D, _super);

                function Array1D() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }

                Array1D.new = function (values, dtype) {
                    if (!instanceofTypedArray(values)) {
                        var inferredShape = util.inferShape(values);
                        util.assert(inferredShape.length === 1, "Error constructing Array1D. Shape of values " + inferredShape + " is " +
                            "not 1 dimensional.");
                    }
                    return new Array1D([values.length], dtype, toTypedArray(values, dtype));
                };
                Array1D.prototype.get = function (i) {
                    return this.getValues()[i];
                };
                Array1D.prototype.val = function (i) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    return [4, this.data()];
                                case 1:
                                    _a.sent();
                                    return [2, this.get(i)];
                            }
                        });
                    });
                };
                Array1D.prototype.add = function (value, i) {
                    this.getValues()[i] += value;
                };
                Array1D.prototype.locToIndex = function (loc) {
                    return loc[0];
                };
                Array1D.prototype.indexToLoc = function (index) {
                    return [index];
                };
                Array1D.prototype.asType = function (dtype) {
                    return _super.prototype.asType.call(this, dtype);
                };
                Array1D.ones = function (shape, dtype) {
                    return NDArray.ones(shape, dtype);
                };
                Array1D.zeros = function (shape, dtype) {
                    return NDArray.zeros(shape, dtype);
                };
                Array1D.randNormal = function (shape, mean, stdDev, dtype, seed) {
                    if (mean === void 0) {
                        mean = 0;
                    }
                    if (stdDev === void 0) {
                        stdDev = 1;
                    }
                    if (dtype != null && dtype === 'bool') {
                        throw new Error("Unsupported data type " + dtype);
                    }
                    var randGauss = new rand_1.MPRandGauss(mean, stdDev, dtype, false, seed);
                    return NDArray.rand(shape, function () {
                        return randGauss.nextValue();
                    }, dtype);
                };
                Array1D.randTruncatedNormal = function (shape, mean, stdDev, dtype, seed) {
                    if (mean === void 0) {
                        mean = 0;
                    }
                    if (stdDev === void 0) {
                        stdDev = 1;
                    }
                    if (dtype != null && dtype === 'bool') {
                        throw new Error("Unsupported data type " + dtype);
                    }
                    var randGauss = new rand_1.MPRandGauss(mean, stdDev, dtype, true, seed);
                    return NDArray.rand(shape, function () {
                        return randGauss.nextValue();
                    }, dtype);
                };
                Array1D.randUniform = function (shape, a, b, dtype) {
                    return NDArray.rand(shape, function () {
                        return util.randUniform(a, b);
                    }, dtype);
                };
                return Array1D;
            }(NDArray));
            exports.Array1D = Array1D;
            var Array2D = (function (_super) {
                __extends(Array2D, _super);

                function Array2D(shape, dtype, values, id, math) {
                    var _this = this;
                    util.assert(shape.length === 2, 'Shape should be of length 2');
                    _this = _super.call(this, shape, dtype, values, id, math) || this;
                    _this.stride0 = _this.strides[0];
                    return _this;
                }

                Array2D.new = function (shape, values, dtype) {
                    if (!instanceofTypedArray(values)) {
                        var inferredShape = util.inferShape(values);
                        if (inferredShape.length > 1) {
                            util.assertShapesMatch(shape, inferredShape, "Error when constructing Array2D. Shape of values " +
                                (inferredShape + " does not match the provided shape ") +
                                (shape + ". "));
                        }
                    }
                    return new Array2D(shape, dtype, toTypedArray(values, dtype));
                };
                Array2D.prototype.get = function (i, j) {
                    return this.getValues()[this.stride0 * i + j];
                };
                Array2D.prototype.add = function (value, i, j) {
                    this.getValues()[this.stride0 * i + j] += value;
                };
                Array2D.prototype.val = function (i, j) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    return [4, this.data()];
                                case 1:
                                    _a.sent();
                                    return [2, this.get(i, j)];
                            }
                        });
                    });
                };
                Array2D.prototype.locToIndex = function (locs) {
                    return this.stride0 * locs[0] + locs[1];
                };
                Array2D.prototype.indexToLoc = function (index) {
                    return [Math.floor(index / this.stride0), index % this.stride0];
                };
                Array2D.prototype.asType = function (dtype) {
                    return _super.prototype.asType.call(this, dtype);
                };
                Array2D.ones = function (shape, dtype) {
                    return NDArray.ones(shape, dtype);
                };
                Array2D.zeros = function (shape, dtype) {
                    return NDArray.zeros(shape, dtype);
                };
                Array2D.randNormal = function (shape, mean, stdDev, dtype, seed) {
                    if (mean === void 0) {
                        mean = 0;
                    }
                    if (stdDev === void 0) {
                        stdDev = 1;
                    }
                    if (dtype != null && dtype === 'bool') {
                        throw new Error("Unsupported data type " + dtype);
                    }
                    var randGauss = new rand_1.MPRandGauss(mean, stdDev, dtype, false, seed);
                    return NDArray.rand(shape, function () {
                        return randGauss.nextValue();
                    }, dtype);
                };
                Array2D.randTruncatedNormal = function (shape, mean, stdDev, dtype, seed) {
                    if (mean === void 0) {
                        mean = 0;
                    }
                    if (stdDev === void 0) {
                        stdDev = 1;
                    }
                    if (dtype != null && dtype === 'bool') {
                        throw new Error("Unsupported data type " + dtype);
                    }
                    var randGauss = new rand_1.MPRandGauss(mean, stdDev, dtype, true, seed);
                    return NDArray.rand(shape, function () {
                        return randGauss.nextValue();
                    }, dtype);
                };
                Array2D.randUniform = function (shape, a, b, dtype) {
                    return NDArray.rand(shape, function () {
                        return util.randUniform(a, b);
                    }, dtype);
                };
                return Array2D;
            }(NDArray));
            exports.Array2D = Array2D;
            var Array3D = (function (_super) {
                __extends(Array3D, _super);

                function Array3D(shape, dtype, values, id, math) {
                    var _this = this;
                    util.assert(shape.length === 3, 'Shape should be of length 3');
                    _this = _super.call(this, shape, dtype, values, id, math) || this;
                    _this.stride0 = _this.strides[0];
                    _this.stride1 = _this.strides[1];
                    return _this;
                }

                Array3D.new = function (shape, values, dtype) {
                    if (!instanceofTypedArray(values)) {
                        var inferredShape = util.inferShape(values);
                        if (inferredShape.length > 1) {
                            util.assertShapesMatch(shape, inferredShape, "Error when constructing Array3D. Shape of values " +
                                (inferredShape + " does not match the provided shape ") +
                                (shape + ". "));
                        }
                    }
                    return new Array3D(shape, dtype, toTypedArray(values, dtype));
                };
                Array3D.prototype.get = function (i, j, k) {
                    return this.getValues()[this.stride0 * i + this.stride1 * j + k];
                };
                Array3D.prototype.val = function (i, j, k) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    return [4, this.data()];
                                case 1:
                                    _a.sent();
                                    return [2, this.get(i, j, k)];
                            }
                        });
                    });
                };
                Array3D.prototype.add = function (value, i, j, k) {
                    this.getValues()[this.stride0 * i + this.stride1 * j + k] += value;
                };
                Array3D.prototype.locToIndex = function (locs) {
                    return this.stride0 * locs[0] + this.stride1 * locs[1] + locs[2];
                };
                Array3D.prototype.indexToLoc = function (index) {
                    var i = Math.floor(index / this.stride0);
                    index -= i * this.stride0;
                    return [i, Math.floor(index / this.stride1), index % this.stride1];
                };
                Array3D.prototype.asType = function (dtype) {
                    return _super.prototype.asType.call(this, dtype);
                };
                Array3D.ones = function (shape, dtype) {
                    return NDArray.ones(shape, dtype);
                };
                Array3D.zeros = function (shape, dtype) {
                    return NDArray.zeros(shape, dtype);
                };
                Array3D.randNormal = function (shape, mean, stdDev, dtype, seed) {
                    if (mean === void 0) {
                        mean = 0;
                    }
                    if (stdDev === void 0) {
                        stdDev = 1;
                    }
                    if (dtype != null && dtype === 'bool') {
                        throw new Error("Unsupported data type " + dtype);
                    }
                    var randGauss = new rand_1.MPRandGauss(mean, stdDev, dtype, false, seed);
                    return NDArray.rand(shape, function () {
                        return randGauss.nextValue();
                    }, dtype);
                };
                Array3D.randTruncatedNormal = function (shape, mean, stdDev, dtype, seed) {
                    if (mean === void 0) {
                        mean = 0;
                    }
                    if (stdDev === void 0) {
                        stdDev = 1;
                    }
                    if (dtype != null && dtype === 'bool') {
                        throw new Error("Unsupported data type " + dtype);
                    }
                    var randGauss = new rand_1.MPRandGauss(mean, stdDev, dtype, true, seed);
                    return NDArray.rand(shape, function () {
                        return randGauss.nextValue();
                    }, dtype);
                };
                Array3D.randUniform = function (shape, a, b, dtype) {
                    return NDArray.rand(shape, function () {
                        return util.randUniform(a, b);
                    }, dtype);
                };
                return Array3D;
            }(NDArray));
            exports.Array3D = Array3D;
            var Array4D = (function (_super) {
                __extends(Array4D, _super);

                function Array4D(shape, dtype, values, id, math) {
                    var _this = this;
                    util.assert(shape.length === 4, 'Shape should be of length 4');
                    _this = _super.call(this, shape, dtype, values, id, math) || this;
                    _this.stride0 = _this.strides[0];
                    _this.stride1 = _this.strides[1];
                    _this.stride2 = _this.strides[2];
                    return _this;
                }

                Array4D.new = function (shape, values, dtype) {
                    if (!instanceofTypedArray(values)) {
                        var inferredShape = util.inferShape(values);
                        if (inferredShape.length > 1) {
                            util.assertShapesMatch(shape, inferredShape, "Error when constructing Array4D. Shape of values " +
                                (inferredShape + " does not match the provided shape ") +
                                (shape + ". "));
                        }
                    }
                    return new Array4D(shape, dtype, toTypedArray(values, dtype));
                };
                Array4D.prototype.get = function (i, j, k, l) {
                    return this.getValues()[this.stride0 * i + this.stride1 * j + this.stride2 * k + l];
                };
                Array4D.prototype.val = function (i, j, k, l) {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    return [4, this.data()];
                                case 1:
                                    _a.sent();
                                    return [2, this.get(i, j, k, l)];
                            }
                        });
                    });
                };
                Array4D.prototype.add = function (value, i, j, k, l) {
                    this.getValues()[this.stride0 * i + this.stride1 * j + this.stride2 * k + l] += value;
                };
                Array4D.prototype.locToIndex = function (locs) {
                    return this.stride0 * locs[0] + this.stride1 * locs[1] +
                        this.stride2 * locs[2] + locs[3];
                };
                Array4D.prototype.indexToLoc = function (index) {
                    var i = Math.floor(index / this.stride0);
                    index -= i * this.stride0;
                    var j = Math.floor(index / this.stride1);
                    index -= j * this.stride1;
                    return [i, j, Math.floor(index / this.stride2), index % this.stride2];
                };
                Array4D.prototype.asType = function (dtype) {
                    return _super.prototype.asType.call(this, dtype);
                };
                Array4D.ones = function (shape, dtype) {
                    return NDArray.ones(shape, dtype);
                };
                Array4D.zeros = function (shape, dtype) {
                    return NDArray.zeros(shape, dtype);
                };
                Array4D.randNormal = function (shape, mean, stdDev, dtype, seed) {
                    if (mean === void 0) {
                        mean = 0;
                    }
                    if (stdDev === void 0) {
                        stdDev = 1;
                    }
                    if (dtype != null && dtype === 'bool') {
                        throw new Error("Unsupported data type " + dtype);
                    }
                    var randGauss = new rand_1.MPRandGauss(mean, stdDev, dtype, false, seed);
                    return NDArray.rand(shape, function () {
                        return randGauss.nextValue();
                    }, dtype);
                };
                Array4D.randTruncatedNormal = function (shape, mean, stdDev, dtype, seed) {
                    if (mean === void 0) {
                        mean = 0;
                    }
                    if (stdDev === void 0) {
                        stdDev = 1;
                    }
                    if (dtype != null && dtype === 'bool') {
                        throw new Error("Unsupported data type " + dtype);
                    }
                    var randGauss = new rand_1.MPRandGauss(mean, stdDev, dtype, true, seed);
                    return NDArray.rand(shape, function () {
                        return randGauss.nextValue();
                    }, dtype);
                };
                Array4D.randUniform = function (shape, a, b, dtype) {
                    return NDArray.rand(shape, function () {
                        return util.randUniform(a, b);
                    }, dtype);
                };
                return Array4D;
            }(NDArray));
            exports.Array4D = Array4D;

            function copyTypedArray(array, dtype) {
                if (dtype == null || dtype === 'float32') {
                    return new Float32Array(array);
                } else if (dtype === 'int32') {
                    var vals = new Int32Array(array.length);
                    for (var i = 0; i < vals.length; ++i) {
                        var val = array[i];
                        if (util.isValNaN(val, 'int32')) {
                            vals[i] = util.getNaN('int32');
                        } else {
                            vals[i] = val;
                        }
                    }
                    return vals;
                } else if (dtype === 'bool') {
                    var bool = new Uint8Array(array.length);
                    for (var i = 0; i < bool.length; ++i) {
                        var val = array[i];
                        if (util.isValNaN(val, 'bool')) {
                            bool[i] = util.getNaN('bool');
                        } else if (Math.round(val) !== 0) {
                            bool[i] = 1;
                        }
                    }
                    return bool;
                } else {
                    throw new Error("Unknown data type " + dtype);
                }
            }

            function instanceofTypedArray(a) {
                return a instanceof Float32Array || a instanceof Int32Array ||
                    a instanceof Uint8Array;
            }

            function noConversionNeeded(a, dtype) {
                return (a instanceof Float32Array && dtype === 'float32') ||
                    (a instanceof Int32Array && dtype === 'int32') ||
                    (a instanceof Uint8Array && dtype === 'bool');
            }

            function toTypedArray(a, dtype) {
                if (noConversionNeeded(a, dtype)) {
                    return a;
                }
                if (Array.isArray(a)) {
                    a = util.flatten(a);
                }
                return copyTypedArray(a, dtype);
            }

            function makeZerosTypedArray(size, dtype) {
                if (dtype == null || dtype === 'float32') {
                    return new Float32Array(size);
                } else if (dtype === 'int32') {
                    return new Int32Array(size);
                } else if (dtype === 'bool') {
                    return new Uint8Array(size);
                } else {
                    throw new Error("Unknown data type " + dtype);
                }
            }

            function makeOnesTypedArray(size, dtype) {
                var array = makeZerosTypedArray(size, dtype);
                for (var i = 0; i < array.length; i++) {
                    array[i] = 1;
                }
                return array;
            }

        }, {"../environment": 15, "../util": 101, "./rand": 96}],
        96: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var seedrandom = require("seedrandom");
            var MPRandGauss = (function () {
                function MPRandGauss(mean, stdDeviation, dtype, truncated, seed) {
                    this.mean = mean;
                    this.stdDev = stdDeviation;
                    this.dtype = dtype;
                    this.nextVal = NaN;
                    this.truncated = truncated;
                    if (this.truncated) {
                        this.upper = this.mean + this.stdDev * 2;
                        this.lower = this.mean - this.stdDev * 2;
                    }
                    var seedValue = seed ? seed : Math.random();
                    this.random = seedrandom.alea(seedValue.toString());
                }

                MPRandGauss.prototype.nextValue = function () {
                    if (!isNaN(this.nextVal)) {
                        var value = this.nextVal;
                        this.nextVal = NaN;
                        return value;
                    }
                    var resultX, resultY;
                    var isValid = false;
                    while (!isValid) {
                        var v1 = void 0, v2 = void 0, s = void 0;
                        do {
                            v1 = 2 * this.random() - 1;
                            v2 = 2 * this.random() - 1;
                            s = v1 * v1 + v2 * v2;
                        } while (s >= 1 || s === 0);
                        var mul = Math.sqrt(-2.0 * Math.log(s) / s);
                        resultX = this.mean + this.stdDev * v1 * mul;
                        resultY = this.mean + this.stdDev * v2 * mul;
                        if (!this.truncated || this.isValidTruncated(resultX)) {
                            isValid = true;
                        }
                    }
                    if (!this.truncated || this.isValidTruncated(resultY)) {
                        this.nextVal = this.convertValue(resultY);
                    }
                    return this.convertValue(resultX);
                };
                MPRandGauss.prototype.convertValue = function (value) {
                    if (this.dtype == null || this.dtype === 'float32') {
                        return value;
                    }
                    return Math.round(value);
                };
                MPRandGauss.prototype.isValidTruncated = function (value) {
                    return value <= this.upper && value >= this.lower;
                };
                return MPRandGauss;
            }());
            exports.MPRandGauss = MPRandGauss;

        }, {"seedrandom": 2}],
        97: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            exports.PARALLELIZE_THRESHOLD = 30;

            function computeOptimalWindowSize(inSize) {
                if (inSize <= exports.PARALLELIZE_THRESHOLD) {
                    return inSize;
                }
                return nearestDivisor(inSize, Math.floor(Math.sqrt(inSize)));
            }

            exports.computeOptimalWindowSize = computeOptimalWindowSize;

            function nearestDivisor(size, start) {
                for (var i = start; i < size; ++i) {
                    if (size % i === 0) {
                        return i;
                    }
                }
                return size;
            }

        }, {}],
        98: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var util = require("../util");

            function assertParamsValid(input, begin, size) {
                util.assert(input.rank === begin.length, "Error in slice" + input.rank + "D: Length of begin " + begin + " must " +
                    ("match the rank of the array (" + input.rank + ")."));
                util.assert(input.rank === size.length, "Error in slice" + input.rank + "D: Length of size " + size + " must " +
                    ("match the rank of the array (" + input.rank + ")."));
                for (var i = 0; i < input.rank; ++i) {
                    util.assert(begin[i] + size[i] <= input.shape[i], "Error in slice" + input.rank + "D: begin[" + i + "] + size[" + i + "] " +
                        ("(" + (begin[i] + size[i]) + ") would overflow input.shape[" + i + "] (" + input.shape[i] + ")"));
                }
            }

            exports.assertParamsValid = assertParamsValid;

        }, {"../util": 101}],
        99: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var SumTypesMap;
            (function (SumTypesMap) {
                SumTypesMap["float32"] = "float32";
                SumTypesMap["int32"] = "int32";
                SumTypesMap["bool"] = "int32";
            })(SumTypesMap = exports.SumTypesMap || (exports.SumTypesMap = {}));
            var UpcastInt32AndMap;
            (function (UpcastInt32AndMap) {
                UpcastInt32AndMap["float32"] = "float32";
                UpcastInt32AndMap["int32"] = "int32";
                UpcastInt32AndMap["bool"] = "int32";
            })(UpcastInt32AndMap = exports.UpcastInt32AndMap || (exports.UpcastInt32AndMap = {}));
            var UpcastBoolAndMap;
            (function (UpcastBoolAndMap) {
                UpcastBoolAndMap["float32"] = "float32";
                UpcastBoolAndMap["int32"] = "int32";
                UpcastBoolAndMap["bool"] = "bool";
            })(UpcastBoolAndMap = exports.UpcastBoolAndMap || (exports.UpcastBoolAndMap = {}));
            var UpcastFloat32AndMap;
            (function (UpcastFloat32AndMap) {
                UpcastFloat32AndMap["float32"] = "float32";
                UpcastFloat32AndMap["int32"] = "float32";
                UpcastFloat32AndMap["bool"] = "float32";
            })(UpcastFloat32AndMap = exports.UpcastFloat32AndMap || (exports.UpcastFloat32AndMap = {}));
            var upcastTypeMap = {
                float32: UpcastFloat32AndMap,
                int32: UpcastInt32AndMap,
                bool: UpcastBoolAndMap
            };

            function upcastType(typeA, typeB) {
                return upcastTypeMap[typeA][typeB];
            }

            exports.upcastType = upcastType;

        }, {}],
        100: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var environment_1 = require("./environment");
            var backend_cpu_1 = require("./math/backends/backend_cpu");
            var backend_webgl_1 = require("./math/backends/backend_webgl");
            var math_1 = require("./math/math");
            var util = require("./util");
            exports.TEST_EPSILON = 1e-2;

            function mean(values) {
                var sum = 0;
                for (var i = 0; i < values.length; i++) {
                    sum += values[i];
                }
                return sum / values.length;
            }

            exports.mean = mean;

            function standardDeviation(values, mean) {
                var squareDiffSum = 0;
                for (var i = 0; i < values.length; i++) {
                    var diff = values[i] - mean;
                    squareDiffSum += diff * diff;
                }
                return Math.sqrt(squareDiffSum / values.length);
            }

            exports.standardDeviation = standardDeviation;

            function kurtosis(values) {
                var valuesMean = mean(values);
                var n = values.length;
                var sum2 = 0;
                var sum4 = 0;
                for (var i = 0; i < n; i++) {
                    var v = values[i] - valuesMean;
                    sum2 += Math.pow(v, 2);
                    sum4 += Math.pow(v, 4);
                }
                return (1 / n) * sum4 / Math.pow((1 / n) * sum2, 2);
            }

            exports.kurtosis = kurtosis;

            function skewness(values) {
                var valuesMean = mean(values);
                var n = values.length;
                var sum2 = 0;
                var sum3 = 0;
                for (var i = 0; i < n; i++) {
                    var v = values[i] - valuesMean;
                    sum2 += Math.pow(v, 2);
                    sum3 += Math.pow(v, 3);
                }
                return (1 / n) * sum3 / Math.pow((1 / (n - 1)) * sum2, 3 / 2);
            }

            exports.skewness = skewness;

            function jarqueBeraNormalityTest(values) {
                var n = values.length;
                var s = skewness(values);
                var k = kurtosis(values);
                var jb = n / 6 * (Math.pow(s, 2) + 0.25 * Math.pow(k - 3, 2));
                var CHI_SQUARE_2DEG = 5.991;
                if (jb > CHI_SQUARE_2DEG) {
                    throw new Error("Invalid p-value for JB: " + jb);
                }
            }

            exports.jarqueBeraNormalityTest = jarqueBeraNormalityTest;

            function expectArrayInMeanStdRange(actual, expectedMean, expectedStdDev, epsilon) {
                if (epsilon === void 0) {
                    epsilon = exports.TEST_EPSILON;
                }
                var actualMean = mean(actual);
                expectNumbersClose(actualMean, expectedMean, epsilon);
                expectNumbersClose(standardDeviation(actual, actualMean), expectedStdDev, epsilon);
            }

            exports.expectArrayInMeanStdRange = expectArrayInMeanStdRange;

            function expectArraysClose(actual, expected, epsilon) {
                if (epsilon === void 0) {
                    epsilon = exports.TEST_EPSILON;
                }
                var aType = actual.constructor.name;
                var bType = expected.constructor.name;
                if (aType !== bType) {
                    throw new Error("Arrays are of different type " + aType + " vs " + bType);
                }
                if (actual.length !== expected.length) {
                    throw new Error("Matrices have different lengths (" + actual.length + " vs " +
                        (expected.length + ")."));
                }
                for (var i = 0; i < expected.length; ++i) {
                    var a = actual[i];
                    var e = expected[i];
                    if (!areClose(a, e, epsilon)) {
                        var actualStr = "actual[" + i + "] === " + a;
                        var expectedStr = "expected[" + i + "] === " + e;
                        throw new Error('Arrays differ: ' + actualStr + ', ' + expectedStr);
                    }
                }
            }

            exports.expectArraysClose = expectArraysClose;

            function expectNumbersClose(a, e, epsilon) {
                if (epsilon === void 0) {
                    epsilon = exports.TEST_EPSILON;
                }
                if (!areClose(a, e, epsilon)) {
                    throw new Error("Numbers differ: actual === " + a + ", expected === " + e);
                }
            }

            exports.expectNumbersClose = expectNumbersClose;

            function areClose(a, e, epsilon) {
                if (isNaN(a) && isNaN(e)) {
                    return true;
                }
                if (isNaN(a) || isNaN(e) || Math.abs(a - e) > epsilon) {
                    return false;
                }
                return true;
            }

            function expectValuesInRange(actual, low, high) {
                for (var i = 0; i < actual.length; i++) {
                    if (actual[i] < low || actual[i] > high) {
                        throw new Error("Value out of range:" + actual[i] + " low: " + low + ", high: " + high);
                    }
                }
            }

            exports.expectValuesInRange = expectValuesInRange;

            function randomArrayInRange(n, minValue, maxValue) {
                var v = new Float32Array(n);
                var range = maxValue - minValue;
                for (var i = 0; i < n; ++i) {
                    v[i] = (Math.random() * range) + minValue;
                }
                return v;
            }

            exports.randomArrayInRange = randomArrayInRange;

            function makeIdentity(n) {
                var i = new Float32Array(n * n);
                for (var j = 0; j < n; ++j) {
                    i[(j * n) + j] = 1;
                }
                return i;
            }

            exports.makeIdentity = makeIdentity;

            function cpuMultiplyMatrix(a, aRow, aCol, b, bRow, bCol) {
                var result = new Float32Array(aRow * bCol);
                for (var r = 0; r < aRow; ++r) {
                    var aOffset = (r * aCol);
                    var cOffset = (r * bCol);
                    for (var c = 0; c < bCol; ++c) {
                        var d = 0;
                        for (var k = 0; k < aCol; ++k) {
                            d += a[aOffset + k] * b[(k * bCol) + c];
                        }
                        result[cOffset + c] = d;
                    }
                }
                return result;
            }

            exports.cpuMultiplyMatrix = cpuMultiplyMatrix;

            function cpuDotProduct(a, b) {
                if (a.length !== b.length) {
                    throw new Error('cpuDotProduct: incompatible vectors.');
                }
                var d = 0;
                for (var i = 0; i < a.length; ++i) {
                    d += a[i] * b[i];
                }
                return d;
            }

            exports.cpuDotProduct = cpuDotProduct;

            function describeMathCPU(name, tests, featuresList) {
                var testNameBase = 'CPU: math.' + name;
                describeWithFeaturesAndExecutor(testNameBase, tests, function (testName, tests, features) {
                    return executeMathTests(testName, tests, function () {
                        var safeMode = true;
                        return new math_1.NDArrayMath(new backend_cpu_1.MathBackendCPU(), safeMode);
                    }, features);
                }, featuresList);
            }

            exports.describeMathCPU = describeMathCPU;

            function describeMathGPU(name, tests, featuresList) {
                var testNameBase = 'WebGL: math.' + name;
                describeWithFeaturesAndExecutor(testNameBase, tests, function (testName, tests, features) {
                    return executeMathTests(testName, tests, function () {
                        var safeMode = true;
                        return new math_1.NDArrayMath(new backend_webgl_1.MathBackendWebGL(), safeMode);
                    }, features);
                }, featuresList);
            }

            exports.describeMathGPU = describeMathGPU;

            function describeCustom(name, tests, featuresList, customBeforeEach, customAfterEach) {
                describeWithFeaturesAndExecutor(name, [tests], function (testName, tests, features) {
                    return executeTests(testName, tests, features, customBeforeEach, customAfterEach);
                }, featuresList);
            }

            exports.describeCustom = describeCustom;

            function describeWithFeaturesAndExecutor(testNameBase, tests, executor, featuresList) {
                if (featuresList != null) {
                    featuresList.forEach(function (features) {
                        var testName = testNameBase + ' ' + JSON.stringify(features);
                        executor(testName, tests, features);
                    });
                } else {
                    executor(testNameBase, tests);
                }
            }

            var PROMISE_IT = function (name, testFunc) {
                it(name, function (done) {
                    var result = testFunc();
                    if (result instanceof Promise) {
                        result.then(done, function (e) {
                            fail(e);
                            done();
                        });
                    } else {
                        done();
                    }
                });
            };

            function executeMathTests(testName, tests, mathFactory, features) {
                var math;
                var customBeforeEach = function () {
                    math = mathFactory();
                    environment_1.ENV.setMath(math);
                    math.startScope();
                };
                var customAfterEach = function () {
                    math.endScope(null);
                    math.dispose();
                };
                var customIt = function (name, testFunc) {
                    PROMISE_IT(name, function () {
                        return testFunc(math);
                    });
                };
                executeTests(testName, tests, features, customBeforeEach, customAfterEach, customIt);
            }

            exports.executeMathTests = executeMathTests;

            function executeTests(testName, tests, features, customBeforeEach, customAfterEach, customIt) {
                if (customIt === void 0) {
                    customIt = PROMISE_IT;
                }
                describe(testName, function () {
                    beforeEach(function () {
                        if (features != null) {
                            environment_1.ENV.setFeatures(features);
                            environment_1.ENV.registerBackend('webgl', function () {
                                return new backend_webgl_1.MathBackendWebGL();
                            });
                            environment_1.ENV.registerBackend('cpu', function () {
                                return new backend_cpu_1.MathBackendCPU();
                            });
                        }
                        if (customBeforeEach != null) {
                            customBeforeEach();
                        }
                    });
                    afterEach(function () {
                        if (customAfterEach != null) {
                            customAfterEach();
                        }
                        if (features != null) {
                            environment_1.ENV.reset();
                        }
                    });
                    tests.forEach(function (test) {
                        return test(customIt);
                    });
                });
            }

            exports.executeTests = executeTests;

            function assertIsNan(val, dtype) {
                if (!util.isValNaN(val, dtype)) {
                    throw new Error("Value " + val + " does not represent NaN for dtype " + dtype);
                }
            }

            exports.assertIsNan = assertIsNan;

        }, {
            "./environment": 15,
            "./math/backends/backend_cpu": 55,
            "./math/backends/backend_webgl": 57,
            "./math/math": 94,
            "./util": 101
        }],
        101: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});

            function shuffle(array) {
                var counter = array.length;
                var temp = 0;
                var index = 0;
                while (counter > 0) {
                    index = (Math.random() * counter) | 0;
                    counter--;
                    temp = array[counter];
                    array[counter] = array[index];
                    array[index] = temp;
                }
            }

            exports.shuffle = shuffle;

            function clamp(min, x, max) {
                return Math.max(min, Math.min(x, max));
            }

            exports.clamp = clamp;

            function randUniform(a, b) {
                return Math.random() * (b - a) + a;
            }

            exports.randUniform = randUniform;

            function distSquared(a, b) {
                var result = 0;
                for (var i = 0; i < a.length; i++) {
                    var diff = Number(a[i]) - Number(b[i]);
                    result += diff * diff;
                }
                return result;
            }

            exports.distSquared = distSquared;

            function assert(expr, msg) {
                if (!expr) {
                    throw new Error(msg);
                }
            }

            exports.assert = assert;

            function assertShapesMatch(shapeA, shapeB, errorMessagePrefix) {
                if (errorMessagePrefix === void 0) {
                    errorMessagePrefix = '';
                }
                assert(arraysEqual(shapeA, shapeB), errorMessagePrefix + ("Shapes " + shapeA + " and " + shapeB + " must match"));
            }

            exports.assertShapesMatch = assertShapesMatch;

            function flatten(arr, ret) {
                if (ret === void 0) {
                    ret = [];
                }
                if (Array.isArray(arr)) {
                    for (var i = 0; i < arr.length; ++i) {
                        flatten(arr[i], ret);
                    }
                } else {
                    ret.push(arr);
                }
                return ret;
            }

            exports.flatten = flatten;

            function inferShape(arr) {
                var shape = [];
                while (arr instanceof Array) {
                    shape.push(arr.length);
                    arr = arr[0];
                }
                return shape;
            }

            exports.inferShape = inferShape;

            function sizeFromShape(shape) {
                if (shape.length === 0) {
                    return 1;
                }
                var size = shape[0];
                for (var i = 1; i < shape.length; i++) {
                    size *= shape[i];
                }
                return size;
            }

            exports.sizeFromShape = sizeFromShape;

            function isScalarShape(shape) {
                return shape.length === 0;
            }

            exports.isScalarShape = isScalarShape;

            function arraysEqual(n1, n2) {
                if (n1.length !== n2.length) {
                    return false;
                }
                for (var i = 0; i < n1.length; i++) {
                    if (n1[i] !== n2[i]) {
                        return false;
                    }
                }
                return true;
            }

            exports.arraysEqual = arraysEqual;

            function isInt(a) {
                return a % 1 === 0;
            }

            exports.isInt = isInt;

            function tanh(x) {
                if (Math.tanh != null) {
                    return Math.tanh(x);
                }
                if (x === Infinity) {
                    return 1;
                } else if (x === -Infinity) {
                    return -1;
                } else {
                    var e2x = Math.exp(2 * x);
                    return (e2x - 1) / (e2x + 1);
                }
            }

            exports.tanh = tanh;

            function sizeToSquarishShape(size) {
                for (var a = Math.floor(Math.sqrt(size)); a > 1; --a) {
                    if (size % a === 0) {
                        return [a, size / a];
                    }
                }
                return [1, size];
            }

            exports.sizeToSquarishShape = sizeToSquarishShape;

            function createShuffledIndices(n) {
                var shuffledIndices = new Uint32Array(n);
                for (var i = 0; i < n; ++i) {
                    shuffledIndices[i] = i;
                }
                shuffle(shuffledIndices);
                return shuffledIndices;
            }

            exports.createShuffledIndices = createShuffledIndices;

            function rightPad(a, size) {
                if (size <= a.length) {
                    return a;
                }
                return a + ' '.repeat(size - a.length);
            }

            exports.rightPad = rightPad;

            function repeatedTry(checkFn, delayFn, maxCounter) {
                if (delayFn === void 0) {
                    delayFn = function (counter) {
                        return 0;
                    };
                }
                return new Promise(function (resolve, reject) {
                    var tryCount = 0;
                    var tryFn = function () {
                        if (checkFn()) {
                            resolve();
                            return;
                        }
                        tryCount++;
                        var nextBackoff = delayFn(tryCount);
                        if (maxCounter != null && tryCount >= maxCounter) {
                            reject();
                            return;
                        }
                        setTimeout(tryFn, nextBackoff);
                    };
                    setTimeout(tryFn, 0);
                });
            }

            exports.repeatedTry = repeatedTry;

            function getQueryParams(queryString) {
                var params = {};
                queryString.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, function (s) {
                    var t = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        t[_i - 1] = arguments[_i];
                    }
                    decodeParam(params, t[0], t[1]);
                    return t.join('=');
                });
                return params;
            }

            exports.getQueryParams = getQueryParams;

            function decodeParam(params, name, value) {
                params[decodeURIComponent(name)] = decodeURIComponent(value || '');
            }

            function inferFromImplicitShape(shape, size) {
                var shapeProd = 1;
                var implicitIdx = -1;
                for (var i = 0; i < shape.length; ++i) {
                    if (shape[i] > 0) {
                        shapeProd *= shape[i];
                    } else if (shape[i] === -1) {
                        if (implicitIdx !== -1) {
                            throw Error("Shapes can only have 1 implicit size. " +
                                ("Found -1 at dim " + implicitIdx + " and dim " + i));
                        }
                        implicitIdx = i;
                    } else if (shape[i] <= 0) {
                        throw Error("Shapes can not be <= 0. Found " + shape[i] + " at dim " + i);
                    }
                }
                if (implicitIdx === -1) {
                    if (size > 0 && size !== shapeProd) {
                        throw Error("Size (" + size + ") must match the product of shape " + shape);
                    }
                    return shape;
                }
                if (size % shapeProd !== 0) {
                    throw Error("The implicit shape can't be a fractional number. " +
                        ("Got " + size + " / " + shapeProd));
                }
                var newShape = shape.slice();
                newShape[implicitIdx] = size / shapeProd;
                return newShape;
            }

            exports.inferFromImplicitShape = inferFromImplicitShape;
            exports.NAN_INT32 = 1 << 31;
            exports.NAN_BOOL = 255;
            exports.NAN_FLOAT32 = NaN;

            function getNaN(dtype) {
                if (dtype === 'float32') {
                    return exports.NAN_FLOAT32;
                } else if (dtype === 'int32') {
                    return exports.NAN_INT32;
                } else if (dtype === 'bool') {
                    return exports.NAN_BOOL;
                } else {
                    throw new Error("Unknown dtype " + dtype);
                }
            }

            exports.getNaN = getNaN;

            function isValNaN(val, dtype) {
                if (isNaN(val)) {
                    return true;
                }
                if (dtype === 'float32') {
                    return false;
                } else if (dtype === 'int32') {
                    return val === exports.NAN_INT32;
                } else if (dtype === 'bool') {
                    return val === exports.NAN_BOOL;
                } else {
                    throw new Error("Unknown dtype " + dtype);
                }
            }

            exports.isValNaN = isValNaN;

            function squeezeShape(shape) {
                var newShape = [];
                var keptDims = [];
                for (var i = 0; i < shape.length; ++i) {
                    if (shape[i] > 1) {
                        newShape.push(shape[i]);
                        keptDims.push(i);
                    }
                }
                return {newShape: newShape, keptDims: keptDims};
            }

            exports.squeezeShape = squeezeShape;

            function getTypedArrayFromDType(dtype, size) {
                var values = null;
                if (dtype == null || dtype === 'float32') {
                    values = new Float32Array(size);
                } else if (dtype === 'int32') {
                    values = new Int32Array(size);
                } else if (dtype === 'bool') {
                    values = new Uint8Array(size);
                } else {
                    throw new Error("Unknown data type " + dtype);
                }
                return values;
            }

            exports.getTypedArrayFromDType = getTypedArrayFromDType;

        }, {}],
        102: [function (require, module, exports) {
            "use strict";
            Object.defineProperty(exports, "__esModule", {value: true});
            var version = '0.3.15';
            exports.version = version;

        }, {}]
    }, {}, [51])(51)
});
this.dl = this.deeplearn;


var editor_background = new Image()
editor_background.src = "data:image/png;base64,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"

var DEBUG = false
var SIZE = 256

var editors = []
var request_in_progress = false

if (DEBUG) {
    var base_url = "http://localhost:6060"
} else {
    var base_url = "https://models.affinelayer.com"
}

function main() {
    var create_editor = function (config) {
        var editor = new Editor(config)
        var elem = document.getElementById(config.name)
        elem.appendChild(editor.view.ctx.canvas)
        editors.push(editor)
    }

    create_editor({
        name: "edges2cats",
        weights_url: "resources/edges2cats_AtoB.pict",
        mode: "lijn",
        clear: "#FFFFFF",
        colors: {
            lijn: "#000000",
            gum: "#ffffff",
        },
        draw: "#000000",
        initial_input: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEAAQMAAABmvDolAAAABlBMVEX///8AAABVwtN+AAADY0lEQVRo3u2YvW7UQBCAZ23nbEJ05+KKkwjc5ggSZaC6AiWriJ8OpaS8ggdISUW2QOIV6JJHoKR0Qc0rxEh5gBQULk6YXed8/pvxJDgpEJ7ibnX+dnZ2/tZ7AL300ksvvfRyY/HWIz9GgftJPnp4hAJjPx/NcOApRKtR/AEFJiCvBuJMoUBgkEwGCgfCfB9boAnAuRo8JwAJ4uqBIoFsG+JcbwClYWG+9mW+FKLhWwzPjJYhCbyZpj+sT0lg7RFU1DWAbQ7YXLlMUsAq4HMSEFkk4FVCGqltSOClagHeBSDimPTDGewZOz6TjlrEcARf5YKyYXoqjQlvJR5ukwyRsMsIfJPgTEarqRFRWP5lIyhE5RFLFBEKvTsCwgJ1uIxrAGlazbg64AIkZcATNRcvs1Qq/C+qsRieZD2jNKsG7GWf02EZUEg5lNqOqDh7lKs7K7qgDjH/vF43uaACFIqTRO/BKLJzQjye/ipVQqr2bN38Pm4DHNiwz44owPHgnk0shQFZOs+NBkEA1l0iMnGjAJ2ZYB4La8MQB7wM0LiRepWV2vTKgHCUe2xtcSYwmOLln2nZ/xWa/tBysomgpc0B1yj/KcChUq5ILAYA3REIJQNMfjI2jHcYYDijOmW+y4sKMEfWqAAKczQLqJsAaM/VXQEBXQGnK/Bol9MwZgDJZb3iAB1wWc/WTSvga4/RoOYMcBAxQMgVtwSmLOQ1NLAN5hZlmwMesyo0Fa5cFhwwAVe3Ah4MiBN4/fayydj2hTP+PbdP1R0QigM0BzC7UC4HbOt2QEpGwxPF7H5XcwB0BcadAe8vAXl9IOAA/uKo7ghQnQHdGVC3CIQcAJ0BdolQM34IIwbYgfYuxwJ6Vvp5hjRSdYj2/gKQh+iltwRookOvl9ClI1AggKicCLpZLQLKbXDRBNzKnzaT5v14gN/di7KonBZ+2gS28Bip2nU2l5MmUEuXpBHtarqMfN0O5BoFlhhl8wUSnoqHbgAcROjdpjTvoDZ9s6FYV6eLBqBqBuj65l5wgJvG7QDANDGZ5OeAQvznp6dpslztUaEOtkstS2+R6GnsfmcAk78BGYG6z4hTJqsK95I+ZWxViE9bQL6QWsXOR1eTgLsuA+oiF8ODS4u5xL9qME0vTJtJ0yX00ksv/738AfxqjuJG5j4kAAAAAElFTkSuQmCC",
        initial_output: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAMAAABrrFhUAAADAFBMVEX///+Ynpmdo52Qlo/8/Pz7+/v8/f3///7+///+/v74+fmfpZ+boZz5+vqqr6ioraejqaOlq6SlqaCcopmNkouoraSyt7Cbn5iwtK2XnJW2u7ShqKD+/v6Um5aUmZONlI709vbDx8G8wbqgpJ23urGjpp7+/v72+PizuLOtsainq6Kts6zN0MqHi4S0ubG6v7i9v7e/wbjBxb+4vbWDioSKkImTl5Gfopm7vbWwsqny9fTU2NOtsavy8/G/w7t9gXl1enOUmZDEx76Xm5KHjYeQloycn5WOkIZzd3GZnZbh4+Cwtq/S1c+gpZq+wr3u8fLFycOVnpnX29mYoZzs7++krKefqKTJzsjJzMSqsq2nrqnT2dfCxLx+g33n6+ltcWvP083d4uCHioB6f3a5u7KQk4rq7Ojc4N7p7e2Kko2Eh4CLjoWtrqXJz8vg5eTt7url5+SrraGztKxydWuBhn3MzsbHycDP1NGLjIGAh4HL0c60t6zY29bHy8bo6eSUlorc39q7w7/l6Oe3vLeRmZF5fHN2fXiRmZScpaG3uK6Bg3qttLCpqZ7Z3tu/xsL29/SkpJlsb2WbnZKWl43CycbR1tSRkob//v+osKyNlpOHkIxgZ2LS0sm4wLxlbGZ5gHxudHClqZuuuLTEzMlKSUSysaW2vrlBQT1cXFXY2NIkIx+EjohHRT5pamGytaiyu7cyMS2Fh3ufopTx8eytsaWZm45TTUZaYVs8PjhKTUkqKyc4ODPf3tV+gHWLiXl5e218hYEeHBdhYF5mZ1tTUlFVW1VPVktmcG2fn46+v7FaWE24tKivrJ6Fg3OUkYGalYWQjXzl5tymoJPPysBybFmAfW52cmRlX1R/iIZuenjZ2My+uqurqpKNnJnEvrVYTjWhmI+GkX2Jgnp/iXUQEgvJ1tWfoIKisqG1tp3Lw7WltbKBeWO5q6KYinK2pJlDQydKUGJlWR1YQxc2MBKtmoh1i40qOUZzeldaZUGCbzuJo6iymmpuX0aGelCZiSbKuH42dQ+qAAAgAElEQVR42uyca1BTZxrHKXtyEoIRlFIFjmOsq1lx2YrFUmNTY+USEYyy4A0kBSQKKGHMrlBXuRqqUomIEC5yEQMnxaQEs4ScRALmRo0iqISL1nWBKWNl3GVmd5yOn/Y9oX5RlxKwztCeX/ISZshJ5vm//+fyZpg4UZwcgyIBP5CfeRLZyUkikTjNdV6nDYUy82sJCAgICH4tUGb5dwICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoJfNZTf9v+RURCIBCO/4fhhBjdKTEIob0xPGILJc0gAmHUnPOaaigG5vIlXc4EYqjt3VNDciR9hlj64eetj/1K+GJp1HlBI3PhdH46N/UCbOwnAuHFbrx9cVzKvKJ1Fcplt/FmNmzqKh0Yfi+dMTYHCeoXC7jMttpGS34dnUaHZJC9C+v7SUJtaZuz/RgDPlQSgX+hNPJMZFJqpt42UfXdYRXOZRTLFDFoxVIpVDd/gk2ZmoVk6cAY1S7Czu6WndZHH1ezeEZut2ztMPNkRKRTEsemAQmL9MGzBUBQzj48d5ZNmFMvbbx7QgR363pItO909A0syu7v7x09dFIChAAGtjASDx+lvP+PrW2M/WqSo1NI1HHFYBc2NIkCBMyL0+p4Q1wUNnueye7ttfQMjDVkMCIZoVDqdQYWmMSCRyWQnBKZf/K+NZ8DkckzWf/txpHiOTAJkeMPD0eHsQFcf31XAA736fpmV7RPJYtCoDFYUl8mYYkRE7D6BYLAgKjPnbkexwSwHCWDs3bKbOUcM4IRAOZuHU7OvLo+45Bu9sLUnocOAqWs23ctSsZhRB/PiorhAAsrr5z0ag0HnslhMlkrA//riv7oVBhkmlWMD/Q8fZ725ufKXNoD4+J9Dy7Jbd3j4REe7em36oqPLJEcNZbE56fy0szFhaXlxKgYMigHlpc2Hqdy8sJhjRzMuX/7+8O4Pvw3p7pPJ1FK51GQcPXWcNUcEoCCkg/7nezPLQpcuWj7/E7dzZZntPLNG+Z8fywrvHb//WeyuP5aGX0tXicVUvDBOxoTAJBpdkLXB/+MPVvuc//uKb519//nU1j9gNYH45WrreM+NMBZ1hoert5w4iAuN7+vX3pLk55d0fuGe1Z7nk1qExWqlVmkW9jx4cHqV943q/bG7c9Lj+Af5XBaTTmcxqfS4sPiMoieu5728lgYNJ9SyO1NHxvsG1GqpFDdAVWdDRhqXMcMagLzdgzlCEmedFHWIWlJD/cq2uO91W9iaKewfkCuVGsz49O5YxJOG058suPlZaWTGrqKitdty66sbi5YdjY39m/vJdQF+ASkiDq9YwRP2K4D7gQByuVRWXOYdk6YS03ALUByeTBDy280AKn9DCUfIYw9WViZXPHz+/PnvUjjFxVa5TofKxp9+F+h8yPOrFXdv/uNerH/+/vVHGtaviFh/uuHmpZDkgILa2n0chcFgkBkUigE1iB0DmHmVe7ZnxAui6DR8mEAcLQVvM34ygkDiOxcSOhRGRUFnUGUlEOBhctDGYoXRpNGhUuP4mJeHR8RyZx+3Vfm51dXNR+Z7Fq4KjC7f6xYYupHNFiUKFTKTyWqSyawmqVwNsMr6Rr46+nnMgaw4Ad0+RzmaCDMSgGz/egCyoxeTkZVUwfHDQWAbjXWiMykpAclXAgaD/DpqZCZUp9PI20aXVlQscV7uvOLQnz5Yu/b9/UcObV3s677XZ2FIqIgjZA/xZCZMbQJgUhQFNUBtVbRsfi8850B8noAlJkEzUGBGFUAC3kYicfg7EhAIEvP/eiKYY5AN8DgikaigoMDGKRjcWAMaoU6p1aDWdr+EdzcFRpzzXZy/ffvaNd6Fi1d7lu88taMiuYBdV1fHM4PgcQVA/HIpcMDAeEn50fvHr6Xzo1hUErCAQ8P0TB0gQV5AkThyFUSiivlrPq0YMmNYVddQF6COZwC/VVlQjU6r1Sp1pgLbvqDNEZc8FzcvO7H9fSCAm7vrvB0nK4Nqa3kinkFmsu8/bgCp1GQdMNo25x+L2ZAmYLGoVBqNBEZE+JcXAEwlK3Ekdh9MWwAXEhh2BUXug10TKDpR1VVlmAA3g2FiwoQBAZRNTU1anbVf2O63eYVbYXXRiQvV9eVup0pKKpdeCdhXiwsmM4Per8bUajluALNBUTx4Kffi/TwBkwUGBzwFSI5+2Pq6Z/9cUBK7ABLEfpu2ArgAVGbctoqUNkynlE7gbjZN4IBxFgU5oG26fl0rlxmEiX4hboubc4tyG+vLXdf1dm/s7NxXIOTV1FQZ1Raw+6D2y1GNHBdg6J0Hl8Nz0lUCFUtMIwEHgAU72AZfqQIUytTdlAKsb/c/uNvXNCsgTKLSqFkbkqvaUKVW+wyYGPspfnygUUtRJVBA+eiRgh3wkc/qRu/q6sZ6t3mtox0cUSeoAF01VWaT2QLUkqNSXACrzMi5fbVhzecHsgQCrkrMoNJIJFwAxDE3k1/efYkEmTJnXggwqQG+plk4SDQalRW5dwJ7pr3epFU+e/YM7CaKdzOLWv5vNUhsbVOTzmrkpAR7zK9/r7Gxuf7JzofBNqGwgA1KYLFMarFYUBA/WBqQAoaOzGyPb3aXpoWBEiimUsHr40CwI7MAQia/6v8pbY0nAGVSgZUr4cliMK34IRqDzmDGR09olNrrQAEgAL77oJcPWB/JHz2SW8xtGqXOYhT+JXiJz96t27ZVN5eX+7aO2jhDnKE6jsIKGh9mDx+gsbQJW5J6bvnvioxP54OjJFAAWAAUQhKuwLQleFkse3ObKrEl9gpgF2Al3nXsEkwnASCamMU/GBe/1SzFvd4Epl8UJLTJOD7OBrNt38CAtSaRZ7YY+9sTsr18oreuvZDb+IfCwkXrMtvZPHYBz4gLIJcC84MaAHTrGmKfyXb7NPxsWt5BLpNu7wKgCIAFOTAOIK/OBRR7Ffi/+Q8OpjC4g82HYAie7LyUny2boACIWVmRMWdLn9SYQL3De54GazNUdXTr9aN6vb490Wbr6x5pb8ks0wd7zdu5Oh+0gVzv+sIFIUmptbw6kQKc/kD3QzWoVI2BM2BfMduWebXB/+LZsDwVi4EH/9NnJfgDPN2ZGHlNDQTqvd4C+O4j9phffC5jHz1gF9APp34X/EDL5eYcO7F9Wf2VKgzEgWIWWc3GL64EJSUEXPkyOzT13aUfJa0LXuLhvsDT2dWnHHSBw5eL8pv3zPd5J3Ufr45TYzXjAmg0oANKMXAG4iX+jzSrjUoyTcPb+jGMX6mFerASSFdTRMRMPsTU0gxZIZdER0VMA08TYBpgb6AoTZOlmIXbh6IOrA6eCdm0tulkH6ePncxsIpssOzln+7Hn1HRmf/Vj5+yPvZ8X1NmpOTPOPvIKyAu813Xf93Vf9+O1luNDLE05vw0GAUj8D/29CyfgV1bBezIFl/ZT7zONazzxhy/AeYZ0C4YDnuJKQACCCD/nAf26yOI6nag2NjUiv/Kr3n5nf2/34eTVPp+mx+TtzssfOzF24nj40ND3+RkXGAzbzhCb1a6R0URZwxGZYYE+lQUFBf13cLtwBaaGc2gXYPb6Nw/zxvaxRFw++IB4xIC/rycyeAL8+gw49Y4IQKSXOiEBVzyckYXKB+jwg+7AfSAD6uuLM/CzpYMI4NS1yVonR59PsvN3nd/TdPT8gUM5kat2rIuMjPxjOJGYmBh2OmJycipxH50yHJE0bMYEXJ2EmUKKSozb/nH24WycgCtAwJeAH7TT0fjy4cWxxHaKTiEV88ieJuhRAC8Dv4oC8AGE//UAnuXt7wTCku1dbH/+eOzhm4KR8CDpwen3XzjvPcoBBPDECokla/J57LHQHWdOnvxz3pb87UFx4Z+Fh4WFXYhKSmIPXbgwOaNl7C2kmq0JVgPGLe/BclNMhSsDV8Rszm68hSoACAAPjNug2cbpaznH709VKItVaiGnC/kA3A37L17KGsIv18FPbAABl8A13pifwoveW/Xez0QP/fzw7woOiI+HGzo83QfE8b0jOS6BnDojZjFXsNJA1wJP5I9lrMoIDCUSiXtDkjaM0kn09lhSYXuFjJaaUARTgFmi0/VwMUoKPSokdIUP2gi4g/yfBz8i4GbV0Qc5GfumqBaBQs7jcDhoUx2uY+lScQJ+iYEP3h0OvbWOYBAWat7fK63oiR8yNGQywCbD4pA5HB70INSEvdrwEwEioA1NSACVUWcXMZlFpoTMlR0d9zs69gH6C+wNUVEH22tZLFZFbkXqfKlMyaRIJAaDEtP16JRMU+GxlaFBPnuAgNtIO8+B/iEGIAOeTD/YlNExFZuq0bvVaLMYrgldgwe416n+hmHIG/bF9SHCjGc6Lnt+wXjMhYhyOIQ8IVqIi3hvUsT7+aL3nVqC7+8XL5SqqudomF1EoQADCe1TUw0NDeyoITY7gh5bOxnLYmQVUWgaLVOikxhoOhpG0+l0mAQIiCJGB23ak40TAB3g8t9hGrp8GdxT98umTavi9rFTtLQJlVQIVqgrIPhHmyK/adInLJU9+iR/T9QBfzxKc8CHAHYBWgAOaccTi+vq4BALhWIxj0dGlEA6BOP5slgy6H8+dcZivUAnk0hEzKKiYSuDVVtbG5tAj8gsJNFNw9QsKpNCEUkEMhomkylpAp2SBvd2uxms0MrAoHXJh7tv3obI/+Vvt+/BcjhmZ52Pp/O+HotLnKo1v5oz1qs5ZLwSfZe9I/C7dzRwDe5zfpT2fhBYT4QBPgIJwQfsgFrahpZK2iZVqdqkdeI2aZsKkiPeUxD+3ooJIPPa5pQCGYZhEkqu2dxqLqKmsVi1EXR6BJ1kolKzcnMBPk0p4AowmU6n1CmVSprEYIZTSSCCkZvSK6tuOWByuO1wOO44HDdnbzm7r9d8Edkx1NDOKtLS9PXqhUbwfxKAZ8AfPBeOMh83PACcDPEGguO7eLzxcbVaLGxua5Y3y/mKYoVC0WnkGsv1eqOCb4RfUpQQnC78fHgHpA144GaJHQNUSoNFZLHYLeYsahqJ5EpwuWyuFLNZJDIYDBB3mQyz25WYXWnGlBYKxdra2mp1hf1+3cn0ysFex23AfxNWr9N5y+mselKzseXi8aGhN/OvJFx3nXDBDC+PADj31IL+42vB7KHJOhhNWHjVkzlCkJmuLh5M3uJxtbxZ7eYrFNV8RaeA21Pe0yPRgWhxufqRPpneyK+Xq+RqeX0dUgkhB97Nq68uNVM0AM1ukdiVdqWlyEp1kVwkm802PGyGv2EYjaZTGuB1s9liprgsFrPVCq+6rK6SHT6rtx4o6HXANHyzv7+7v6qxEW6NBdkD207eBftUm6vs4UuFZM8stFwCCAv9nrAknh78AD8AL/14VNsQ9nG5vNntbkbYquuNE+X6Yn0xV0DTgHblQg6X0vo0fRqNgAtZoKiur1aAMomlcjG5i1fHH9EwX4nsSqXEIFFimN1CoQ67EmwRx47ZXMNFFA0mgewQGSggEFar1UQqs7pe28p2Htn5+vXp8JjkpqbKw/2XLl3q7W4sKMj+ZPP+yquNjd3OJ09ePvz6bsfU/Ax0wnFOgGcUWiYBng0RwuJsvwAfqr6LjAoeOOCAxEnr29xuvso9wUerU6Hn6mSYQCDTaLW5FaBprKwKUSk81NJkAuBgZEI/YVRJ5Uga5PWd5dAAKyhmi91QarAjcaOmJdiOlSWVlX2UlGCiiuyW1lZqyjCLZDKl2WxlhSWnS0pKVsQc+gFWYN7m6eQDz/p7e/sHs2tqBm7s2ph+NvnqJ7dm792bffxd0937b17NzPHHyQELfoywrAxY9P+LC1c9FHUehycc541z1NJ6Pt9tHCk2Gjv1ej2kOldH05RqRZrS0tysVBa4mIOj7ayKLFbtZEWphkaT9QkEIyNGI9/tdhv1+jnaK+38/CQUdKs518w0M5nWBnbZRzuJxJ3R64+EbqCbrKTXgLgkLCSivT0qc2Xo8cgXW/7xtubw27c/vEiPOT89MFBQ1T2YXXl0/56tMTE5OTktTdPXL5371+ffPr764NGbN89n+upRDfguF//iLOBlwGP6/JDoeRo8xF4lRSHnlutHoMrLIb4yJWaxMCm5FUVMBjWVEXswqoHNHhqNZcW2j7bPazUauPX1jYxMTBjdExMTI3N9mpnUecYkY7TVmpVFZZjoEYUNQ4lhJZ+t+tPFLWc+DUwkRpec2bZrl0/++g3sIWJYXMam1V88/O5Jd/dXz57mp9/YXDP4bHAwe+DGxj0fr167YsWqoLU5LQ+nnZ//9cq3s437Wx59DwyMqITk+GDf5faABbNEICzi90X4UdaL69RitbStutMIUSzvQeUOE5qGJmFSWCYGg8EymUh06GSZIZmZIWx2Q0TU3r3sSS2kRemMpk+AGJjwENA3o51npDXQXcNWEqlhb/SR8Ghi4vqgf7bkNT09m37mRc6hG4NVgzfOrg0qIYYHrt+xbtvTb5z//g84HueBFzuSnw1UDTZmb96/NX33bp912+NCozMePXp07c6XkAEO538ZtfZwqPM1fubX5VQzOzNomDEhl3mai+ZCzZBJMWWSmUEaMVSqsV3MrsuEOYa2UjHIQXG0UVtP7OrilKXTVlg5iiJ2DZ3kNIqz2z6xnhnnCSfVeX/DYvefvDN/4nm+n+/7fi6vb31H339/HXxecjh27YpP/tAAc8kCi2ZlvmVT948+REANzo4doOu7Iryg7YHqk7cFOQaBlTstk5nPbh1gTSazhHg8QcgiMxhkTzyNmaCE6w9LCptqAbRSKySAQCSXq6vUstkBAQyq1Era7CcIPtPf/3T9+vMHV/XH1Df+497T/f8OwYUicPwMccf6czfvNDSgm7NL+fWb1N2NavW63auXRvPtKTg83gIB+eu6desS2MKma+uK+n4d1KVFxAWu+MM+cA5ZYCr3zjq/eQCAAcDfffrp0bi4uL1bKioqvCCaSFCedpI55TqWcsrpF1ksfLhCoSDIFcXZAQEKvJBBIJLI6Y5h4OTTUiSuUwik3q2okLiGOUZyldrK6rJ4PO3HGkpRu0ZzIOu8+tyD/NH6+v4HTU1nD2DKiouJWAwmY7XD0pdPhhsGoFAMbt8/213fjW7KosVivsgfKwxXOOc9s9APfzc20XTz4b2u9r4fBx9Fut7dsWaJuQOmjz0XAH5LTdMUYJ6AQKC/fdAAcXGfx+09WeHl5QXOPNkV3JnjkfIjoNHlf7+okIfK5XIikSovptPDCUISwQIvpHPA0qWluKaUlJT09EyOQIWkQpKYBFKh1VZXxxOoAlFGtPjGqvPna2t3PtB367vyz23KqhGyW9is0EyKT4zmjFhvMI2M3B4+Ozp2eWDg8p2HO7u6G49rYmI2OPAxREVxcahKeeHJ1bFx/cTDpnsvT/WJnFXpUXePBi5fsNAcAZdNfuewFDA79t9xIAoAMEBg4D7U5UIHbN6biiIgcYWCu3V04zjmOqXTA4REBBcaisVhiUI6XYhnqJiWBLotTxaUti0q+bOeqCkAoH0kJVGuYb68FtCKMhKTJvCzjxavXPVye1db/bXGUb06/0WzMldm68JmEZFmh6HHL048MZlGTMPqzZ//dB86oeHNP9W1O7vrNmhixPYULEFRrFJd9Lk/bBgHnvhGP9Te3t6XR/atiNu65pNJAKZF7aMr8sWTIJl9wLQEoAy4z+zzDx2KizucGuEF0u4FSSbNESKLGwfuPyCbhadiQkIQjBVCVGRnKwh4kiUiL+V6e7ud3pYCDgFmoKcHTl/RI4kqQb1SpIdOq/UkMYlISPCXX17516rva7er8xtH1eqNIRdzTweEs+BmM/MKmvlX1k2Yhg3Dl9/853/fjY2gCNx+2N3W1bVq98qYeRTEwoLEUoVLLwEAEwbDRPfQ0FBRn1ToLdm1zwzAnxbNrC4++l+SxctmOwE0+oAFXI4CAAUcAD2wa+/JVNT0JKd8lgZOTebESbe1Di8Ol2PtMjLsMuxwRHkxiLoFlpYZLuO4c7yDggCCTtcS8xTA9cPkoBaJq1RqEypVOVQbjN2VDZoD22vrTtTn56/bfUrKcudkE/BkRihWUCPoa+19PWYyjg0PDLy53DA8AgVkePPEjbasl1kasUhgGU9iqHQXxkyGCcNNw8Q7AKCuvSbnUckPsVMdMAXAXJLhzAId/T0UADS8wvyDCGyNjUVZYNfJLalehSnJ4GABAI6Tu7s1nc5SAAWE2AWHYDA4LEIkZmIRGxzCckon23q7ueX6JnUmJbqCGEKBKgTB+XnuLjptQgKDifOnBO9fufIve27UnV/XVuSXF/8zi8USqoggJnJqVV7ro7I9943GceMkDZpMRmNDw8D1xtq6AwcOamL4Alq8Kpxt++qBAerqQ/3robqXdR01ec8S49aan4ksmllefdwVzfqJKSGYvwAFIBYQiAUMUBk8mYqSYEqUa1qQm5MT151tbR3AUhAssLjgEBwOvghiZYXY2FgxWenpSg8u18nN7flz386kpM7OzsTOMDQp+IJf1HpWJiSoaALRRvvourq2Pf1dL74owFLlRCqTRAANdZZnM7C0qlbe4GO1wWg0jqDnHzC9f2+8PDLQ8PVXWbs3xBQVFeTlMNhKXkv10/u3TAbDmP718YPft3W05/xyN/avZiM0uz7qAxbPAmCqb8wcgE4AhN61kAEg8hYmF0IDpJzOlck4Hul0VP7lFkQqDoPBIigAVjY2FJEVIs8uL+W4s23dObyWFh4vkhcZ6esLx4+M9IYBYGsJJLwnSeCQdU3dVlfff7x/4/6M4JAQaCIaicHAW9KoxXgLvwKa7bO8x+/GjCYQgIGRkd8AuNPUES3m1+Qx8Qku6U5c7YVNTV8PGwzf6PV7NKK+vt5nkl1Hty43vzr+87K5L0UXz4A0OTsL5y8xk2AsxHoAIDD20GZogcJkSbJryrY0NzegAA6YP6Gc6OyM4KxwGDsMgsP5i+YdE8ENcoAf2C5sekKlTqn0aFFyed7eXJ65PNjaBAZBZemvWd94bf1X6v4iaU2B3TF7ij0FgS7AhlpSsUSCXFrjx/R81fvTu3fo9BsBACN8TA0N16++rvI5VVVWCX8n3pJJ9Vup7tbrx0e7sza2uvzS2Vly+FAskOD8hXM+++Tb7ak2mdaOhZM+GHXCgYHfom4QZuCkV6FXBDiBlLS0oCDwgXQ8gQAiiFARTIYDPxPBieZF+/hj8bZHym1tra3JwrL4Mt0jnc5F6YF+PLjQDVx6ANmTwGBa+vGrpM1SClL984ULfiK+vY8IoVlR/NHXUdjMUGmVj0ia86p36EW9fnQU+sBkHH8/Pj5y3WDQv6j5okDgn8GPjo62wtKqe1WDpNZeUryuJcixM1Fy+NC3YIYXTC/j5gjA1A5x0fTOfwm6/EAXfuYQjC68gAUjCiO2pBbCFKBLHRmHLiQoQrEYHDWTMm/pUgwRa+/whR2CI8tKy11ctJ6eTJq0VVX2qFKr00EnAAK8SG/wQUIGk0nAqzwTdAy2bak1dL2fyMdHxD9GoWRgQnBWApzdGU2H5rFPs6CsNc/51JMxw9jbDx8+vH07boTo291WJC4Sn5q3VFxFqrZUWbfInsueDZZpI30ToSR3f4hdu2bFDAvMHYC/LZqRQVQDzDbIHATh/lEA9m6BLBQR4QVEgO7qHJ3oQrCA4FqxmYjPsdUYKsJ3EGGoWLqsFCaAgScJRD55OTnxqmo4q9IFhYDnzeW4kMlC1f8pt7agJtIsXN2NW5YdO507SU+nhZAydEhQzIVg5CIBJnKR0HJJMC53DAQUZAxBEZRAIgGLEaGSjAhKLTtWdqRc9Glll5pxC0d3XMcaZ6EKpma2yr1VzePWPm3N/t3BqX2Uvyrv/X//Od/5zndOBCCH062X0paWwxLCDFLHhCCeII8JkgwkJ2P+0dXxfnEBPMEn7OatrX/8feunn7a2fvzvx99+mz+uo/ryVkvMQvUjy4OeB6VfVhxq+fK77wC4g7UZvvqqJ23HDnAbth988P7T4aR3UmFvogwmscb2gZMnc3J2IAAk2Ng+XFV1FGQBWwvY+WZWhbQaJVBZMCiXmZAiHoE6ggUMIShdWtJokvl8tbzVKLbLzOXCHsulND24P9BHh1Nb0notXq+351ePHvXqpcm0WiWTK00BRAnJQkzMSCmVRbGN8b4+tyFQKKv+Vzo9AU/RZvXrqWezvx//6qtXL2dLOj68YGNczmqBmsD5FoXech0wDKDawYyyy/efnF85cHDPzlBs73sD8M5F5yKAc0L+LwTOcRwAALh89D4rB4EaSqkAakiBoSpYFAAfjcjtRIgQQQUiAnVqNGFnuoSvKujv6OtsHSooFqZb9Po0lgWyU0F9uITREq/kkdeSdj2ZVqlRHqQMBqNkFImt+XWUHSqM2pqaDLq4OCB3hIQTEyi5TW6/fv39UGfJK1Dqh2abRi/4EVRAMICAYDr9eu+Lluzc43V1tRllVZe/vrJybAeA9/cE3gGQcMNBCTzIvv0pTgm2nWk7w6YAyABWCcw0ZGT4BhZvgDqgkEYIGGbImA1AQNAEiAYRKlTztU4XxhcQstb+vtW+jqb+1ptCq5QjgWzWP5D2eidoiYTu6enttUwIhbAMRL3SROk6wKuLHbBDTkbjOqOx6WH/0OPp13e3nok3/B2vgNQfesz+pmeN8xfWPI4QLwRqLw9WA82Uduh0XR34sLLhJywA7D9OdrX/zHHAzzowYYUkXv/MjuffCCigahLwYP3MQNfAItACSwqp1oXK5BAZWzPEKEKAAkIQqWkaTycELhoVFYptutG85ubVh503BZa0bFYcZWdnZpcm00KhEBeqy0HZ7wEAmB2QQ44Y19xutwGBiBAaCjEypUfX97DDSBUUFolndf6OppKSoembW3+aMk+3Gv3NawaSEcEqRgarvn/t9SpyUwAADTP1w40n2lYO7E/a5b5womj8TACcAZ4DlPDJY2evgfTvBqeYeYAAACAASURBVPHf3jg8PNk4DKKgAVQBAMCIBpRBlazQ7qDca4agWkBIBCoZfJcWSWC1ECBjQsRU3+gfRvNXm0wolpxIgZa0NGuvVyickqlRFMP4XoyPq1UwbCaVFIVQyE1HKBKOLCsu8dXTnR26/pJ+8ezsyxKb2FhU8Pi3d3setDxgYjpKtyEuVqmYchiCCode0hOZlZUgABpm7j85cb7tZOJvBrsxxdiB5i/eDb2BBkyQ39lu1grq7j7R3sgCAGJgcnKyvt7X0LV4i9vc4QuAohXxonlrcQeOSTCVvVhdXm5S2WG1Sq5sFZuUnascAAEAgELRwlbDUgvf6gXNsF2klmBWqwXDaBAIAjUPdBOgohQr5YKRpas3MjXSiSmVucgQp6ZnZ3U2QwyRlRPWUv1S1r3t+IY/RtEYzojwmmjszbj6Rcoga0P7QAS0X7myspKzL2l3rmhimLZ3Z4S5E/+nOCugu719kr096IUAB7IkONNQe+tG1tyyRkvDZpmdx6PyxmwMn2/lm00iF65ElCYeLJNTRSalvPUhuP94B4Lill6p5vr17Gw9kAcqIa4uN6P8ZIwvJAhcUlrqxEUIGUIdSBGF8ASaZS1RXODAS12OWIlYXNRqM3TYigC/uvRabW5qTWxjzL0B1RAunFfYOf/ZfE/mxYayo7dvN5Tdf/J127mVU8cOJu3OFWbX6nbGoOwaGxsAZ8H9u7nTDl4dvPtbn2+mDLTDXAbMjWjC4QgustsLQVebv2lwCAQu3GSCnZi8Va6EIJABStAmFnTm5bndfjGJJ0s1IyMgCTKz9cmYxerFMK1GEcYkND8MeiqenYFCkZAjSIZqQqFgdGMjENxmmFBoe3vbwUSjHk8s6iEDkWXnvdQbSzVBf/765r9jDnr65V/X74xVz92aqfdlZAz4jg6z24I5B/btFoDELHvvzjCAG/ieTABw7Qzg//qZtwNvB7o+yugarO1aXFy8NReOuPBqFLLLESXlXsiPOwgBrlLKUYyvVsJ2OWj2SSVPBhWbmvqa591G0rVckZWSBdrIitzDhzMPHVJIFZojCk2yFdMCYeRMSGoIIYOejebm+bG1DUM8Fl+LkQ7SE4/H/QZbXBengs4K7dWPMjIG6T+/2fzjnfVvfnj2t2++WPcHHiyy3FzbBQDoPneMm4/vzhbfz204JWrgnv3sugPQAKD2Xzt/HiTBCRADMz5fV21l5a2sq6lzc3NXl+5VozxUJAPk7YnNj/ljJIHjKrMQ5wtoFWt32ZUmBDKrVHabPz8/3xAUSI9UpKQMDgL9kJUCGDsrM1NxJA00lFYQD1rQWRIwyiMDlGFzYf3j9fXNzYXNhbF5D0XF2WPzu/2dQYaJaFxLt+8f9aUV5X/4/NNPn3/2w4WnTz9Zl/3TV+/rWqyt7ZoZBjJoPzcc3hUAOxSQ4ID93MoDN/TmGBAwANsG+LqA+rs6p0gGH20Nh3EIoUhIVUAZdW6/wRiFIVTEIyKRZAmWzjeLREAbkXJAhiZdh3u+TwwJtIpDuccrBytBa1xZV3fxdItCr1eAo5dqjhy5Z5XgLJ7GvtHm0Qt3vvjkDjhjnoC4qCDEBIqND203pyLOUGhK9uJi3e2Lj96s/vif55//ZeHz3/zu108XXtTdLuuqXRysHZiZPM92Qkm7BmBPQjlwAOzL4RiQy4D2SVD9AQ1WsSE2mJI7t7QsdUZcRA3Oc5BBBIIRj8cQj8ZjDiZYQ2BYJFwaKZVqaVbayHgQQZhJihIb1vwxOeHUZKZWZFVePJ2VdTz3dKpCAxr6Cu6kKsIRUAhogod02sS2vIVfro/mN28gjLzTLqhmPPHNfA8kjIT5KOH6H+dWF9NGdkbrmaUPGWd+cDz2zNQ2NiDGDBmDbcgPhi7YzgoGXA/OGGZMEERsEpqQttECDeA0xlZM6sWJtqZ1UKxURkFaIUGrZitV3QfUl6hK20i7+7AKWvqwqqpsCH3hbVup39hp95kdyY9+uOd+3/nOufdcqTUV3TDXLmxlPvvTv//66u+/+eMfdnoLMJeS67oV6L9ytql6O360Fqh5kyqqHAfX6esf09XvxGKic3EFJFACGMDZyzboWQbaqoHoZYwGQ8ZmgNntdxhssWUZleNasaiqQjmdI+VsEOZDPVZv6WPsdof/wnsXP8JwydfqcvWCJ271NSzcvSF6Ii6vN+qMsDwv4ZoqaIgd7ciu+f2bUyf9aHzZZgt3xLKbnz+68MOr7UGC9bALkw2zM+MDszPTI67321+9/vo///r9Z2uj64VUvrA+PZdY6dfDgseOHT8iAHrsoxIEqdyH1705C1qa0AsAPpB/08m8Ryriqlu15gQMCjwbgxKw2dsdaHsWmDvu2MxiZFHNUUROVEkZJgETw2AaBvuydhsauvjzq6iJsvpcYmt3m4+VArj1Bi+yaa+el0q7XK0iz9NGFO3JTvl/OoWuXbyDxuRNNPwL/+dT8Ti/vbzTbm8+1+ewKdHOoYEXD2fmhgem954dvn71+m/xVD4VBQBg/RO3zjdVEw1HQ+BeU1MlWVRTjcGc1de/dF3vAVA/Cd0BAAAb22Wr6tYoiluWgZ3tWRTN2EMhB4NwcU7JnrTFyWK5rNZKbAAxmYwGk1GWTcFwT9DeZ+pjwu+gDCAA7A/7T7txdyAgCSJQIT+pv4wCcpFA1GRkdPOk/+adp09/fXNn5+1H/jDKFLcltfjFowtffvnezjnh7mhy5uGLFw97R+Y6Z3YPX3/9/P6CzxfxFtbnV/W0aF3NW2/yAUcCQM+WHX8TgzlbYYCxJZ39QABB/68M/WMumS+Vc6pCkJh+fpeV5YwDRbNo6IQNURQlrpGoTSmqZb6Ml0XcyHAkZkTsxlNM2MHU15MKrjUajH0YzH4gvwBBEqADJMmT5mmfy+n0OqNeGslM2QxGgy3r+P7bTx85Yl/E5NhyPEdvfxWT5VixjGsarqRa5uY6P/y4syUZHZmfeXlweHj/SXHSFckXpudXh/rHuo7/L8/4naMBcK+aKwAfdKypC2RQxf9dvt5/u9IEiXlnq8uTLgu632GCWdkGYx6UezYcchgQAicINzUY0wKqmqNhXThnxCgSGgBB+jIoQ4EKnBQXBKsQkNK+BpWiqLiGBySJ51WV3hjthfWPCvfPcUBzhKYYexw2Mlckvtoo5D1skUT8m7Gt3uGRaPfwcG9L50qi8+MP55PrMFI/3ds/ODzYokVXNwAwt7oyMXa2pnoTdMSXk/fOVsN11Tth/QH7j2HzJy73374NJnhxZWhuutfFskB/YF4Z+4OMjbEBvaMZ9OrVDKIB9dEUAt4G5qOK8xJ44VpNA3dsREwZxkDwPk+rx+Px+miBTwsUZkIwUhM0KBwSl1jWA1ToSjewrhLLi0XKGJQ5kjOa5Dgow+yD4NTO1D8bRlqiJTHuvutdH0gkBh4OzxSSyRHn3rODw/3TvkmXywkADAEF3jt+pKOwbwCopAoqN4LQA+cr6i8xNLSYAALQS2B1POnyiLwkmDGT3OHQv4xjDUVPXG0Pm0gcl9ICxpEUIQQoMy/AFptxQqM4ZNCChi0gglzgA129XlZkaZyTs7IB4cwERSmKRlgBACcog5Go08OyEmU612OTGSYYRk+AvvjZu+/89pc/cYuToBXUwSene7t9qejs7Gxvcmbm4ad7u/uHj3d3/9wW0QFY6b8FIuBoZ2HfAFAJlryJBdWBEQQAEvovsai3wFxLIV9KAwngGgdt+gAkmmNtbcqx6egIBjFFyW3zRDxOKgrH4QCAKklCTr8pM5qYniCp8SmntzvvTaUlQSXihgcyRlY+RVNp9nS3Nzk9Pz8cdfGiQJ0Kht8NZzJ9wR4URS2mwUZTzwcN4pMt90KZ9bW1Ljwhl5Ubu2zbyMzsy5cv9w8Onm2xbd2p/Pr8/O2lyrXo975FQrDrbFddpQX0O8EKAku6+02srCwuQhMk5ubXYQqwtARjkOAwRLahD9BQKARjy84EEbPZLPFSkeRII4LU4jhOs2wuJwQ0rZYzWUwaDUXujEajERbYopkbtCC1zSTJNVMCLcL+dzuH9RtXbysfMA9+EOxhZDloOjU42Gh2C273mTPNVivnZj2pSNS7APb7Pmc+g/tmxmf39nYPnh/sP6ZbR50AQOciqMCqqTtyQPZ3P+jSgyXwVdcPk0APxUATDHUurnbOT08X8inQgKrqBna3AAWCAgSNnoVRwPRgXCMWAAVgtMHcq69tdguiKOZ4WlBUgeA4DBd9bJs3CiVuNVOEmeQ4qpYiFa5Zk0ACpVlfKeWCPQShAeaQg/7BkFODnJsQgDYXhIbTC2a3eQEA8G6IeG28WFSuNXjy6+slPhC///zg8Rbv84IKmO+8fEs/C6u8XTkqAD+6cr4LLOR3KynourqKFAAdPLS6OrQ4Pt4COruQ2mDBumkUxnS0h0LtJ/3+tTU0k3H09DHGRqOp2Vxv6kNDDhkbpMwBq5STxLQVVyVAACNh+LGnPa7WBjPQhQ4A2dzIcfUchYP+y6mamXDTnshGmraqIvR6EUM4qiiANMTd8FdaEiWlnJO2N3jRM5rPb+ckNhIpsSpxrfGj5wd/eUZPjqa8+fGB25fu1bz1bYYgALB0pauuqaam5v8FoJvhCZ0GVhZXx4eT+VRpexu8W5FQEBkN3bwDhnUTOGDKYTBZEI6zYBia6Wh/tGnkTFwzEKCk3x0rCokLBEIKbNoHxc4GOEoAGq0HnQTGhzFZLAaMKMYRC+ZmfWkohg2P11nKURwMh1w6l4NRCU6J9uXzyvZGqZQvFApRPZdSlsCNE+T715pPffLJ/jPe5Y04p8fn+q/UHa8+lPjVUSvg0tglPV1WU30FUE1HjS1dX4Hv8sTQQDIfKW2UWPq/nFxbTBtnFpbHUbTa8Y7HM74yazuJmQ0zxkCAYUrtYFx7XAYzTYxjEoxMCIQ7IbBx4pJQbh4CwbBioY4MFU0hKkoVLSiEvG20laKqoCCtQl9WSlbiZZN92Me+7cuecS7qviUdy2+WrHP+83+XM+f/nVjMEEWsenCn8e+Hhu5zHDdFEjRKa0kL6nJxQ3EOcUi0zmDAzEX5zijVoEJ1DIF7UqmidJExpENiRg8LsADIaLHYKtrVNgBQldXhAXYoMOb4sNhoYD0FYBSLQ2lPqAiIMW/l7t30UVD6SjN6ZT1vsyykm4dHA9/Z+Z/3/vP0+Sc/Xb2edPeDDD704QencwmYaD5z5PWMaU4N/1bJwIDSC6y9cKH++tHS8fUCeMyerHaaBG8DdqVc6VhwertKq4vqtA6bxTs5E0/YEZSmtAZs2wwWH9NNR0SLg0Zj5nRMy2AeVBNLYywOGfCJGtATapHURWS1mN3cTMc8IWDB9fW1xoLU+HhxWSpldjoLNtc3C4qB4jZP372kRJ8qcmazoVBUFTT5KzS86WD/572nu7vjV5P/mns2ceb4m87WBydgZGKgSzl0l/vkpoOPnOyqheWvHaidy9wthX8OeTweBoviiE/Wu4aUBJTfD3AWK6nDPEwf7YMEtCV6F2iWZRlMWwm/BqEzjciyRYNgRpAGBhZFUC3GEg5EY/ErFTBl1VCIRa3CzSGINVV8DBix6lgVVEEZmM4bZoYJmfuYyotV6+lodq2xMevBcS0tbUksVTEaNIUPDmwvd3b2bu2WlP6UHO7MhXDo19HgSH9/8xnYBMdzViiHAc1gBcfGwAq7rwMArq2FnLEYILhOh0zpA+VDEP795QCnUWliTgxjTWpr6+N4r49kMYyARGlxcEgN0elpC4ieyHQ0BlVCRBDCgOkok0rll9Ucp7aKCCIHBGtDI6xqQaqswJhvNBYU58CgzFzZB+xKzA/2sURkKRxR/ACqUSF8UPhUnpoKkqjp4OBgf2u+70ZJ6ReFyTmI4OPXFfABx+V+UQHNHZdPnVSOwJzM9UOUwdjOzrFhd7LuEhTAmhNqGjwsqDectOl7e1ycXq/m9GSE1DIsRYk+n/7B56NBnmAYpQIISpIcBI6INsFvIm1+kUKhNCAizEAjGqus13OcsCBa9C5XuyxRGGN2muGpHOzzmJ3G9fE8MxAiMKgUlPjF3pvdkfDUEmRBZbJsBX16e5iigvz+wX8PdmYH9/JLSs8WZsYGlGNzvzYBz2oHlPZnc7MyFXS5uV95F648c/WZJBTAGpCQE2A9ZDZ7dDjFg7/Xq9V2m1WFTGt0BELSJlnwLwqL4hasMWhcCqEdEolGwRFpKGXPq0jUAAwISUBJFcQfT+j9FpPJolb7eQcFstigzWYxjGEgC0XFK5sxHGdRsNNT6u7yOzd/XFpavr9kDS+JKlICBok0TNPBrf2Dl+L+LEDAJ9cK6+o7J86cej0m/O7A2AdcbPGsU5l+H+ivVdrAtQr41zdl3MlM01xT5vqXK5tpRdY0mo2hUMgDxE5aBMEOKbBqEJXDQAR50scJfj74aIGnt4lKluYhKgmByHAcS3tYQiJ5ygC1QRAOYACZS7T1VPhsNrVQYQuSoJ0kB4/qWKgD+Iui4jInQap4h0Xu5obaav789Tc/Dn1/587ylCpsi6xSq7iSUv+B6uXOwfz83tPnVdeutnzXWTuitMP/LwG//817g8HIhf6BASUHOQ84Vw8a0J3JJJOZTFMmqaDvGiQgCxlwOgELcAqxqfX6Zc5ujVgRHS6ZfFzA5pf4hS2JZggzCzzvQBEEUUU0aCwN4lkyATdqMZxGSKvPzsWrJ112fSCQaA1wgl0mHaQ/aJJwZflDNz7KM5AVgn+0PeG9Wf2XJ/d++Oqb89U1N++4lsORhkhslR00UKuPHu0sPiJn2b1vb5345FyLe7h2JPc+4O0ZpcNvLzZ4fwyYaB5R5kGVJvBYJ3gAd8ZdBzloSWYuHR0fXykwFoAugcepzIbhiFWogG2slqdIKAj/Isf5RT64MM/qtBhD0PQ8zxOkw1RhQ/BYLIoiJKHt0xIoIsp2fbm3pvrxg5nWnoS3zevqtYdJ0V/h52m2T9kC+fmYye9fvN07U3Pl/Ff3frj35Mpk9d9mvN54uYA0vBrcezG4t7e1v/N3fuvbjW3lfMK5S3XDw7UDXcotfL97d274w0zh5WZQAh0dSgIA+QH7x8bqm+rcTfV1LUC/SgJS6VCjNqr1QImmUmnIQFgFbHBfbwVMN9mFdp9IksGF2T6zjuljDX0E72BRWrSLDgSZRqwmUaIInFKJar2rx1t9fhICai2faatOcHY5bFELo0EFPIBRjVD/ksSP3h59cOXK10/uPalJ9LQmWj8H5h0SFhpehQb/PVi5Mfhidm9jo2h3d/dE1bWzSfdwZy1g+JG3lvbwuysN/vCeWPgQou/oaJ5QxkCGv6trgZoCFHArPvjSl8qrcNDB2WgUMzhBrR0rXstmlff/PqFdFkHOypyr3eInJZ6fZf5IMIY+htESBsJBm/wOxALGiesWBD+JakQZ+GPm8WRN28wMhJWIe8tBStm7QU9QBmAYXHujyLwNULnqF+dHE+Vtk94ewScIPt9tWVZ32/85Pf9q25mflx/a2Hj6vKxEGb87d66wzj3314GOhx8ff3OH0OFDbwaE339K7GFXc9fl5teTQGPulsLTX5xNKiSgdEQzigDdBK2WBZefd+xPpSt5YH3BkzWgKDqlMiEqGXxx2EbSUMRMpa7S4DRjOBHFUZ0W11gF9VJ3wG71WxAER0mZg3X3er3V3ng8PhTghv6RKF8OuGSwRQpHeEA+wjZgDARrEG2IzwJYQksS6vCR02E5HJlefZHe/OjExfwbF5/fKv4sF35hS6a+88JA16l3o1G/GBN97wSc6QD66wAeHKi9MFzXcvbc6aMtw0ovwF2XPAtb4Ni6sWDNmCqu+qykJJUqzjXyERNJiyaeB2UYEMIkKVEsw2wTg0SlU2mOObUE7QDJZ+u2Q53bBJ9JotBHvW2w/vEZ70yPK55IuMr/x8nV/qSVZvFw74fdBIKAvMpy7wKXRMALl5fLS3ABEVZelMVxVFSwKmArtooKOlbLqgVbtZqZtjOZNDX2JWvSTFKzO91vs0m/mp0vzX7Zbf+D/Sv2HKzbzc6HaedGCS9Gfc7zO7/zO88957DzPN+gQE5ansqkauWG+dUGwxWZIsdt+Isbext7yy/9ZoVlQNYmG/AOqNp//HvRbvcV3717d85FstlsbWqq/8XWdHLnQ21YqzT2slL4oxEAEAATXJusAwuABbqymRsB1AKghG7pIRM6Ozu+bbfb0waXPe1Muzpuq0cEvRQBuFeR82W+0d4uk+ERxnXZK+ABGeyiuduSEHhIoMp5no71zjUa0fVQcyVe2A3thtZnwKfLofU82xeLabwDQgvsudhqXVpadkQiQQeAO+fI6OHB5ysyZrFFPNYtezpADPy4wXGOc9/5O/R+BMBUILC5NV2pz2I6e8F9eB7wyQaYnEQMoBckp7cCAQDBjbWJza+/DgSe33IaTs+e2VJnxwaDIW2wG9IuW4etTUdRmgQWAoABZmKCAWmbFJzAMvC0W41FUBIV0Q7uS5MkX67O8LSKGOQL4ZWVr75qFnAkXHilCa5QjsqpREKj8ppMJpBDYrPSl8tkc4jtWhZb0iK5nIPbMCv8VvALr2lp6eU5vHOO9NcCwOOpF5s/YJPm4sWZ1n+PRC8bJT7OAt8D+Bcn0QeACitXIQj2r62tTWBlJOaghtODg1TnmQH23ukMbqdPQbaPiwZF7YRIKBLpYJNpXbtQorAoIBV4iT1EypTYK8IqGQ9N89EocPgcPTdX/Vs8XAAENJuhaigczlfzLO/R6Bo6lcbr9RISRVvKHonoI5Fsrdb1eApwiJsc8dnUFsgw2+6ZtOo/KXzBSI7jzgEk8FO1rv4X2KSKY9Q+VAf+6rIT7H0f5EeEwdnJxc9n6/XZ2cVFDIZbW1gQdojBMDBx88bD7c5neCMzksFuqaNtw+1O9bfDQonWKNQKjQlPrNHQJQQqmdgssQBJ21KQyY5LTQRWiZC0nGfZKlBevsxWw4Uqy7rLIVh7PpTfz7NyUtegeyDy3//9gMxidQVhedh0WKs97urvwtazbFqZ6oSQIgMnUTDmp0Wn3ungsAC71ZvYj83KlR00wGVx3Ie654tBEB9hAWyEXpxtXYuL9XolCUIALpBFW4eHAIKj423Yfn3m1kP90RGqgk7rsFSLUl8iJAQ9NMp6jYCQmqXSNmvKZhVLtCMSrVBDelAyylk3aJ7CbiGUL4ReR2mSrRaau2iSKuRUc3PyWG/Pgwf3CZM0dWq3ByPZ0dFabTSb7Z8CA2TSHWax2us1GY0Ws9pm/pKJZPROLre6mgEDTPVDwAYZuwOp4AcD/Ob/Z359jAFg5RALJhfhGVhgIYl3RUAaJ69iQoQtrQYD/GW9M204tneeuaQjWqNROi7VelW9MQrErAqSG63YKja/MoshjfWKCK9XRXh7S3Jezrur4PPxcBji//6fyzPlfLPV+/tFqe+bvvkZlqdLpVKvyqhQ21wOZ6Y2ip3ISHBd2QjHiE1GKXgISCsrs+yX7Tkz2KeLzjGKADg8TC7sAAJwGvMl/f9kKtrPGuB7DAB14IBr4A31VmkE5AVggIXpzyYmbj6HXU+nnRnndnr7+KxDeZBqH5GMaCVjUqFAQ2kEqnYR5DhCqTWVUlrNYhmIYS1gQztMUPQcT8qj1cLKFdB0UTcL7gBKoFk4ya//MyaKxfpYcIrofLTvQUJmtioZMPMoIAAIAOwwlc3t+S0ygD+sX4bJklq8HLyV1a+uAhyxNjiw+dnhNLjA5LWLcdQX3PfrTzUAbjsYoI4sAAbYqUNysID7Pz19OBFYqwVdp0ABTqcTgGB3dajbpEOiEYkExI420Uv1kiQFCWKpfXhsLKVs8bVR1iaWSqSS9kRMzveB/A3FV8Iz9Nx3fEzexzZR4rFlt0f1xwd9M4AIttxX6gEO8attvtwq4B+8uws4vpYNFpc3Ut3m6zKTRWEGCyjVfhcSEV4tBARaEwsWEAK//Z9OkZ/MRPkZBMxCBKxjV3y9MjsJPvCmslPB3BArxKZGHVzH6XEaVYDd0GG/bZMSAp1gBHTeHVqj0YDUpWkN1aA12vHxMQmk9hKCMBLAjx5+Xi7no243my9X90Pr/CN3tOpm3eF4HPK7AohB8Ad3db88PxPTJARGmcJsK+aQA8ADavqIPhOJODiDXanuNnfD93UggQ68m54OwmY435PABOiAFgZ+98ECn3xfYLZ+cYEFMCDW37S6JbE2ZnPt4RF3fHx0lDuy2zsPrGNqtRVC4N1vx4dHBHd0IkrXC8kwLydJOd3QESJCpgBRL7kr0CWGPI9KtJyMydfzhUKosBuP74ZOCvkZHp49icdBBzRn3Czf98V+dZ7s7YV80rTkZxyRTPYWkP9q0BHMQcQLRoAHbHsu34b/lX9jj3E4OJ8P342sAla6upAGryYBA/XWQPLLJPgTj8TqC/VWf2S9Uq9f+/waOATgIIl3SPtvPo84t7eP0tztIhjg4KB7eGRYMPjvMcnQkI4iB0mRgOR5POICwdvQDREmoVBEiO6KPHI6CjCP3pF/V4UgAGsPP8Gtb8bj/wqf5E+QFePNE7eHjLJ8jCqVKNWA6Z6f4QxOiLYggRywzBzHwEMOF1207THF4h68DnLFIuhF5MFarcWD4AMLIAb/8L5t+tMnx4CWelO5uFpaoD4Lvy+ZBP8PdAXe3xdiOkH/HaSeHYi1ImLoYFii9QooWucRCGienyPJ0jxP9lB3pVKhyaiidGAXkEDrUbIRfZ0PFWCtYVhwGGJf/MlKuJDfjV+5Ajioyj3RfDXKlko99//y5T2LmvG5DKC2nM4chw0WLsaHjRZczscwjA+gwLTaTtAAmAq2lEAAT6/xP28Nlv5F49Xfvv0BmaSSrCAPgiJAPgAhsPniRWAKtODDbYMypV7GO0MjQH6g/8YlEgj0hG6QvtPiAJ3AAwGfou6Ot8EHRooaxFJJCpQw/Si6Xj0Jh3d3PlEKjQAAIABJREFUd8EKoQIsfCUcDqMXwCvIh9bLrHy+9FdIq7z3lpZdHR1cEDIOO+ezuXJBH2Cf2WD2IAOAFIlZ3mOCzqAPDbCqv8gF+vsDkA0uVPBYt9U0/Evmxvzj8Vuc9JAEQ0IAaA0JSW5N46AIbJC5OZozPHsG6Y3VPy4kCPySEVqJUaXC800y0TNHUwIvFSvFPAltm0JmIggBkGNPTP6Ih0TA7X79uvofzq6up43sDGtmWq1UO7bBYw+DNePaxtpAjPkwHkyhTobxYGYDCMfh2yTUME1g4t0NXyaASz68iyEbNrExCijZNIkUKarUaFO4XCm30a56szcrVbvq9obmB/S+z3HU3i/DBWAhy+d53/O8z3M47zmLNzAPPn+yvQ0AvrpM5kLvwgLxBNPfgAiNEt+D8d+vPgQAIYy+diYEz1sb9c7M10UiwbqtGQKAE1lQG416KxywTKTQ+zpw4cqVykf/4+9OCsC7wCopqJWVUTyXYAmJBry3PtFZnnr+vLXl7tiYpWPe0oDwg+IKpiqfzUZtumfdjIqRuvMJyixKEiNSw0NWF500wQdokg7+jy0uTt54g+/Qv2cnIf3mts8h9lAC53oX/ny5d/qz7e25OUPhevC0+6/V1CIFajHQ4ExoLRhB9MmuqhbSdxchnWcEHa+3GU4Aw8+NZCpu8N57AG5/UmmcPwkAb3dHpjpfoqLerCwPY/avr5NF8Yky2RoefXt8fNz/9Fq9T6Nt49Zxy5DL6rLZOJGdlfIqL5CdwQmOlyW3lKdt1T672US3c3ZekWZ1nWVjbpEJQw1Pwv2dTccbUf0+x0+YEL2Xz8EgIAFUhu8pFoFAv3WNdKTWrNWB74Mk4vPzzhDpB4IpBBXONIUi3ijwIDUAQuH/SuAKqYRXL/7mhBzw9tbz3UxfmWQT8umje5XDEjrXJ8pI/1x05t/HyR+PZLnEKnbbkNVmHbJaofVpM4xcnt3kfTQlJpNJkUU1FMx2iqcontM0rUdSjfCmQNnayaIIcmB6enp7bnF6ehJ+EM54AWRwNr3SGN9jdAXCmSsqSr/DMm61WiB5wDjOuq2ttS0nOWIsFY1GU95IMNIUJU+qexAMSExDoO9/CHx86TYB4EQ3BXxb6/1peTkQeJQtvyQgdJbJ5vup1UxmsHvg1Tj3eu9H3VgxVIU2FQo2IoLJLlC6n4MGYFlGFM0FEyH9H2L7AqVBGfJ8D7SxzJmSeQbyQBTcCPyTsyTyk0QUEC58cPnBwuTi4tzcXLrRUOGnOBgKzQ/d64Lxq+/o6FiLYA7MhOoqkyAVRQ40I/aoEZUKgPhDLi09IghcuIlKcPvTi6dOeMXGF2OvBm7dgrbMIKNIX1yl6z0wsnMr1VTreFr8188/L369oio9nH/44d2Hw5TLTNqFKYEXWV0E4fHJQp5h29607W9SiTyGzOfB/5yLTgiJAs1rgGAzTOohPOANqILPFh589eAyBLEBCcWGjUZ4IY3nOb/JUW2rttmq6jvm6+adEUQe2d/U3NSSWkYsotFWsqnwfQUcCQSIZn5E6sAELNFHt2///tQJTxDThu5uRSBAcoGpqXK5TJbEIMh3d0KhZ8fH91//8+9p0JjM8Qo1/uLxq2dDBWvBXOmY5xS91NOjIOb7AKAxzCTMJhMHMjQTs+wyJW3Dw+2ysYIKgLBDBofd0j5ShazzL6bB/7qsyDKzkU4bep7nIYYd1S5Xg+Nah7Ouci7ToAdkByHUEl3ODUL+elpbK4sSpEUokCHHWUzhI5NlMQBw6cSXrBwVoOJf7ORyq6sEgezqVN/SiGcw9PbwzHG/q/91aWU2jBhxPuudx6cLyUTBlJQEQeA1kWEUjhc1URSSgsQI5DSNJCXhD8w0p0mzs4rbHW40dKNxEuW+LcZK0v7BwYGb1WNhA5PKUFXGrbPMhg4lyUALWx+CAbqc887Ttc2pgagXfsAzSkLemkpFBwY8gzuDu7lcDgUQhiFDht/X11cmLAAATn5xX2yTvn9tfgAOO/MokJ3oy64+Whr1PH7x7Omx/2nB5StuGDFVay/YurrGXUmBokRKFHmJkSlK5vrbNQXpq0mMYnZZqzAfNLvJRPpBVYYJG2EEWZFL5MhcXWcksrmgUSoWRUbH7/qeWirpxt4GHr3U7m+4XnPoODwPFdDUEmkZiEaaW5dJwRtczo22Nnu7kaSVwedGcwECQWAqCwCynZ0XCAf86cuTXloXO0g4rA/vpGCySedNORtYCniaXgWPj/OJRILiirpxIFL2YctYVZJKmJOUO4FpjpECCxdCrQgCIzC8D1lfRf5n7KPJTnk7R+2zKk/ZURF4UWI0DbCxjT/EwqKG3EHwpXic3VD1eBzlEgzjI4a4vstZG2luHuhuGfCGgjNRKD5CdyMjg92t3Z5RAJDLkYNs8MoIOCvbh69ymQDw6aW/nTphBkz+ZdN/rT4YgRNbhr0IrC59P/rTzF+/uP76yK3KRU1mY3lNsw/bCgXOTEPmhAWGFTmOtvtof3uJERl4Al+DpYqmbRplNwOAdp/Pb+cZtwxqlySZV3jNR3OiqIZjRhjWT2VVKKd4PL63R7rB9b1Sz+sef/Xh4fWONSd0X3NzKNpUt1UXAfsR1zcyOggt4CVLAZUewVFYxhxRgiQHOjsnLpClwau/PeE9Q0/+sy8Md71C0u14BkcyyLDvU+++/e76feVI39g4kuNhBFjVksI+2cA9XDDNbqL6UZyPdvjMnOYW9/cFl8VSZaLowqYAZ+/zc0AAk0TkOaXESqIoahwNPNTZWFsjy8syq6uyxLB6nGUxOcJGXFRUNS9w9n5r/diZ85CDNXfuBGdmar2ewVZPbnR3dzdae/p0U9Nj0nWE+FcAqGjBbBYsMHEBEHx88RS5oOuDX8yEvW8OSv0OyO7Ht/DmI0u5ndy7f2x957dr6sZGaWMvzuYZXVVB8wBqyDZsdh+EWQnJYBvy0z12TlTylM1hqW6nYQ5EXqM4up+GUBIVu9lcLIliUZKkkgyma0PVD4uC5Ib942WQgM6urMT1eGOcTX+dNpARR/2ksdhRM29ZCwaDdXUzzd2plCcV9d4Jnq8/43TWhrykGubeA0DsEIgwS852WF+/8smHv6och/nBL5RDvU8OoHIt88E7A57dXCaQyYx2e9euV9s1mVHxoVQ3Ysfq4bY3B/tIgQLlno2xjJns6mywcXY/J4ucy+awWm1Jiqc5XtBMrvePzVHNKcXiRnwFDAjFBKYEFQgMwzIyWDJuGMZi2mDjjentbxa359Lp9IbS7ve7qh31VZYaGHB4gyZv1NsctAyN1dR0nXcGgyG8QLbeEj6orArhyZY7yy9v/uHql78+0ZLQuTezikY31NfUeVtzGUyqbGD37Va1H1KH/S9nV/ub1nnFxb1atOky7uXtvhFAAaPxYrgOFy62yoBb3nxDbdm1ILUbRgpGLeBoa007HFrRDLAd3EZ2UKJgy7HTqZaqKJscZdona1a/pNFWVatUKdW0feiH/Qf9vvOQpJk0qa13P/qD0XOec37n93uec85jqNWsEo5LHavBmjh+bMArHU5l6RgA3hxuCnUFgJPXDArkcLcbW89SFMbYjUtA6IwkZXcQXNpbbRQbaUMaxxU9RZIOTM0wioWzyMCiwKuAFtWL3mr0qNc7itbTEBoQLY4pt87tyqBRLKCOhDGRNuqMtzIZlh7WENoi08PqY3R0NDpkA+ADn7x77mm/wOmTvhzVPa5IZoxaCoMBzlz6LRh09My//vqxjkAGSLfWOmuwd5WgN7hd2d4ObFvXBmtgEFwhCJNKTZkULmlh7DqX0UQsABCiyNCieUAksCFFSgeDhnS5Vj00yIqaQip6VmWRODWmChq83upePTpZr9d70W403wOxBAbAwaH0JsqhnQ+Dy7f5jGgTaI3WOO9zOjdoUEtgEjAA+s4PVz96GSjsDZAxTwapnbxSbnXv7s2QndR4eOHCNfin5y+9905z/kFuipOkpCx3OqgzIN/t5gPA5MydAdBc4DdeQ5wgsBxJYkARVSodqQuhVgj4G4W4vEujpRwpyapAxkjiiZVqRY4zagZUD7AHjtHHgyAD6qt7xZVSvljP1w+rKAJqLWCGSTmun0LXzZoHmokMzTZtEd6j0Xh8tM/JQ1C0UQMemkE8M3P+4qXRyxcvo4ORd5EH/PzU/9Mw8Pj4saTCsuEML/ivXfv9KzNXIo/EjzQUkFxVnItbgeYGq6Xu5GSsXpmdw+aADFYCKwkDg1o/UP04kH01pSVABKtBKedueTweWD5FYhagyRWcA+kcrAHwSWa9IwTsIWXXW4IBb7lYR4UC+RW08nTNC3ADikuxyBxEAaEJs+yEEQKBdflsgs8DELgBDJGH9U/7r0wj6o7m8AJkXbyMcOCFD8+98fx26EQwsPLtXYlTqPAGj47/gXmeufLoYGJp6rqlnwxaOU7GvflSbHlr63ahlBjMZbM5tZQA5s+o17WkSY1hENJqI2W360OE0WTcQD3BgAgaEhUQ9C160xRiTRYpntKHQogSMKHr/ZtAEdONYhEEYQD4YrmcLLeAFLTkFMOkMIdxifWJvqsujYtmH7C8KF6dmKBZtskvLopjEKlIIPvPDK9PEXUZno2d+xUq+j/9v5cDP/2Bd4AC395NDNRZDetsC7s2P7AQ4dEfslRcxvuHjQ6jwhOw/7HC1ta9nYerx9a53Pq6eYCYgCqXzVImMADHEZoshjF6KrzAOudvzaPCxzCJ7oiAEBAODJxfslosEARAlPQAALDHjNLvD69OV4KQFfpSuV9u9VPAIO12kxaVjDlpX4YFHAA0pEcWfSzNulh+2HIrXDvjF+CLRC74X5w5fxm84OILr74/HKP1s++KpP57VPb3E6Gvj79pKZDJM85Ffvzs4j9GnBN3NlERUOPzYuq+nC72euABhXs7n+7sr+4lZtfVjCWZtEroCAxZQOEYTEthKgb1kHnCpMbZFnlaY9RqScpkV3F6NGlATkqtsgGFv92u07ndulAqlWJkQzGaB1GERAGQjnjIDoHk0BnDEy7XRKZJNz1sJpOBfLg4gkZ3AhNAR0Z0238hIghoLAlIxRffe/sSaJj3XwcDPJ0G/myu/vPv+w2wV8Mhr7vDtHDQbvNX2XnXlwoXL1e/6rWI+1KtXs93Y7H92zvgAvv7e9uzkCCtVtwym1249cQAdgwoskoBbQAZYMG5a2s7w1qK0GpIQpWUOgj+uHhcKicMZkhyFMS3xsGAKSi1tRqtBoLAlORksgU4CbxKRlVzbqPOTbpg0Zp53imK46LPEw4DuKB6TZalbf4LNpswhuayCGM2AMMbL7/2mzeeVQufev4exI95CCq6t/pNDVcw3Vtse1dow08tbH5maSUb+VgxFYobqtF8tBvrTqKHrm5DFCT+ua7m+mWrWZVdCJNuE6FXEeh0QLVmBiGo1cD6eRoCwOQw3lpQS1YcSK4KdUngeD+uJ2Bh4XDYHUopDHAlvB5NFL2tZHIoDtH5QL8vy9fRhXAq5dBqjMZwe1wUBNHHojpFFpEBH+sZESM2m23syYwyQfCPvvTya08L5k8/K5T8bvN/6LLkECAuP5jDKJp2HuyCCMuE73wptQKl6GEZHCEBWA0YUIoVduD788PY8SAHFrBUEDFGfaO5EIGt55BXAPcnPJn2wR8hdsEDSDY7t2YdDORZs4og1LNrMkdQWXKBHF6sKwoDVKOSjwaqjVrQW+0VqzUDjkMWhFQoI1MkFYADd7htGw5vA2+A9Tv5DE2PsBnWJ0xHIqgBXfBDUpi59Orrv3s2Rg09eXOS08H6aumrb2rMHd1VWuQPBIFvzn/wWbnR6/ZqkAVvVqNd+EoxyAOFQmF/vxALwOYznHUblQuHkPDTaok53GrmVJjO4wTw2gAIY0nS5dYDZYA8qFID/Zu14AmD4tACaSbU6pCSYjY35WKs0M0fVYu92PLy0WERmFC5Br6QvgmIAIIhFZrSLQHsCyId1gAwIgzwASSKsEusaLvg99vGedRkMPPKjU/+/ssnU6VP//jnVZ583uO9Xq+KTxnpjCDu7h6ImeydLxrFwCEIF87gza/GSl10lN/txib3H97+tLCybSbsZus2iAPczBDw2ePWYIfImrLzmY82NjYgnYxDMtR7Y7G945VgEohUvW6QTQ5Or6gxO8FJyuafUqH7/V5h5/Zqvls/2tpa/kuv0Ths1IA0FosgkVqAiddTmwCIQP/FEXpC8xbrCrP0CLoeAGk04WryZyOQDfi2ze9/5+2LH5779S9+8rxS9gREIPD4LnCQVkrb9Izbdq8cONmPN78A3dpIBMrJSjAwvN09gi0qABfaLxRWAxXOrl8bbK9+nQ8CboF6UWrBzjqVyxGkJ4PYmjg2zmdMhmi3V++tJNK1eneydBzsxINpvGOO4+mk3CrHlf7N3vLWcqkaPezeW/68B6wANGERhFGvh+ZIpUJ3dG8uvfmg6YP1gzT0eUgjC3pwLBLhr/qavmZzZPHszIx/2gY+MDP60rlh19CpUyceLp7cHgzWGIfONSKOtHenhZEHf7v/7zWQfP/h7Fp/0sCyeIDuZDMQXqJSXGDLI+FRniJCSi0CI1iRQB1QCCwt2nYRu61iLZY6tKsCCnVEHVaH+qCbTtoYNHQwfqnY2G26SUdrO9PuPJu0m002u9n/Yc+12/0waZvtXiTRLybn3PP4/c4991zJC4nqW5B/NK7Xj4LoC37LYjzuMy3PtbkIAAfj8UFwWTUBn8Sp2JhkWwKD97jRvBjAqjZZKqk++dGU2kw7aeq3+MN6S+cRiUS1jBrfjSx1dpoFeSYEZMgX6A6MhotAhmHjI90BSf84sILsWoVIuEKPRoX06N6wDZlMIBaT6DwgSGgCCcqBXV08ja3DroQQwbENXTj9MWoRQA8gvemxuXeAoeaf2m5TqSV6i7RWPrzKgCxTenK7uvmjmLnY7YMEYIGtR8d5hYx/aVFiAkoUdIAXY2iDquAIYEVmNYZmShCYuJERrAcB6j35pToqF3UOThmb1aHxTdQjmNnsHF28W8dsI2CN6orqJuPJLISaSCibHd+OrcWyZrB8ZAXACsxr9SI6OhjhRXlSqUbKkDcwIK4IAR/KXimAI4M0wFEovAfsnGFGrW3g2uVTiAu86pd+0/Nhb1UAvy3pEQMZrpU1GCCg2mSMlZU8IVmxFir2++IgfwadZ+r1BYiAviBubk4VTDCZEPSXE462kTqT2pEI0hygABwL6/GkVpEBwHa5iSQdXVczZaxwqOsko5sWy71CJpP7bnnO4aJQuBTsflpEEurvVJ1sbJSYp6fWpiWggBDYAyDjtdsiLQ+MfExKZ9gYMh4DwiC6VlMF6kVzR+QIBXBQu5zSBhbAGJZ7z9/65PAvXrcLv/GZsLctqssJgFPa1WAw2If+2D5kt3X1fUVKcmPFTtTXEEbPPHda/Hp/2KIfpKkbWaqgiaY2qhvVeD6/MSTBMUdoRm59k7FxP5dCcaOhSYIqQG0IDwv5RmMzOHy2H+Lokh/c6DsTbS7pdJNE6sDG6NONzczGdNMUkIDpafN4KBuCKBDJNq7V50t9fcJKbbTvBuOAbJjHo2u1Wp0WPECDCIvBjtpo5Q0K78CAlzPcxZM/f/619ejhD/e9nQq9XQEP0UVVwbBc2dEx1A7kckj5PPqwRJqMvdzY0OstC4VCxhLXgxXo40dMQI6YdThTkI1TMwkkCp6FozGZbFwFvqa5uppLJtdQSMTZlHt2Voc2rEfEBU6J6r6SjSXUHelbvKuqm3MkyZjpTn8BQn84Mzo9Fcuii/LFcXO2uDHeHckam/jUHmElnypa0ZZ4Sg6D11JJ5fcQiXTkAMCFJ4bse2RArtEYBpTD4CTPvQPWU59+uO+D/+Ph4ZV/MKI8GdDrIVRdsh4/b++KQtp5koXsDAg4t1XIgPDhJcgBiyocBp0KEZjq4OdsTI2LW83CJVjL7Orq+up6Ph74ALONQtSRPIDaWsSIDxEaG2Mf0WiRDctgf0QyaDKp+kMRk8RneYZS39PNzfHsdCSSNYPogUjgJSRk83RTaz6dR1QqL1y5EVXINHShqLWVKtK28AD7KrzKBkN7h7LBxlHUjvEa7BOIFn19/PLh1zcm3lMBY9fngVq2Hz9+0Hro0GefWc8PyBVKTql1Z3xxM/wgd3895/fr4/q9OHAEwn1b0uVMOubqRghkD4mCdTgAEiRGqgEP4dsSuAQaqkFxznp0YreOKCRSK7itRpqku1vF8nV36uM+BCv3OkQ6j3R3F7eLAYh9O5FAEaJhoAgLDIDPT+cnuVRuK1+o1Qo1jFotlV/Pp/J1UlQThbhn49gPdhiUoAmNVGqbsc8MzViPnv31f8sB71cTe7h6Bd2R+NsF9EjOsUvWg8paQwen5tHudtjiz62v5xYg/1ksEAHiesh8sPEeogfV/iizOjH8RsAF2Y1YilOExWLYy0yyiFzp9Dh1AoEAtc16WoR4yHfmk/vZS5bwwtYC/FNIK/EjAbM5GymXy5D7AuUyuH4sFNmFP7LZJirIn0+n+ZP5Erh+XwtDSJ1szVdSiWMy1DSlPODVyDoOdqCTcoV8rIozYz9jvXTuP9fn378q+gPHPnPmIuqORy1Xp69aZ2qfGx7+uFsGBy0gBeQWHgAI9usXFxd9naogxplyu92zAOrdbgFjOFXDZCaasTVkPJ7chlPtr8GjLkoPug1rY7QIbBwxplFtZLHq4gt+f+5P6wvxzEJ41CdB5yGRyG4Z8l5xHO0/DWRHRZHperD+dDotEonSWrqQWNlSRaSCBwghBsgalAYvp+GAgsHpOI8AgIbD04q/mGi3Xn68lwM+eOPt2Xcr5O+yIfvBa5fuXD12DM2kPPd9R+0PYz8+Km+HC/e2kPxgAhngAaO+wcFBSZ0a63GnUmKxe9adagH6KCA6XckkmofIxTJpEhxqnCbXOFsYVyauMKoEtdfJWAKBoKYtLvnX1+/fX88sfeN/9jTwL3QstLO7swvWX3xZfPmyjGRfm47FjJP8yXRPT7r3Rm/6xlgpLyKNVQIk5hPpOnot2L9BoTAY5LIGSACarrEoXVgqRb3X7kAS3PeGetj/UBL4Sjpx8YL12OmjJ34HP7/9zfecvt7JR+Wnm5kMkn/9lQLCYQiB35rYOCbe6ZlFY7NSqZbV+fnhVUFq1jNLxiNoEKSpTKZggoAHVpCav7IqGL4ynyLjnSQ8BrdoeXB/feHBA3/uZi6s6t/NohrY7u6OOTIOCtjYKEIqXJuaWkPVAH6vtkcE33yPVIsh1YipQIqoFF4VBOsGVA/zDhi8MgWaVq7VEisppFKt/dYnr8fJ/uFn8v/q1VsT71CAeKL9zDXrraMnHp8+d+rs7y+OARfa/mfm2b2/3IS1vgUayAEMtIx2h9g0Ng6TdIEOkBJSgvlhWKACgY7PTLASbDYa/4gjEJIul2sWWJFtguFxknTkapzJZ8nkwr740r2bN+9t/vXFi+xOLLYDaxcCwfb2083yTnbtz09uNzVNpsH0+3p6e2+AAla0+0V5av72FL+nB/VKalCH1F6LiFcuk3Wt9PYQKytJ0S6v9cTHrwbL//LnCPB1beDtLlDiKGesh27dufr43Jdfnj0mEzLLneFvCoWtm/fhs74Fn1yuAHjYJzGZ6kwOZsLhIrtARieSEej/6nVBi4iVYGJwc3V1vs8dyTbmT3NsR9KTmv/CiUVzQTBB1V1gFL7B+FKmcC/zb86u/qmp9ApPyNRppxlAjEhgk6yQuCQaPiSB3PoRhBsJoju6FFYtKS4J2yZcdvfGiMZg0UoCwVs3kOoQgkC6ZglfWcSL4WNFFghGxATjWpClTtzOKp2xv/kH9NxgO50uqzMN+SEz/PQ+9znnPOe+73ueOzcW5Ew/8N0WDEAPCAg8fhwIBof9ViufukSJeXQISWIIiQnioSW2WvfbDiE6CzWZN5k6I3f4aE1NXgaPZ0EI6hx1UWLNh7W/+/276xntrbmNvBGB+4j06an22vN/OvCHT/fcfHgirbDPdHLx2+lFr292Zs495fP6KI8vSILKJq1Wa2ByNbTGFBoHKB8FGjIxPTVVmpXayqCxaKwGOVdUn8LgSlDlJD0nJbYomsOJSuHnFHKAHKiEujhJHRE02AItQ8MN4XC47mogMDHx/cSDiaDN7w+FCCLOCQlAp/Pcd2FGF0by+Ps3EQQwQMcz3qPeAFFnxKAE5JVl8iwWj9DKF16SllXv+uiPNz//2Yb1GPDWJPA0/cLWw38+UVt7/uFnH3/Wk4cVqMqnF6enp+coT/Q598zorA+Sl6MZ6mCnUg9RzqXRqMsgdi6ttAQKwbWdl699VVQSxYhqPMJhs2hHmKD5VNp6Oicllo3aaQz+pi0MaB9pNKbYMKlSqLRM28rKyia6PxSsAwSgFk4sBOqG/UMhK4ELCSeO6yw6BP5cmEC9OWc/jjutuEdqUUszIPChATgc8fdKs+iMAmFszLH06iuQvKgrAz+epfjaP/FNIfCPnedOVJ9qP7hc+9EnDz/Y+TL4eGDaveh1z93qHhnpp2xOr4/2z865FwEClVJrADmXrelbUi5BHxRVevzSxa3n3r948cui2EJYJtCALpY1yRRmlGtA83NQLWjHnBYbKwXgodG1YpFepkWvDvMx63A45A/8TV7w7PX6W6jzwgRJ4oST8HxnwXVGj4sg1caWIRzDcMwo5aVZIjkgclY8b28GtEcI9MuC78raaw+s3ZlYpw9cMxF8kzZ4lNd+9uzBXe3Ly7W7are6gnf+Oj216PbNXh8ZHBsc6R4ZH6G+3ddnfdMdCrNyqQ/VtE12TnY96TSLNfbi1i8vX4hPvXahNSqbzio+wqLZDUqlubxzadKs5bANYq79CIe6H2ZvsGvEBrGI2iKv3G/Nef48FAqG5PJnf5+4cSMQHG4ZgvXPEyQslnB67qkJncWIO128xKE4lwtxUSPaqfYM9XuXAAAUG0lEQVQwY28e1ADIg3uTeVABEXV8Vll7z4HXF8fWeRXy84iH8psAaH/UvuP0wZ7l5eUdNVLyuWzAPTXt9s1Q6+8dGx8cHBkfpMyO+/tnoX51gprv06CTIIrMXV25Sk1xa+pXiakX30+OZtRz2cU0GrtepDSdzG1DodPlMrV6lM6iayX7KitEqFimbNJXVFXV2UL+cCAYfhUO5i9ULpxpCwT9/qGhQ8B90gXpnyA86nuu+677OIGoeVAOPB6P0eiJT/MIPGqgQBnkgbJ0aRom3BytU+ed6vnk05t73v38JwD4Lw/lnzgt3kO5u57e1V5z2XKI+6DZOwf8nx3tHh/rpQCgMBgcjHBgxlFuNiwtLWlQA6z/LihkWR8Nyl1qVjrkAAa7kEZrbKQ1aFCTyawRKVUSrtisRFls5hlmhUwl6jOA/C/Izm/ZMhQGERR+9erV8+FQOBy07Q+FrIcOAQAY6RLg8EF4UsSCI/BDLdXhwACjEcG3GxEM/pFZRm2MZWZlpUUnxcUkZNWcOPDriOMwAPCLbdv+1zL83/cH38CAHyjXhLMf5klLbIFvmx3uOffczC0gQG9vLyx9bHxsbA2C7pmpgXKVQdwHcmepKXLwWzFZzzh+qehY0TFhUgqNUZzNjk1isORKWUVd1Q0tU1J+18Ck8iWqMok1qFYm02fnWHOG9hVMPLDVBQPWeYz/8pU/KcU65IzlO4U4SXoQigIutVrnmscIAuGpLQhJ+TQAGhhJCow8KgjKMtVpPJ5OGIclXDtX+/Gv3nuPcj1emw/8Iwa88xYl2H72SnX12erkzO2b9AMDi17vnG9m9DoQ4BsKgDEKAIBgbHC8+9bMlEMx2bfEbLO3iTtzyxVd5ZP1jdD+l5aU8qMYNAZbwk06XsLI1ookcm2TGDX7ukQabptE3Nl8R6nsNJluV2yJ3ciwibTfTwQW/vk8tPpylb+KtQrxFSefsOIYQikAnGK+FMHm5wknCeLHSAInSJKI4+OkID5Rmg4MSM5KKIrnITGC1AunH+6hxqJGhkKuNzTgrVtj7acP7thRfTTzL7ZnJpBpHQ6Hd260HwhAOd1Rzx5AgGAAAK4DAgpVE6QBLlQBM/WWXN/AiC1pZBcXF+cXsuolIvovN8akZFdUXq3SK8UVzT4zs08jqVBBB2hSmju6lHX8mNj8qgrtGfnVMwG/00keS2hFjmEu12qJNWmeJEnE45knIATUOmgH4IfFkqnWCQkcE0BujMOhI4ZSmJ6ckbU7GkMSdiPSo19HXoevzc/4vwD4+oMrV3Z8UZOH7FN1TM1BwXd4KZP3sYjVH6wb0gAEQwSB/lF3uQkA6IQkaDarcpvLzX35jGKJgUvncPLp6KSIFRsTHSUXFRTozWKD2TFg1mi4oIK7ukxK8V3vXbQ4ZjdNEzkdTK9a8A/NJ616VkmPB576C7KU9AhcSIIO+iBggJEkQBEZLbwyaRopxBAEi4uL27w7lZrOl57IkxqFQsGl+PjMXZEdoQ1r4xPeWW9sxNsAOP8byAGPnq5aRYYnDvdUx8CAlyoBvREAIPQpAnwTQWBwsHvUkas3SMSTUM+1qpOODhXassUgu83k2OScKr0MLdy4e2M29HlnbqvESsWAQiVit8kUkCyaRAaf90lD43FhC1Mit1mtVbcnbOEVwup8QeDzL0ln3PEXzmhI80UI1QWmSY0CeOw6izoj457UiOFGypggDhMAA/YeTkaMWVkJlAbee7Tnt5G34Wt7Its2bFtfB7wJgNofrlR/sdVVqTRo7FW5CsWd8g7f6H8AiBTDXiocIhh0e6EQZNvtdnbhJpZIZtDLKw0yPZdtl4jQNlTCZiXFHqkqGLbpTTKlLLfZnCtuMJd33VWYZQbzjMNAZ0C8cO32fMY+0+2JAGjfFasTmt95q9PvHEoq3U5uLyqCLlAoSEtLwP/F2bU/JZ3u4RFyt7ygIgRIiolMQqG5gl8xCQ0FL7EOB3W6SBhqiXBULhZGLa2iKNKCsNukFmrlamu0aRE5m+nkemnbtva0leU2s50znc7uD+f8C+d9v+BOdTy5sy8yjDg483n4vJ/Le3keIgQgDXQAyUwNXCPFU6NwKRlxyUlJPI0pIzWHXNL22Y4fGx1QbToIwGpBcC0ADu8/tmfPv3+Y/unZs6V/gI4FhPe5gAfANDgCk8GK/cAhvr0DEMjPlFUQYzC9+QRrJ9UKmfX6xgh93D5VL2iTQmj5arZNMFUI/lfHQgsXZEu4ojrV06/gZNKpmCKpUEVafPhkGgUAjCG7/fshhITxLcrwPGAV7zqLYR/WmXgsjakGqjSl14DIgM4BIrw9adJ1gT9dMZFLUtP2/KWJD/XGQ1FK7dXERdYGoKnh1O7tYg/40kfmR0e9HoUHxIBgDAT1z1VofgAACMik39Mx0yetOLOvHO4FdVbIVC0cTt8LWa8qv88aL9tXQSEoDaAYhDtpg57+Fo5nQdEDwl+uZ6EwP6I8KhojK6LgCfqeaSOo/sDD5dTanU56hGjxQXy0HU8mX9cSnYgdWHidSIYcEhnbs2BnwGQSY4g4XknqRh5TAwKiLmUjAAA0gQ40CQRl51fvhd5Pp/fj8T2/Cfyg8L85cnn+zoKi3zM6j1YBX129fGMFAAgHeOPm5Jzn2Rg2fN/WnJyoaLgQHq+qz5/pe0Gx0FRcGiYGR6VgVQaBoB2upCq8nupcz+AgVEzuV8gHuIxweBfa2U3S+72PjSLE5Vr0PXAO2xcnhkDD4EP+tug6g9dexyMTTrgWwAPFfzKYBl06JpPJ0jBZeBZuqymVDKKBBNFuTOlqay6uy3aAIgjVel91T3BtAK5dO9Tw6sL537q//vK1qaJzSS333LkxAmI/mPHffYcC8FVwXEXLwQU5jVWSslXH4+FMJUSSUJxJC5HF93HZbBomOgZDSsC2gG5IoVfkFvZ4gBd44NEK/yhwAjUphBqD02q7B54+7akWw0MQLjcoh4YmEAYiogjNvzykyKh2Fl4iQhAG6AmTk+NMPB5oejRRREiigA9nELfycjAMSayIwWxLS2pu4kNhbFgIRa5blU50/ZqsYo5sflkppFQvKytrbTi4+3PMjHd0/uLIf25Ozv40ehlGwUA9ACfE5OS3fsVMJi6uDZ5Ya0uL6y6nxoZII2JBAczt65V2UjHAEPW4rR1kPkG7XqEfLPR4+/1zc/0dnAGCUCiK1d7TOWfn/XqjC1gpEprNiNPpxOOdThJFnW8ssMgYRAgAncEARUBqHKgHmExgPwBAwsBDXKJYCD5WIoplpWR9/GsT37ElUAeGvndT+D1OEAb8B2VTdTj4/LrWw6/OV5ye7gElMcj5ubOjk5dBJQDq4BFQBUzOz436+weX4su7U9ravj4HWR6794XDfUFsr0oFf6TSeGsCTS4XDHZwOAOCQXmh3OP1gw96BsY4eSRgsz3rnvXORT9wBwadIXKL3SIEErDgGSFYo81Wr5KSKmLoEACEyNOBas/O0GpZLCIVT5Rg6LEInRXFiiCpawuECDkrDUyBxGxIjLyG5vz69wIQuQ4y60dCcnV+2ScNO05k/ev168V/WicWH7y8/8TrnwdjbhYujy/M6p8NPuNYRRXAB86dS0r6Mu78mYpOGUFVYIXLYOyxMYsvz2W9bWtv5/T2sjkD2FrgA7PA/twZa19CLCVeZL/X9fPTb27oxUgMizHhFmcWIU4tLipGIqxlC3Kr5ad7MVTUA0iiGF0OmegUSSR4KpUE3pAwEETCYGnwLqWBLfZpUpPvnjyQnc1P3BL2XgBWiwPr3xBY+CA4ILW0g1/WWnzr1vNbu6tObNu1MyM9I7mcGu+iYPDEzs4ikg9rpVul8eHEjE+3XTjWvPmjj9KS4s7jiEMx4eUYKVesLHBph6jxPyinxvNi6VhCbwRW0WIUeBSG/DGrxSKkYV2a5WG89+rkk1oGjoh3+sSZJCEyTN5LLSKo6wWFev3jMYssXOSKiKbkRTNjoiQil1CI0COwIXkFFhJCh3QSmCJ1vYGdR2fqTEeLG/mOgP3/n1J4/VtMEu8ukPwuTxgU2gHhoBGMugMHWpsa6hobIdEgvKENFbdOnbx1/NK25iOPqi7B26WXnledPfu8qnnXo12V2+9esRepLBUl6XeXr/zseuDOGS4XSfZNjN1OSKDlK7GWXikNm5dJE/KWvzfrv7n42AwXP+wusdnldvJyhu0us3H8/rTeO337IaEo1hVLLypA8J1wexkrTogNKaBgC9hqIQibIHDWqpVygzETf+/Ko2LIohQZqIPW2hRcj06Fd1NjkIo0qDYInSCbD0c2+nTwIfN0dik/EUSJLYnZiaVQj7q1ta4sIMV3COpRHUR1yF4d/eKLV/vB4+ixz/eW16Snt6XGpZZQJOFRe6MQSBcvDYHXSDTL2pfTN0brRUyTTqfxic0+H8LD4a4jZvH4/cKenifT4y+5WCFJUlRgoUulBcIEsZJrSeDKLJkG4Pi1tW6zWKk2DhhsHIs29UTxobLssNCA+X+ARxIY/mHQAVYg2LDyuaDeYmgYHJGwwYQjDGovZUP5SRBs0IwD2ZfhcARfV3QJoTLHgbpWyD6x/8SFbVXN245svrBzuavm48p07fL2HFl0NJJAQbTLWuPt2Xbz0MakjGSty2x2+0SgzjUhp8XKKX3PnSf6aTlnjBZP6aXICqwWLpfANii57KV4AlcwNVU9NW4U2/5uFNfbBHID0vbZyUZ4NGbdH+YSBQC8ExM2bHprFwE9bLoO9agN6G4zVJ7Y4tjiSHSg2RZl3gXgwOQRwMMRBAP6zLXSUjB9oEDdqVPHD+/YcXx31dndl3b8deeF5u3dZ/YSQ8Lxuhp8iH1a6dYkV7bFaRC30J0n4pFxZIparKxWeEd7vPqOlqUxFa1PKuWoLC0GgcFQP9MxQJC3tNjaC/XVAsH0Y5sxn21jK5Gdm082Bhxg05+8Nomqz7/526Y3BGtXdIjRJAFtDw2OyMD4HQRH0C+gm/D5K0qlrQ2QqRSVLD11svjYp5XJw1QqkTfMs98juBlXsiprarrsLpfPN6EpIeck1Krrq3u8/tl+xWD7zBJIKL0vbEsFLdVoX1VYWC2oNlRDHgZ4ptBWTyAoa39h/Hq2iR8Wuu6DP3lzHh0f/i8ibx8u3RR0i9A3n0EU4GyBZQjKShx0hoBYK5wSZSCelmajuqUHPjn46tgRHQ5U8xreVh6GjjNlVKandw3/t71ri0nzDMNecHBs4tIWw5w7tFtnDVk6NYu1CLN02sXOlTAWVrHiKcZsVqCIRXAeSE3GNg9/K9qEyfbT2aRpoKlguHI0IxC1tmm7yoVtmhhi0rDr3e97/++HYUozNbWu6fckBP4LLr73f7/38B2ehy6bPV+W+6NE+NqeD3tadFTQ69W5vb+2dHWdunp17gac1A9VosbC5TJRYdOpFh0KE7rPhizvvF31xnsVSm07Sx+TtY3ITsqYc1Iflog7B08J1hDgBsgSOC7IcMwYfZeLo8gJe9PwSv01n6S8Q1ghzK074yiVfy1vtYnomer9xrrjwtpjzT+ETLqYm6Lue2OhW9+sNvfMxZd1OopyeylTeJGKRsOVlWGKCoeplm8njszPP7xmbdJn3BLcFhvA+SveB7wU1s0GNirgScFw9DPVCRdWanAc8bf1DUjHFbChWyEUVpQ78uXK4kOt4sDY2P4OSX7uUUvz3FBoKPRJPH5n9fqe2xNV56r648ux+14XGj9FRcK/RRdd3uAfVNhF/fJxfzW95BtRdeq3TJ6yeSNkp2maMw7BYSjZc1I2SPoCDg3J3Iz/wSmUqRuapI3djyRi4+MikTDgcMgXWm15Irr61VxH3thbt4/dufXX75ZzszP36Jla+vvdtTNHJuJzMdRPx0KUKRKMRhYjEdSxe92UqWv+TdonXxnoOzG6Ve6QrRlhktlpSVqByRdpkZGbCpNcLntgBUJMNh/kbAWHQcRb2qgoXrD5xMaOpXKbowP1OWX0LrFDOC2qnTk6e+H8T0VFNk/CkzjuqftKRM/3Wz698XdP8/WuSncwGIxEXUEXakfc4aHVLyWX1rSwJfjcPOCJ3ZZUCc3B7sCuS62jN/43lIKitUzf1lZz5crKn4pHqF686btpnA6cEZ+cLn38YEG+8L4xcDLvwIH8jw5+sU8+OFV86IHHGNj1Or1EP9x9b7a/azkWdnmXQygYBoOUxaMZHhhoB0Lp52+AtIyZFhNSyEhqlsUHTWPUcQJtI3CX/mw2y+vlyhJlt6a7RDGu2CuvHyyZGhnZqzR/p9FYT18ym7uVcC2otHiqfp9ifGTw4MWLifxEInH58ri1t7cTyN+Y9TAOb3uTwNPAzgWgMF4/8qe9DjQRkJ+gfkum1vd1AoP1Wa1Wa4X7zyDrbm08rbGiJ6dUC9ehpb3A6rnm/FxrdTpB8RWEz89a15yqXu1wH7DAqv2yUeZ89A4ZIFkogQlwTPjvahTZ4BWOAPmBH/nBXUzmDTwww6BrPKxSaVWMyisG6L1h6VN7J2o5gOWnqcbQYADaPzXkWUg0bKDdIQ9g42GKy3hDc7EA992HkRHa7XYDqhfxx2C4a6jBnG5t9gbUZjGLVGpQQcfSB34/88w0aVBjCLC64g4NnzXAJHsva1M3NpMax6h/gDHp9Wq1H1WNaj/04WrmCfWgeIwwSJxrBLjCKIRlYAHu1LYkqPBMbZA0A3xvmMs6ZQSs7YWqRaabEBSOYqBvWOflsisV/Cz+JJ9tSjiQaHMYSRz4mXkr4EVBNrMCw75f5rILlrrh8DKfeeZDNcGcB+cw1yN5m2iC/68mSGs+14FfwM944JnPT3HHJ/POCzz8Z5B/Cl5SA2x014+AgICAgICAgICAgICAgICAgICAgOAJFLzkw/8HI/Ur9DqkRfAAAAAASUVORK5CYII=",
        sheet_url: "resources/edges2cats-sheet.jpg",
    })

    create_editor({
      name: "facades",
      weights_url: "resources/facades_BtoA.pict",
      mode: "rect",
      colors: {
        background: "#0006d9",
        wall: "#0d3dfb",
        door: "#a50000",
        "window": "#0075ff",
        "window sill": "#68f898",
        "window head": "#1dffdd",
        shutter: "#eeed28",
        balcony: "#b8ff38",
        trim: "#ff9204",
        cornice: "#ff4401",
        column: "#f60001",
        entrance: "#00c9ff",
      },
      clear: "#0d3dfb",
      draw: "#0075ff",
      initial_input: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAMAAABrrFhUAAADAFBMVEUAMP+tAAHA/z3/oAAAMP6uAADA/z8AL/8AgP8AMf8AMf0AMP0AMPwCgf8AL/sALf4AL/39oQKsAAABfv4AMfsAMfi+/z0BLvkAgf6+/0UB0P8Iev+qAAK+/0AEff8AN/EAgP0Pdv8Af/4AMPAELv/B/kEAK/UBLf8ALPsg/+ABL/YBfvoAK/gAJvYAKfIg/+OnAQcHLvIANPUDNtEMcP/+8QIARfZx/pRw/48ATfB1DlAAP/Bu/o4Be/aTByYKKv4AFOkBNusAKeoOLOjA/VFsEFwDL+0LKcMo/uukAg009foANfgBLvwKPZHE/0p2/5oTK+EFLdgHftcCLOX7oQqZBRyIDDx0+qcBO9onJscQK7sDVfz/pAkBgfn7pBsIX/0CNcagAxBRGom89YYCOLoDgPMCNeSJv7swJLkLZ/8EzP4fKNIEfO/D/1oKO5lYFoMEgOMCMN7rpkX/9QsEIe4f/94ENKRC6v/C/zpHHJUD1P9v/Zs1EJ518cMNnf4Qx//dpmEcMKk4Ia/68QgAPOk2b5w4wv/B/n0CEt0AQ95579AWf630ox8ERbPA+p1dk4wDV8MlLZM4IqsFbcMARubD/2xDpcCuiHK9/WLh7liJpp5O1dk+OHsjxPy/mY5u+cgLdfYnecO/+pT68xwVlcJx+J7y9UNrZI0EQ8qWz6a3750LZvcwW5x7r7oXUoTzpRAi4/vr8Sx46t/s8mqNCCsmn6rE/2EGa+gVSaW0/4cgc+Xz7RZju5KDsHRhE2yy/5H++CB10LE+ktWu5sfio096a5jXqUbR74pjl7PUpHdbuerQ+zMIbaskK4aLlojH24N5+7bd+CXu9RLtoTPd9G5gyNADhr1z8rOX0KE/H6Fu3tpUKoRfTXOGbHa491aJd4dj48n29S6cgoxt+r25zqC+9qs2W75aj5pUkm4bV9mC4/oVPnv/6xa+4W5p0fryxQtBl+9ib7dQJD9vlNmo0Wu73r/N7qs6986cjrrDp6KJvORR9bWfy7saOFaV/JvJvkf8m5//AAAgAElEQVR42tyaz2vbWhbHBbmgn5ZlLCGDQT9sYwvJCVg1hmBMX1JwFtIiJl0MSRx3M2HMyyalf0AKXnQgmw5ZPh7eTaGLtx1m3S6yeKuuZ9PFg1mW2bS7OedeyXZ+1U6a9rn9ylZkWZZ1Pjq/7nW43Z++A7148WKycSf99CL96OUzc1sPH9a9h6mmW0sjE5Z6o85e1BvP1p7NaPPZPO082tlcW1tdXWvA8qxanT31KjwAQOxVsoRUmOLKckmT8cpiU617psdzfuMRWLQNy6Od2Y0bH9t40E63293sPtrsrlXX4tRS+Ot5CECOVaIRoi2peD6bzWqaWtd1U/K3f97avYu2qLa75TU1OS8hhFNjDQDEWqwpsizjXnnpFsLXamB/NqvWq350vPvyl7vrH3/b2jFUsBSMJ7KsgOEEAcD9l8myigMARFE43jN1v7v14eOnX++qTx//t3tcVfCkIPB5EhMOAFQwAAgwRk9bOhGeJ5phyBrnecaj528/nbx5+uYpVfJnIb2BT52cf3zZi1RC0FTCcxrRKhUGgBMJfBF81RJ6gChyRNclyFEEAPzn5N3BXfXu5P3LB6HCcWgqx3OEIxQA+oLMJWLusUwSRVHSdVH06rFPATy+lXI5XMFzf//0zfvft8rK5MwEfIB8DwAkSZcAgGf6XQBwigatrKzkQGAebt38gGeOHpnL7e8fIICuIl4LQEx2S9KyAeAgBaoKz2U9s5wAyE21kpujBAB6AAWwqYsp2O/EA3iiqGoMxQAAbFAAM3atpDf5xgVdhcbB/uMEwLUhoKHhkBaWsQzyim6ohKtljfIhA8DMXlgMVBoCKr3FPDyp2TMAlrMKEIwBFQp2TUsA5KaG3cL+lSQJbiIArAIMQGXpGyFaCAlRoHiblwAs7gG42t//jQIwSBrmcuIBnwMgiVJyF3A92cIzEEmSvlUjUKspClSBBpbB02vtWxjAzlUAhAFgKTB9U5yImo2ZSOOhf+axf0Af4rA6k+Qz0EYBEB12fI0cSrhKjeimGbMymJTA1L0n23MopFVAnZz3swDYC+QAxrM4RAAq4WX0FgwiMBhzyUUANLjuWQqpXQKwMgEw3fyc8SwHPL4GQOUmALChKHGsKGgaVk4FBiREgVssw3BKhojEY2s1ykEhqSvwuOcL7/flEIBGWFF03fNin5bBz1mcuz4J5qgHnN4OALQfqBijHdtRFUYRqgGDSIVdGM4p1KgjTMdXNDbuGQBciQ7261429g9vBJDLJZbmrrd/mgTnAkgQAAAq6goYCjK4N+QAQtL9NTQfMzThE7NZzrhvD0CwkHCz2TjtA2bjPul3Z1q/q/bT3QmANWU+gIQATfPMFyAZcGinBsdp1DGwNYG+gRYCOriiH4K2Xbp/AOzEEAIXAORm+nymx4mzX1zwjZXHk0ZoPgA0l6X55H5O9uDEBE6dqappGIYEGVA3DFVhn1QQBCGsMtwjADZ2hfNWfTYaTDrByc2ductJa3x1OIBvJDmgOw8A5BtmLiOA/THEIE1yqhGCIlyFdoiDCiP0DQhPCQuArtC5m68EQJkAePfbHcbDOBw+OD1BAPpcAIYk4u3WTBXub0yysWn4Rh3W5Va7tb7eXj87a7db7cjktSj0AYbv07UE/QqvSLc19KbX09EQyzCaJuKEyPnTU9DB6eI6ODhgH3l3/v73nxtzkyDcUACQJaoflstglxFFsOHrftgaNptNt8k0tA1Rb4HaSANXoVLhONW8e7a/cSzAygtf8zd23346P7mjzs8/fXzea8zPATrt/oyy3R6N4LFht9ujtl0ub6w33WLRKuLTdZvtshENEUiCZNgKDdM0bh0CN3nCtA/AIqgQr8aLUe+PD/8EvYXlFmIHv3374Y+trknmAsDJEaIY9t5gmGgwHLRsewQArKBvWY6TLxabbTtsN5FGkCBZtw1VWxzAFZef3PDLC00wiidqnNh9sPv8OTxu1r+uKn1rd7e3o2e5uWVQo9OQYXvgwg0vFnHlunsbXfQAy+kHTtAPrGJzVAYAViYTAADLgh2tUKxU+PiL77xyYSE4S4X9uEdMuLLGznGvt93r9R48ePDk1ZNXrybPV0+evIKd//33Ff39L73j4+3D497xTtlbBAAvcrJuAwAwL+M4JScounu2vbHuFi2nEDj9vmNZEAJRu+k4Bdi28vk8HBKJtVt0wlddnUm9KI2NR2rENE0EIVXLjUaj2z1sD4avL2kwOjwcuJ3gwnI0Ptso+1XfL5cbfrW+CADoejQAMAQABVgyhYIFAEIEkC9knEK/nxEAQGi0m/AeHCBkAENz3dazMGrk7p4DaABA7ZmVBuUYhhgVM/J9E3/TqVJ1D8+azTHKdcfjzhic1G0Ozw6P99xO56+dmed4DLGp1eumjxTMOpkPAGqvBiGAABw0v1/IIAAbAOBLfGQQgN7CEKCCXZADIP5laRGDWW2jw+dEGOc46tYje1ahHYmcBB1GRfV9w1eJ6K1WV1dX1xDAGOw76nTS9dgdogeMOxd15LbL1frqqlevV8EDFgCAE6SaEo0GxbwgFJxCwYEYmADIFASIitQDrFLGEUAZcJL1UNI0eZ4H0KEE/cFLg24q1HUwzMA+wrYjrSJt7O3tDSYLqBWptNnUCB2AcNCJQkeuGuiPThCUICPnHZCQsTAxw1XD5QbOjNxWKMWKSj9/YdL3MwBgDwIIwDLwAeECgNIsgDwmCSQgIABuEQDsQng+a7TWWzOCFz6JwO9o6k3kutBvqNTw1HdkmYMhuYpXI5ScDP1yvAYalgwA8igJiaxiAoDg185eSgpA+6YA0m9RohbY6qK5LvvrDqDlGg1drCkWrSzw58sBCO48AN/WA9LJZx27CDAx0+kHqKLlDtqhfQY7mU2wlMCtf0APoIMbyHajZhD0mZBAvjhsR/bZsBhg5XWg2joBXP2w/aN5QPKrhAJdBHQVGSiqDtoaZIrDUZgAcCiAfpC/BwBL5wH4mxwOcXUMAQHOLuSpCQiAeoBAC2upVCiUhHsIgaXzAJxEgirISa1mMSNkpkpDgOUARFKyvkUO2L0EQJbJVwWQdH0ieIAFHlBILHAKCADar+Lk1gkUwNUQgBcMQKnkCF/uAX8KAFGUMAfkHdZHTQBEDAB+pwAekLesLwawhB4AjZB0BUBQSgHA5WcwL0JyBAI/ogdMAaQhgGXASUOAVgFaG/r3AWA5PYCIkkEbIersCKDft4YjGxuhpJHHRiB/bRL8zj0gGf8qOJQCAAIFgEoB4OWj/aD7ALB0HpDOveJ8Up72ASwJltIyKExb4ftIgrf3ADrmpMPhACd8ChcAFC4CsOYDYNNayWzH9D8MKICgT3MA9XjsA0J7lACgVqQAiJzMF9EBrQwjY8OgAJwFPUBnw+HFANDZKVUPEQD26YUC9Knunh3Z6+CeBTollscpMTucAEAHdtejiqaplwEQH2chNM+j/7KeCjY3R8Mxm8k4OurgMh4cbu6MXrMJjSM20zHuvD7Eo1cnn12FizN9BkCALJEX6GQAACglAKB/AOsnADIUQOzhPAT2oQsCUBFA3unjhEifAghnAJSuBwAeoKuXf9w3/k/N+YS2kV4BXCgfGs/482iMZzQRQZbtsaRhPBF4bATB5OBUaA+aNet1DibexIZ1BGHjpeoh5LiBLsvSriHQUJ99abKhV4fspbTZwhbaUy459FRIYI9lL9vQQ9973zd/9CeJbMeHvrGlmfHI9vt973vfv/e+usd91zDr9Wq1XndQCXip1lsI4CapSa+3AUCn8zUCuC0PlMcdjHHHL5ArTr1qhGbb8jwEgEWBAKgixQCg8szNUBUimZoVANioADQNDG6cW+Vt6pRSLZdVAADgFQCI5wTHJsZiAIFq6KbZbwFVT1MVZjmOU3VaV1oUud9qOS3Q9TbKzZv0CkX++OtOZ/PxZbqQty5ffrK5AQ9HH2s5VZokty0JQJYyApiQAK7PRIfwregDDAMAmNpIVUDXxzUVnXQM4HziAwDAHFWxFABRCQmAbmoDVaBq2a4adDZBltKy8/C7j0F+Gb98/OThzsNdupmSJw97PrXZbQUmZ4YmAczEvi4GIFrQ69GMGABoq4YRZjSzb77y7QCkD0C0EoAjAEyNzQkAntVYhlZBjl0ukBMcT0IuIwC2ZVit9d07dz7vkw9/0yd//xBk8GbPh+7sbl5pMyXPYwBUHj0Axham4gowNk0AarVQRQDKkDnBIQDUFIBpLN7rPQCw2hEA8gE9AAzWvy7AXJ87m9+9/uOg/Llf3ngzJa9/7Do8U7OFE4QqIHoMKQBj0+AYYicYAchjzDH2wkYEEAar27MLCwvQV5m7fj22gIVBAGQiMwRgXB8EkHFds7P707NvD/vlKcmfnsZyeLh/+OnTPvn0EG9L2d9/+ezV0oY3rwgAc7IJJAuYS5pB2ZmMAWB4SWZ0AAxcJVoAAMBlnwkwNADgxRYwDdTRBwTSAmYkgLJl66zWD8Bwrc6dH14+ONojaYo3vGqCJG9w7+joAH/ejGRP/ORIPE4PPHj55U7HygsA03PC9id6nGBqRpx+LFoBAUAZAQCZsQoAYFx2fkZOWVzYCszg0my0DgIcZgWA6YnpKTF1swwALGuwI3ix6gGA/YPmWnFtrVKpFIvFUrEIF0WU5pp4FxfNZrFPem80mwfffrnbCQxmy37pRAxgDAA0yuC6J/oE/nfLtkMRCT8KgLyiqKopxmXyN09f2GpbgfyTuDhCtMsruF4+G83gbwEA0xjwARfrXvfOD4d7xSJoX8lmc6VSoVTC81KpVKwUKzl8L1bwBdiUisMOeCpbwBMCYI0zagbBH0daCgBkAednkqZBdITQNG2WgeY4M4ITzIvgP5yhn57C3w2FPJ0sjYk/R6swQXv71q1ledzabrQ5V5X+ODkA4GwKAChgARUS0FiclArAo1TKIQdgU8jlKjn4WamSo6NCUPClgJ8nACYjAOn1nzm4kCtDOJt4PjEA9AFty/ZFuE1mBACYUaTx9sr28uzssli0mF3eKlOAxGxc3rcaYBPtlVgajYCL6c4+APV6iwA0yfQBwRoxQBVLOaFzAfXPZguFLEiuVyQA4iQtYJUrwgIWzk8Ij4fT6vAiANBq9XQk8L822qZt2iMDwPzBcRyuthsr0ZrVSiPwdKuxvbUdy1bgmWbQppipchBg7xRczGCkaAoA6loSJlCSxV0oiPInSasf3wRLyGbhE1AFwCAEABYBgBZpYmFhClcVFiZmRBVIr6xRWS03TN3GME8CoI3QFdZh6KQohu5hiJAXOB70Yz3uuk55tVwur66uYtxMue3puo5xcja4GD0MTR2XfAYA1CIAaxXUWGhYSAl4BKGwKH/QFI9SQR6lXPYu3b17F6ykuCcBgBNc7lcVqkBQTpVRJNCo0XB4NACapnELhjRKPgTtQDWuuwzcu+0yYNGGe1Tk4O9A6zw0mobBdTvEp1lotQedYASgWBJVPRtpjsWNdg8lm6V3YQHZWKIHQXUCAKcCAHSFbQzZmo0jlERdvaXajlhWX6Ev+v512a4pCtfUDIV2DqsCGBIWDdQ1DbqM6M0BC8eSNdx8bd724Ix7wANw+J7lWVD6NneN0MYoDtt2Xde28IOeLla/koDTHgC5BAAqi+ZdyFZSAERF6AVQuJuTqCIA4wCg3PjdJZDGpUQaVt50MGjPTgIsvHLA5mtK+BYAHG7bnBvMtU1THXf9qgOjTt8XoRgwiJVn4gLHtNU3ymLdRz+YN3DIjrGWSuYiAdgHAFiRU5JydBV6k/eyvQfqLaoNNgQAYAcAgLFR1GbQbgfygDOLM6rrfZHWyhsiuBMANaaHUIxQvDa3YdS9sbFx5cTi+YbhuzoAYAp2PVIAqPhzg5LNvVmy1EZkIwAHCMAc10IMWeaJSHXBgY8enBMBsJQaVALT8zQgtfiLje760voppLPhaboPtccOdautqdV3A8gdC8BuDAAQyEgqkQ5PycbHB8Ax7l3hVgDj9sXPrt27f//+P+6fQu6tb2Dfk4cAwFTPBIAOAHhf+UfZ1scHoNTyzMhwL9Bs54NXP//r96eUn//9wYZne6ZwrKNUgRMB6A+zO676yeqwUoOGLKN5FvNWr/3hP1/0pJ0//9Ux5fvv//bXex9Bt8g0GVqWcnYADNz1Ib3zBQa4ZU5QBUIb2n3V5qrfuvZPjMa+cRp5jgA8X8f4XvS/ZwPAiKNM+0MtTwIAfIma0X0lXAQAz298chq58dsv0AJg8AF1E9ufMwNAPXaMZTCSXUFOBAAaAUwM833XRgt4jun2lHQvM1COJ1cRwJLju5kMNMFc0+rvHUCHAChxtM1JJQKAuU8AADpz3uo9ASDKzr46eWz9BYBWBICbZwxAOT0AqACmxTP5Ws3rCABkApR0PnlsIQDrdd9nlEapsLMFMLjqehIA0GUGl12r2TGAySQl6bgAbgCALvSKKXvo/wIADnt0k+fdvLSAJP3q3LEztc9JC6hXucwnrZ9xK/DOnKNRADBD524+AXDu5DKJALoAABNKsYtWP5Ou8PsEEHJ9Pq+b7wkAWcBHMGS0dMz4PZtmMALQk+t8cgAmALAsGPHLVmB4cu6IBpAA4EwCwEnR/SMxHBZzXZVeiSa/BqVYEVPGuUoOZ4dKYjQIPXdDpHNKhRUltfuJIoa/A5OT9IAyrCPEDQTg2XYC4E0pyO/erEH6AKfOWY1hCpXrm91vaF0ApLK2Ru9vkb1m9ERTfqc+0sSFkbKi4IYCmLyvxgDkbgeoPQzu5Bmlf2oEB/tlGm7FMKwVAAA6AWgdC8AQJBEAp15ltXmmA4C87nV2aWXoiBZ3Do4O5DLPXiLi4iiW9OneUfLog68QAOYmMcsSu75kKKs5CsPFsxiAzH/NKCK6BHcjGgbA4kYtz00bOkKiJ9iva3qzAtE2TKY3MUhvYZAGwNh8CP+ey73u7k/PDr96L3L47NXOqpZXVI75Njjbw0TSLmhN87Eq5piJrF+NWiGlNj8vsk2YSAUerAIsjwDcBMC5RMHouzdLP36Pk5XjHHYJAPoBPAwBgKrXnc7OX14/evTi0TB58SK5/0LeIEnO04/+9/WrpRaHItag8wYQcCID557A8BW5r4epkV2I1WBQfF4AyIj8u6HDYTAoTE/3F1tJVzi1P0cqWX9yMr1/R7yTVYqDAOD5PmYD2ZzBMNtpdZa++fzdguEByVtyt+dsd7PVxjS6jGmFWK4wloWhNyOPCFdWYIHj5Zj2jPWesttxYtDUwFZ0yxxiAQhAGScA3lAAKf2jTbzSyeuTvQAmhQUgAMsLmarZ9Wq73ep019e7JDht1l2PT9flne47ZtqipzccG007D9roIdMYB9dlcQ2HXVD4VgAAGIZRwU2G0/k6SwDwoQCusZphWqbpQxVYvJYCEBdu1COcjKrAVdHiR9n7/6Pt/ELaSrMAHuiFmHi9yWAuVxCMeuUm3NwGJjEDpeQhLqQPxgdrH0JRV1i9ICvSbJY+T0n6EEYpwwpDZFmUQAgbrYgsim6htLOT6UPbhwllH3ZYhK5O0bK4XYVZOnTPOd+9yVUzZFrqSfPvi/nz/b7zne98f87pqWwuN0wA8JsSYHIcgiRpkhqS2ZIpLbeO4KrrCMmA8TT4e/PRgPnKSOO1WY9TkAQnVi1BS2G8gCfT0MbBSKaaq+GSgGeJwMWn3WDOY0xMuIZ+QAIUBgDAdPgUANTnhgkJbly6VMtbYZqLS2ZaA9MGaJRkBXqlhEuX0E6Kommaws6KGTLAVt/luAyTJ1qHD1pflzEbLHuBvUo3guDmNZy9GGF0HhEBJBIeAkATG6RDAPA8lc1ho/hrY1fA0QiABBrAi4pbYAsiN04vcXxC10/MB6Ojl+Du0ihVd7Se0O0GvoiJKhCAgruxlHrDgf1U8NDSJSqhSA0DElSDWP/LRq0VSVVERRSp+rQFAXzwIU5VnPQW+hAP+hZYIWAiKpIjETT2KSSJIF+mx8YeBgLj/E4edEZjUehcAw3oSwg82EtF4kRaEhvHJaHxUSPvAl2RA8NiFFFqBqz9aE0vDFZsRUjV/FRtJx43gkesvey4n4EEBNA5RcEjlAm3Rj9ThmcoQZGaG9taDaqKKgVpoiLWAXhI4T28pgVDeG5uJMW6TCwGz4JS0OhpRunIiBwSVVHS3KgrYiMA1/p85DHAlECM3fzHn7421gTn5tbW5uAyPje+tka343hHpaYwCDfoivnqxtfm5mhNEJwKLgFa6CDnk0MbY2xeoD2y4darR+Kd7lYct5ysgUEUD9YV1xIxLZPoVCWPhIfiBAooZh+A7h0S1SQYXPC43QRd4TY8rMdhzE1hIRQxCYdTGDut+fFdAg7M5wDghi6MBH43DwBWfnzy+ddMvrHKuYJv8OmaVb77Hf7R509+PLqZkvyuBHZDJzswgCaK8mzhtruHPDe3ILJOSjUPgfXGhWQw6TI0GSthG174925zPGP1h7FfAvci9WpvpS53V1b2XmXjI+FTpStYqntVSYN3oQ422BtM4KEAaBMALQ/vHf3tn4Y8s0qDgu+fffXu33V599X37H1He7+Nw5gqkKNCJ/NYFhTMZgqDF+i5B5fvBfAP5E8/DckyHQSFemsJhzDojeko7Fb3YjnmfQZ9MQ9Mg2HBEPNB8C+Pn1vl5dvlZEw/W/r8+M2krkp+yg7T8KRoAgELvIvzc0LsGtsYevr06Zd3rTJ0vuBg5Yd3xcPDwwhcDgvFJ//56Sm+7cs711LwfRKqLB1N5A0CvI18EUmQRB58UjU2DHp6DdV0kv6FY6KgxpKleZA7eLM1Pz9ZSmZlwWG3OQXzxDkPb3aAMVHDt1cr+SLJLlyKxY2To5LOSneLNclXVm+nREFjTdBoFODsLg+Mn5rLDx5xfHiYZaGeKG2bp1aXr29vl25OlrbhkVGyvT1/c3Lv7n+LWP0IXAv5lz/dwfeBr/IrFbNAg4OKkxMfWACWaoq0j/Vv/BXe8PzW/YP7fzww5P5sKeWN5baP9u/d++GeIfvfLidlzkE5BOgzWB4/h70voSZnF6u7D+uyW6wclZITW4vVdbOogMUbi3eSqsPvswtn0nvUPEG7i6dMBf4+nGSBGQWNHEkt9C/NGHJrZmlB1xf68ZFRspQbTr4CAIV0hAQAHNwcGYgHB/AUgTvhF9BDN/IE8GxyTr/e5mMAPPqrN4+PX9bl7eM3E7peevT4pGLK88rJ8WopJsLMzmE3N7ntNgLAyeHZxQ0AkCYppKGqlbsAALAU0hZ5uLE4m5Q1BCDyXMPASej+AgtpR3OFp0LAi8X4/ABG9XaPjUUDPVdiUIDPx7qhbCras5BKbt59XWTfHzl8uPHyYMKrCq0ab2aDsGQHsVu26Dn8slZbKLm3WKnmNzbyRbrkN05Wt8Lh+f2TDVJcpr7VyuKWrrrsZsIyts4KAPukeJhpQCFNF2js4nMEMLSY38lE4DdFMhlomUwBAITl4GWW5cpubxo5ejYkpa2tI9De85nX+1lPe6CDTuRhBMUVPbUJGoAtkEmnDwsIIORw+ZtuT3KtAEDkveGVB9V1+NmFw8MdkF1Q1dmJidv71d3CYQFkB6/r1cUtPBvcyreama/tlN3OhwBWK9D9d9d3maznQQP0OoAMqaYJIMhTQqxGANzvBwCPoEHBlZgOAPK78DOxAXY33h6EZZ7zS1zT2HE7RqTEAEB+HZQ1w2SHAdjar67vRDKHmQy+UlivPthKhRCAwILOYfrD0cJGXwjM3UmlapHK8XIdANaddc6mAN5TA/AIXqCr50o8u/nF36v54jpJvvJ2KDwoaIL2XgAyacOGZLClhkgD1neQBxPSgBAHpl+wm9kr0ZUCkxBMTT5afWCVv367HE5ZukAkcyEaQF2gizRg+e2/KpXfVF6jwTr531ZYBh9XabYsewpA2gQQMQDM71fy63XJAwBdtNmcYDWMQ44+5tPzCowYy6djC5a3cxYNyDAV+NgaQPH+gU6wAdny9b/AiGXI/qPJpCxKitAMAJvC/gyA8Pzy8WuLPP/z6nxM5BwIwFj3ZQB4jxLPljdnbt3CaBO4vQUPZ8o53WoEL8QGdFDGBwAwEisvXV9+YTbCH7ZzV8F5VdVmAFrxcJNARrAOIMO6QDhV2v7C6m5Bq+YAgLMGACuAK1ugATJGXUXHZqJsZB6LRnvKVg2IXJgGjDENiP26E0ObDPrb5ax3EH2ApgA8BEA2ARjGOrOLAPTcJjpaL15cZ5frt5YWvB43AqDUnlQBXPHleAw76+lq78bYOgw66w60d5aTqQvXADyg3wIAFvTsdBc6BtGp6BRIz/TVkCS4hea5xNh3yBYNwN7KNEBfKGMc2dTUDF3B8eq54nU6nJjIljnTdrbyz4sqhtm29XaDSQ6MBZheTufOjQKZjz4K4Bl8BqCM0d9tlAmlm2K/Ey6XO2FvDgB8AQsApgI7JoBAgMJg2sHUwgdPYdAb1t8EQG6VzyeGTACBWiqWsc7pBf0DRoEPAwCuYZlygNDv7G5BAE63W2jaBUgDLF0gQnMJ6qtDE6ncUhQjyccwsQjejxkA3LS3Y2OrWzzH44FlAADfz+qO0YwAIBsLX/QowADgMHi13ImvshClFjyq7Wn9JQBa3bie0WgUmEUA5HwTACQbwIgfp9DK1QEgAVz+JQ1oYQC62xCXFUD6QrsAhknGsmWoOQLAgAUE4B2Ej2yeP4AO2YtnHCGjpfRcuZMS6EDvqsV9ejyCG70HAsB6ARCgLkAhXSx8EsxzZ//CxY8CQAC6ZzsDEKBIUuyHFK8y6MYjl79gLlADcEYD0AZ0BnphvkXhuBSUbgDwWQCgHeAkANADfbAbczxS8Figq3/hQ/yA99aA9paxbgDgRRvQAnODdswxSV0AZv/Nz2raOZv75xyhFGaQwOQBbS0sLhgBDAIAXw0A/bczNp9PIg3o6Girhc6CHcp+pLkAZpQkAC2NAHR1Md6/9A0AACAASURBVADTlAKjDmCQg3ZyN8ofwNaiascZAcBpRyhjjAImgJaW3g6m2ARAFAWXnSV4ZhloAICdAAAmIwUD/M52K4DTo0AcALBF8dr/WuGESru4RPAcAIr+BDOLgYntXZgtspcAhOoA2Fwgy+LqKECx2wDgSrjPR48rguR3+S4rluQBQSWOAHbSkbRprXfyAICFz0frQfXR/qsDFHJvvNsMXAgG43oO4++npsy/D0T7p/XUtbMasLPxbCg8MDBgfjN+CLvXNL8/ONAQADhaFJwcIOPSW9eAXgQAXd4A0GUAAENAAGznAfCqrIiKGsQ4BIvEUwSA5u0ZXLnIEIDh3ObMaVnKNt4iG0n9n7mrC23jSqNCCKmWJ5LAGikiyEo9HUuaOBKVg6GEPDgrVGMpAq8fNsSENdjNEqhNA1Ws93UTRNkm0HpxKIVunkwLgX2JE7al7OalEChtH9q3vHmbXcPSh0JgQ8N+5/vujGZGspulCva5aH7vXM09c39n7nfulfOfftx9R8V+Pz0/d4EJoN60XQb87dZX5xblk5vzbY7vpQZiz873I0BlAXrSx1lAc2Tk2Gs5OjAy+tIYCLjIBExfPnZsFKJfLgJCvQSUxpOWUav9Zn5ePojKV9Erk8tcC/zRfh8AAnaXF7e23/JiuzNnf1btAkHNTU4SAV6/21uLy7tCgI1vv7311e4yf5CdmyMe8N/zfC+X5imcWh8CUOckmAAqXo8eh+0h4osDoyNQ1LzoEICGENUBx19iAioYF9ZjPj8xbuXOLy5f9WH13B0i4Nsu/nrr8593e83n3713dQ+srv6FemLf+Qzwd3/2BsvhnpMLesO4MDnXK63NBMTsFABxEiYA7wRPHBGRIzcBsFnkMoB6LaHhHm3xSL5hXdr6x5c//HDDi8ef/9R8+I0Lt356/PjGjc/8uLE3Puvj+fHjn265Q/3mIYXrv/AHAKsvt17voy1Ola4Q8NIJVmsDAVPTVAZQoT92FDX0yOgpLgNGqIRgAiiToBoM9Y7Yz+cDlcl7/36ws/OeF18srTQfutHcuH779tIXftx+rz9gVN/H8+2lTW+wFO4ShfEJLrHD2nmPb2dn58E/L/gJiCaTw0RAg+3zqT0GXVl64FwI8hMfpUYqRddOAWMjkCtg5cO61mfsciRfMBbvPNi5vrGxcZecwt2NzUeZbNtsNs12GyaB2WazurJyd9OPjc2NvdDX7+ZK1Wyb7YcP2wL6B4TKwdylv7/uDnCpHwHRaMhDALd0pRpE3I/gGBMgtcDYGLcWHAIiPQSMTy/feXD7rn94HFtSY+RcKogRgCnahn19ppmpiqtWm+S6YgJNOYDBcgLazsDgvprhU1Xepf1UMMysyshD/BVM92X0XVUNwltZwWJz553lXgJCbEmZ66oFXKSW71SdCBi7CKVpVH3UG1xX1SCrKh/hvkAyNtSbBE6W5omApRURA2iKjXw2IwSYTTOcgok47IMpRbTDWUcsIKt+vwTlL6ukCUxTjDDbxCsbZ5q2P9NRLzDJgZdHn7xztc8cIxFY0XEZMMZiCUePQouHCDh+EYbpEIzgd4KXYbxLCULp35429HS0d6jqyVKNCLi+0r1bmEKKWXyYCIDpLGxHYSCNp+aHP74SB9YZyCg2sxxvU0aTiqml2xYVtJv8nzwoNcXUg689CMAHCI2bwtTyg2DMEW6QggDoKFHBeGKUU8DvX3YD8wvoyUY/AhYdAnhArBjMwzSax/+CAdtCPNiHAHZsbu8bWiuja13UgJes2BhnMmGHAITBZtrw7XBqNvcmIDScTEI2SdSNj7ENvlGZOqVEkLFEITi1MAXxazbbXViYyumYFq9nmp2STUCWVRAwYjjsmM67rcj5oPhxTMc5kr2DiMX4XulQZDIqNTABKRCAvbDSIwg6lvp2cHQSZQ2xsUcWoA5RNFmZuvzyqVNOfCkF1KH6vcAaAhTtejJd5/lWlAh6rqIHIolQHwGFs6oMgFpGsN3m3J5RlvRiGe3EHw8H9xrk1MGpOOvWEsiyoTFTmLL3w0IHjmNINa2DzEZYjLPbLgbYDBlX0w2g+O1PQCIxPEwloX56auE1ODzd1xZyFcuQiOZYQyBXwhSQaS2dxIiHdFqHkSiMpfP9CaAUEOY0jrzI5YDYT9PaDDtPJ5XFk/PDnU4w3JytjVUigXm1yx47yFkJBCtqhACVGxQBUCnImIqA1Z5ZZmJ6jPVmjGmJK8W6bkAwwDKMWFSvQAreMKjvH2noac1KQ2SgkYjpWjTR0LRIPNCfgGq2G0kTcUZFFcyq5xwEOaYSUegHVbAFbaEND7ghoWzybcuClGnaqgzYw7+FOROailBUQV0CEmogi8zwEA1RA84at/S0BRGFQiSNh5zWqZ+U1hsJLYn9fKQQK4TSMa1RKGBEUGiIck665614DwGcc4PSSgEBqTbuW+oBySL+6MFx7Np9CcDZdleVwU7sqrBNuQjgUljJVwTblFUUAfhk33jFGcOgvmA6lpku6REng4e871Y458uBiA+BcW4H3IeAgsoDYSUT0XZFh56/Rz3i/0W77SKmrbQoUkqWIxsUYsN2JclaNU4hqIGAdMMZgDBgd9ImwDR9CgqDROq5z6OIlQyQVQQ0Ikj3PIBIXlkN1EUlBVwXAszggcMmgNqgQsAFfHkfFrXFkDb4OUNLQkBVCGCdjAN1PSngQiPC82Vi5FJUZk8cJDS7EFQNIarYzQN1lP+5MYjumJ0C8gFMnInUH9UGTsDZs/OLXgIOFooAs0sADE5kmhsRXRkskn4CDksZYDbtMkDX4pE4hqHL9JpacrAoOQSgEjpwtLuFoF0GlMYLEyfTJR69P8EGCoPE+NvSF6hmUt06/4ALQW6MNZ1CUOwTLPlUMD5olN6u2S3BQwQvARWjZrBob80YNwaO+fkrKgVw4XvQZWBQCkF3FoDkb6fTOf+CMDm5tSq9Qfpbbowfilog46SA1W23jvFbvx08vnv38bPrVe6F4g3goakGFQH3/rP2ovHh98/4lRi0FJ/nNecLhbqBqvNS9M61tdkXiZmZmSdPn93ffCTvsjPVw4BH0OutPtoUAmZnyjNAeaaIhd/tv+sc2OvKVuvJk6e/e3b//tIhw+2lpU/wYeTO2my5WCzzr1xstYqALBXoWJnBW0Uv+DCvyrKntrCDUHH6ydOnX3//9z8cQvz3X68jBZQR7VaL7paWDlTci/a22mp5QTGUpVwr0XcFAMaQBv68u3vOgVhI74lV29fqvud/FcQYe3nyiosAO4p0161i96HiYLnY3fITUFQ8CAFFO/6KMznx5MmHf1q0JfLnJs9PeqX2+2Bx8jnwXJ72w1ztrIcAFSM7bXNs8ITtZC5bPgZa6snz5ZJqus9fJY6Z2Y+2LhmWYUwbhmWDJ7a2/A2naSNnGK/WsK7QXq23aVW3XjVqfBxGdUZl/4bYdC6HEAUVuQiXJytY6iVFgORb9SjVWpKARFsiqahwOVdOUAS0Wt48wyERAR3M1Z2EDWm9Xne6SlF/3wkn2RIea17Syu2SyaGhKIwm2Bcvo/uCzw8lle8h2lSzxQ8NpaN6TQgoll3xVhu2KzvZv1gslv2FoM2AKgRckVZJoOgQkM7j7TPETJK2CqgIe7iAGx5ie28NgwE1eU3hdrAYCrBgAvXiWSl4aH8n+ir2+DCeVxzGF0kdMgSaZAHcokTALsS6BXo3V7ecfOFyZSfCTnph8gQtqTnKnAXG0+lCI14oFCDEK7AsPdbwgE41yBPetQPwVPA4y8LlFnXiKahGPE7X7Pc+ggOKw5uEVcCaDhQsK53Ix/MnpR2AhgDHzYuZslOvOZHsgxmP52KRw3POFtEaAAGldGGiAAJcneVxa2Ki4HETGL3m9uPvXxOPuG4/P17/EmBB6RAUsKJdWNcX8nEiYG0NrbXZmUGgvMfx2bVrnRxrbwfw4ZElcQv0UPipNDzOlsuFpnU6GhtOeNVDtUZDZu5thBJpq/IcqFv6UCISH1ITFwcCrHUJC8kkjxRFX2B2dm2WlljLalaOrNnHxfHRWfts163t2ZiWU/ByrVNJ5PG1Jcb6ARDE1dMTBc4GPWC1AJ3qiGSh4CMg1HglH2pAP4CiPwVd+/VfcKdPVyq61pBJ3gIiNMOmnbEksV0K3Pvx2q/BR7LsC7e/H9f1eATfH1APQBSYPzFavOwBPTejkpvOwaJcg4FNzC2hC5sBYqieW7h86nlweSFX0S1+1xcNSAWgoXogAnSqBq92trZuErZu8mpP0Nn3b75PuPm+rBX4pN3x9XWE5TIE3elgZnJNSyRiVAnRUq9P9cCZifo0bZ/m/QrdeCiWIAclipDIIQVYMMXILbx8DFN87OtGMffFes4a57edUVifM4iAYS3WoBRwoba+fmld4dL6pc428Na2Fx90Oh98fAZmxG8w3jzz5htnaPnGme1Op7N9go18fLj4ced8h4KeRrj0EIZDkFmNw+Qloecwf4MzgYMPzmTUpxaIt0giTi4SYgcD+AgngUpu4djo/9g7n9fE1TWOZxGwWk0DTVAQNK1gJekIYwvpULvIGfAsKjg/FnpukXFhwxno4nQtbi5uRigUHO5mFp3FEYTZCZdzmWWX5Sy6mSl0dWBW00Xpn3Cf7/Mm/oq1s58+0ahR8+OT533f5P3xfNFTPrVwWrcIQEEvjyXuMfwWL6oU2kBvcSWf0dkbEb0h4zxDlwhoNKwmrdSqtYqewegR46J3OoQc6pZ4EAzL2ktCIQzjqjF2hw7as8O9OnffxxWbmTWz+ayuySoB4FjDAPAWZy81q4iSiKV4IZ05KHmsHTi6NBMuN0z/J5Rx3SEARsJYX100GbHU2huHR48jdgA3+4b84fwCgJ434/m8iTIin8847wkAHRgfnYU5vd/DKLn32+iRXacHXv2JADjus23+vSU0pPfqh4Riz0pud0qocd3cpIJrMxIJrShRugxZZgC7b5Podhq7z1iMkgDsajMAaD0h5KZqhJJACsgesNU1cqMNjrAWkfm/QncvzN3ln6BafPNJTuxoNp8vvd/+iAOcso9rz5zXnU+iU/q0JQ/ckgMAe0zKskZd3a3kWyeTfYJCF0UudlyNRsIQ42IPSC3VE+tTysMBb4hh38PcZoukL64VveGTaqRwsJaK/YAlDwrKBmI6MYAQA0BLKAb4UB7wqyKCm4iRIqJ32LrhiejRPJEQanNpSGUbQhB3Ykq+6aTH4oexJU/gCL9Mbe/uK7npuJe04zibCpLAqjEtiDMSxkmIgSoGPAAdkJf9HizeOrgNO64LD1h6wGIp2nkllwuNej/4rxgxQh7wa1mm8kkSI0VUH4Av+4jdWRoBWDVmN5giAEKAxzDGUpF4JfIMIKA8xd1QzAUAeA1MAdsNAGDZVkk2KRNci/0QgDdpPZfjkUZzQ2j87AD+9QjgEcAjgEcAjwAeAfzEANRHD3j0gEcPePSAn9wDsFeTACaVexNBADO3wz4Awz9+73aYAOjxIADczXq3w3XjnuPHdg1xGz4HQHQKgLFw8gDE45I0O6JtfDeoagg1CMVhjBdE7Y4hKjdYzHSJZskDBwCWhPi60Ha3WOs0+cbxACCUCx+SgMD1AXo5FxhIKG+ENhTUCFkiRoIRMGx0iYcpE4CItKzI3DowWgFC68rZTPogGVtatx4wAwDyZlaG7nBobgSJDZUFk2UVdbaIy4CKwPpeHWqme9bS+mpsL3mwSwCSGE1uGBPi9pZBANI8xhCxXxABxncdBlCIBwCEoWcTBQDWTo/NO37LWF+PeR4wF4AmSVraOUiu8uDthcYVIno2izGhknQPADQU8ogZkQQQj4O2L7wdUUJoR1yuEUokErRvBqbpGqFUDC5g8dhycWKFEHJ8dgyRFOGuyQCwKpxmdNzehJCVvCGheq8xgHGtIOq0EB4VSQBa6MZiE0nAzCpeRElpAQCO1M15AMtrGzwqlkMoxsgDnA6SAMcMmlx/8q2oEltahfotOU29fki+Q/9hAGYuCACb2ScAqXWrbs3baRBMGBy17sDZh4zmLABNkuNeHvAAgATqBNNaJO7HF58HQI4qQig1LPR891Cv7ddwJ1ANvMYekEzRCmc8zK8TTPEw+5TBCsie5jElATMQWIkb+HQGMPaWOZlgbJ2Irh2k9zVleTJCKbds63Q+0TBCHl4/XGh1K5b8tGtC8AFBfjcmCIwBrPgApKjZeTcTl4Lt8FnH2d3+uHcY2Jz1iQGspSyuQ9875HpjC4NOAUBXggCQ1+qdT6h8xwpmrT5+S+AdWsUUABGpOyrHM7vPjv6Ys68BO/rLzWTjaAySpoY1TiSBqCLaTFS9UDvtfQ1a73TL7XwSW0NvUn7w9MdfNTQZfDw8QkTDqZgmRx87ZrAYRH5G2W7nE+E8on8F2pR44SHPjj4+66QLCtcDh6aKQVk2ndr3V18ftj+/vuptufvcNjitQzQRRwgAcGLKerp2cfGB7cvE/MPFxaC29fnVn3Ps1WnNHZz2/p5jvRpdgcwNKWlmapPti/fbacPN+AAmRZXoOsDdurv98CN2e/u5VjKjiAzAwZQC1wFRRaNtYPRkVHcGN932tysxta+uvsHOzoa3J41m72bYPZu17vCiUWte3F7/M2PX/1zffn+ZeRIIKbGyEokXXn4+/++P2Pl5raRJYZV7tch+YCbkBPnj5sWQduDbQ3bWvblruHm0jIeEPFNQagsCqUqUABTc0+urfqvVwrPFr5VWq1pt3/6v2fx7+K16WR19hS/7/Wr7y8ng5GJ4VRXWwgwfLi/bw95W6UkgokSICh1n6+6m222f0TTHvtHzjOfd4e3A0XD97APwTmJILm2dXHSr1UrrAatUL4fnzeNfhM7UPAAQ0R4DOLmutuyivVMsFm27uENvyfrtawZwVSEeNhYWeTm+umIA3Wrftlv04CfmlWp12GuUAlFmQ+E4IsOfM7J+lWezk/9C5K9PXT0kACCgohdPUJKiANCuVirFB6xSqXYJQCmKxjV5UmNiEoAqSQAgF44BYKeIiYxeYEX7SgCo2pUKfRRfMoWiD6Bvi+X4tW3Tn7DhXuN1fhaAEtHNfbd53q0CJVAFDGtoCfLV6xMA4DyAAUiip4esM4AK7U9x8eQD0BDh574kgCB46hiAOHI++CLPpwGwwTvoQH0PaPdtgWSKfE+kvelwgppu6h0CIP5hLzx9LQAoYEjrckhidTGvaTs6BuDt630PD0Be58ugeVeC5ShfZ/NMALBHp36HD5NOsweAN2gLr0BCsMcA8Beb3YCw0AcGsBXwADlq6rrmNn4IwA4AHAcAcA+n0suRByx6eADcvC5kgOdHlZXEaHEB4KqPM2vjSLCDlQqO0s8D6NN4//D9BACfgPDjewBI6qYSCacZABwJHHcmJpu3jBXhPQDUdDTlA4DOGZnXwXIM4EfyADereYNi594O+wBklALtK5ENIXvqi6z9ikqBBgAgm+fc3ysEWn4p0O1XsO8tPxNE0VFFKRAEoEbjYWcCwH22U7ErHgBJABCdu7yhjfljAcDeWWy+B2jekFB5ntweZy6qGtEK6QEV9mTjMgmfusObk61G76Z72b707ewbv7S7Fyc1FIOXjOrycvxs3/RqjjYLoEyJQNtFJli512ya2KgIoyRAuXcYunJi70UfMS1+zKXAgrV4ViUAdDmlK1G/o2BQdlcSCs6UPRVqd/+ZY+d3g1rt++3tl6Dd3g3eDS5uhrNG0G4+u4XAzVCuTCfQYQD26Ght+A/PK5zmyDXYoyqX1wyADp5TPnftIAIIzOqKYvDB468IAEKl5h7dYaF+oUKrymk0B41m86TZbDYGTXrXHOBZO85kjrdouW+DU+9Ns+Gk3XffT09PAj3rvnfM4KWwXC6rEWdASaA4kQlyljUqurxlO0UvE5QgDx+auiWS88IDKvYDVhEA8sEQTxNJgKNsItSprhcyDhnixKDbfiZTStOH16WMFtf2M+m003FYAYfnx/yupGn7jntcq9Vct+O69IK372rvau6+lAvEFSrLKwQAHiBKAS5MJidbQGnhmz4DkKUy4htM1gnQfSt5QNe//lxodCXYcOKyJE90j5mR2UHHJTksx6O+8pHXE59cooB4QfsaxNnjOqWRffPp09LzF8+fv4A9LxXyWlQz9zPcK1foI8FMs0CLdCUeuBJUllUZ1wFDXHL3H7IruhI01bCqiICqEveYQqBKKgabF3Tf0m0/aLgXeJ0Vwdmj826GRgDKqkILVaUs4mnJKhSuwmEtLqsrIVVVlyHxU376/MVvv5P9m56/vXiqyMtKJKrk0HuL3irQgV9ZUdWwHFFMXQsH4yorMt8LILMVWewCw72ArpJzKiMAHFxWL/xyvPV5bn4VtDu6GyQAqPqddzfoxRFSvZC3K7nNzXhOVXPxTe64nM2Wc/9n72xW29iSOK6GIxpJTatpJBpMQ7jIxKaRjeTZaUAghARieqFgJKJdbC6DkGDE3Qw4iwRMNlnMxmR572LeQau78CJv4UeY3TBPMPWvOqe7Jcvu9t3NOKUkFk5/nV/Xqapz6nwc1zHivl11nfrp2+H6bjMSub9eXHaDdi32TqsYlK7nXvMw9VPVfttotvdtgAoCr0Lxxr9+/2ch+f19q2pXEgDiBrG0Ntmkdx9goP7+7OcfdMiHd+Po3Fa8XZt6cl1h/CC+FQyXPOdlV81iru322dnp6ZnHg+3Pzi8XN73tdtvv97fz+7t35+3o7Vm9HWDR2rPMwrlndHDU9h4BcKheqAZZ1A+J/Lz3SX//4U/vBhfYTsDjoXw6K8KbK56fB+dj2KfLvz7z+eXyzWA8xvx4BFINRz0HQG9fUHWbpOXT9bv1dI1qPkTs6ni2QqvRDdzh4no+u2Lpj26pDkSRVycD6sgSPDwe0dH74e4EHkmfNlmNizcDlvGANxbLfkQGbGYHAzIkJkpTTnpJVIQTbDkWNC8islSR/LP/3ey+SCbkBJ3JqgCAGpWfKvndw8PDHclysR7ydRzsbQmjAABXHZKwM+vdTSP3InJkP0+zsTO32fl66NHd7xXmkAymFtOXeJ/I3c+FfmreQdMlA2PbskOYrAitkSqs/QqDRSbHYfvksex8r/GPOkbn82LJhzNDSoxgYqWjaLh4uB+NeiSo5vSSsZtps4FQokZ0lgAQhmHnigHwFsh4GeQ4HN5LTPaV5JW8laMO7jSjuAA119sX7BfrejV86LHpW01llq9CLCQtGrpHjRcAdZ8XrybrpNbwVjBiOA+AItM9XN7c93rz3nw+7402d+sIRgdFIkMZaAC+74cCoNp0bQHQkG0VoSdOVWkY6sBGQ9gnWelRu3tLbynl7Pb9eVjlV2LgBAD8IGY9YJJZ3iouiufOVSpUhicAxCkA7rKP3PH69mZzz7K5flhOqWhNly/h2vVoutxAA/yyPwGArkP2weYHYs2PXd5dk2cm7PrdtFPUlsBeL5f+WLJrGwYBGZ6mqztFZYn4kp5Xx9sP5izjIzP0cGbTSVdFewaAG9Si6fqWLMAD5G65HvJkT9fDooH2SQANmF1NSMgI3k1bem9fmdF0HLvYG5JLiK1W3ccAqpg2QYomEhwWzIzTE+siuTsv61ZiuKDryv8/eYF0Yh7fheqW23gCQCChsJ10N5Xc7nS9XmhZr8kRQLrdLjFU0S/sBvv9GbnB0XKKGLDZ8Fh9YzcO2OrGyQM8XmS0gmkTAQWUFFKOx918oUMjNnm6GrAFiLovkHGrGyFF88Rg6R0AcAhxMFwvlrdwAreQJctiPSUCF39+//Pffv2Pll9/fv8N8uUvMGzRGKDgOSVQZifaDWyz+Z5m4bjHbXKza0BePyk7/zXtBjHrEu81RIFgNJyuXyT07DJL4Ck3mFSBOHZPg+nt9f1oT9gftL789OnTv7/rRvL3759Efhq48B5UouWuELUhpsByY7Qh0QEp73D58HBzc02fAkIVcTkll4h5ry5vEexGZIofbooL1eQpuVi0o1XODhMO15v1zf28r2WGmI/Dvpv1ePz102+fPycT4+jrZ5LfPn2Jou54fXdzvbnekFxv5CfZ0MU0sB3smcprNit++i5dH4DhZwvIPd2ZdJhbItRgq9IlxovHb+gpgTPf4AoBefFmLgCyuRE94Gh7RYauQ3/oL6K+2XZ0vRgSgM+fV6sVlXqFn6vVx4/0/dPXFl7KBp5zV+7v1l2ET46oH+d2x9Pl/ZyD6SKy3c57mwWZAYrUK/YJJs+oaIgr9OXVFBBcYRjxsvm5AKhxC769/qQTWmUWC1HPpN/TAKjUR/TR8vHj0YoAvKEI6Xa0nbF30ELfZr0bjiThxgRAFQDuRn32I51cwTuYze+XwwiT/Sp6//CI7tUnX9zJv8YER822uIINAKUCALoCIAQAZmD5VtgRAN8IwJHIDoAxA8BJoIU4mf+5ml8vptQqrokBkr0GCUBvNpEjLD/Mk87VdrQcBgobeNsnx/ArEV+BYrFOJ/ds3EKuUAiASgBQrGOVLa0EZUsAtAwAKjYQHBkAAwLAD4WD6UyUi75M5tdLOI9qJRne4TQIVW/WAdSQ6T4rdB2KN+jxsTuRI3MGFd+rw7rp555PR0xwhcgu1T0vF4ASEwMApAG+fkH+jgaIDqyA4WgPABOzSHBzSwC8dWuqYkI78jIMYBJarGJ88I6U/czvfFITBhBRbOSa9KgA8HEXK0dCFEGu4KFjJxdAqeRFXa0BeD2JKqU2gMtuKgKV31QBAWBpAFQ8DSByMPpGT332TgMNAIjyFcAA6LocVJEhpJg2vVfO6aIDGiGyf6U8ALDTDACAy2IDoGjhJNWA1dEOggwAskt4KC67VF+yAVR9UX6sCwBDXiUbcAsTIxUs/w3q9yc9YuQCGg3yAkDoW3yn54VuoBEG9AzVaiUXACI6BhCyKmo3oL3A4Jt4gURWVAsyGkAn6cfyUwCnJVWpAYDifbIaLWMtrAJC9UgAoa0AIQAAB8NJREFUVKT86FKpBADQsQoCEA0Yu6UiAGAGEzeIym8AXG1TN5i+/cQGjBtGsS3BxpVPA5AVux1xhZ7YgA7UN8ytwpbxAs1KyQyRcEoBrgALWvYLIAzDiWiAcr1arg3wHDcaCoCOnwXQzwLQRpD+agCtBnxzFgCqn6kCeP8xqhc1qgMNQNvw/PJrNyhNNW5IIw5gAFCQ3OIbAFSJTgt4AdcAIAUwVYBKo6vAMA2EjgSEAeBEogFSJildFoD0faAdF41FA2Amirw+bcKcQPdsxbGKxJGG+VcQIy4A6CleBsAvmyDA4kBo87gKQANWCIXHrgDw5YkAAHfXALC9OzdkEWcaAGVLh1rPfkwcEDlxwBTJk6pI7E0IV51/vrlCFdto5VeBOE5sQNkUJokEW9/SKsAGEG6QAUTGu5vQCUYObnAxbEt7E2tfUFAcNMe6Cug483lJHl+GcoqrZgAhBxt551sIyowfcfNbg5hSLnEA2gK6jhFnATDeAaAhsBu8TAAkdy5LJMhuEH1OAoCsQTcBUH4JAO5zly53AcA2IB9AOQEgGabcKuCkgRAiLa7O1n4ckHqBHTc40cGd0QBTBUoqmewROIJKe9jCANAVpjQAcbnWiwGoPwCAy3MYALuBTGOIAZT1e7EyABwGoJ2YAaAD4dznT2wAVwECUAIANoJ4srzz6QgDoGarAo2hFwDYiQNeF4BMJHD0ejVgJxB6bQBWiQIc/bABP2zA69SA1Q83mHYJ/W8DiP9wFVi9XhuQNgVeqQboGGD1QwNerRdY/T/bgPgxAKtwc9g/1BxmAGYUSQLAsor0B6QAdOYKQ2te1BxOOkQ8u+55h5vDnhm7pdRpEOjMkKQd0PHKXRsAcDn4muYGU0uY6RZPASQdItNA1TESV29jhQ4Rk0SzigPoyijBRgNjkHRqrEiPEHQgyQyp7DRsbx+AJEcNgFlHUhzo3z4MYHUwFE6ziSmAYwJQ1SOWHDdOKkuuAnO/d0YDgI8ANLQGoFu9CACTGTqOswCgAWp/mBwSOK4G4AuAcgbATm7waN8LQLGTnDqrgQCIYq5ksqdlBgBfvXAVUDzXIHacODYAwiIAfNOxLhqAZRQ4VV2pZgGYsTOq2nAMgDBJcj2yAatsc1g6RbMAxAbQWTo9jjGmjuJBemQDMgA6uc9vJd3iPFDOlhS+Tq1wr3gBK6oB1DE+Ux0CkBk8VqlWHZMdTgAQZ587RS+zuUHjBQTARcvYdms/MxTEWMX6+Pj4hCe8mdQm+vvyEyM6OTrtOpIbVI5dqnBuMCyYW0PndF/GB5ScZnZx0kMAUFmzXoBHMKQAWjutwb3ssLbtJiOX5gYxWzKICQDxzQLwCyQ2kuwwRvkRACcLwM9PrXApGIDL4+t2AcAIHivPVnq7WDYNKki6xZPkuMUA1oPWXo9QYgMiR2dsxW0KAJ0ZqvPw4QAKgBqmq4BUz7wSpAosyz9QXQIA6ViHfoR5qbUkM9TgIXrKNiVVtnd8AAA5ygQAysD5dZ0XWCd5gWwgBA34FmnvbuIGvnMCwK42GzxMqEEAVALAKpDbCs0Al9IJ1yDXITW6EAAFcmO7AJCfSADUNYASV4Fkzd1aVbldPUZIB2s8EidNjHCps3JEGnARJW7Q2h0fsCQAMK4NHimHcf7tIdKoZgTW86MbSJkEAIY4Ydg8hhg4yRCZ/PNZF3Vy9L+Nnc9r4kAUx11IKflBImUll70Ug4ZQl53dnnpJQLQIHlIWYd3LsjmIrIe9eLEEy+aUs/QqeO+1Z/+2fd95iYm1Gr+N1NbJM/O1yUw6nzcjM8j3JijODCinoxmmXjKAkR/gTuVm8LH8HzFpwHPfy9Cnq8IAvghOQxezOn+UU7qr1NO8tMsGUGtx6gtVHLzywBYIORXrojJh8OUiG7ar2v9DbsDQKKcwKZiXQRogkXJMXc38vQYDeq+cFPFJXojBvkk+gDtCj38YEiuuAc/NBh+UhHaYTNkxQhiSUbGyiqbWFK+hsAFX7G9VBUiDbHTYNoAaIQvAK/oBFfvzGZwZIKdj0qghVNHaacpQGqDUDd2QFCd6CZDXl6ToaDTCQ35jUjQzgMWYnOwJY3icDRiU+bS8FWjZrqEqukx+sDyv7oETZL4vP0lPYG7oxoDya9iebSK/0wbPXoB21fvvOkKWZSk6CXXVNF2hDhqyx3XcX6kFq681xCyJtnf76m2j1UwakDuw09N6+YMBCQYlB2AkBwUoCWic7zSA+Zk6ncFUklHKSiE1CaDkV6xyj7+hS/rgGMr8fUYIRjaBWoZCQabGLpNAVWqGXicDXNd1ONkP6X71tmW3RDhOFuB9GfiV0G+0WI1D0Zws12uwwk97a2ksJ01TdI+isnJhG4pu0pvQvYYIp9vDksd114vGQnhI5jNNBTHex3JPRfg77grbanMdMzmui8nVfd93IJ+f+L4tGuWEgV3eAKD1m/6v282erq83m5eXyWfzRgCWLiwrYOk2GYDYdPiOP6S3oZJR9LboEaFgtApbQiAEHZ1dd3zRnclP6FxFiyQUwnacoetwbfMqd2o/5wcKaEuDNEyxzdLsCW30++8PDzLjL0/7+4Yf7+/TYB4E6b/4QNNxmoUsK53GcUKvLuJqoVySBgGF6HQ4UDBP02kSn68kpsNAhCB4W9H/BOYX+hyX020AAAAASUVORK5CYII=",
      initial_output: "data:image/png;base64,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",
      sheet_url: "resources/facades-sheet.jpg",
    })

    create_editor({
      name: "edges2shoes",
      weights_url: "resources/edges2shoes_AtoB.pict",
      mode: "lijn",
      clear: "#FFFFFF",
      colors: {
        lijn: "#000000",
        gum: "#ffffff",
      },
      draw: "#000000",
      initial_input: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAMAAABrrFhUAAABa1BMVEX////5+fn39/f4+Pj+/v77+/v6+voAAAD9/f38/Pz29vbz8/P09PT19fXy8vLx8fHs7Ozw8PDu7u4DAwPt7e3r6+vv7+/p6eno6Ojq6ur+///g4ODm5ubn5+cBAQHl5eXk5OTV1dUJCQkFBQXj4+Pb29vFxcULCwsCAgLe3t7h4eHi4uIICAjf39/d3d0EBAQGBgYODg7T09MHBwf+//3U1NQlJSXc3NzW1ta7u7v///3Y2NgKCgoPDw8SEhIuLi5DQ0PQ0NAaGhoiIiIMDAzDw8PX19cWFhYdHR3S0tIQEBDAwMDGxsYXFxfKysrJyckUFBQREREjIyPCwsLIyMgVFRUNDQ3Hx8cZGRnPz88nJycbGxvLy8skJCTR0dEYGBjOzs69vb3a2to2Nja/v7++vr4pKSkTExMcHBy5ubkqKiq1tbUhISE0NDQ7Ozs6Ojo/Pz8yMjK8vLwsLCzExMTNzc3Z2dm6urrBwcEvlxCxAAAYP0lEQVR42uxdWXMbxxHumZ2Znt4LWIAEyOIpUhIZk5IiqWLZJV+JXLbjxA9OlVM5HhxX4koekrzl/6d7FhRviMAC4gKYZomkAApE9/Tx9TUCiBQpUqRIkSJFihQpUqRIkSJFihQpUqRIkSJFihQpUqRIkSJFihQpUqRIkSJFihQpUqRIkSJFWlDyAARWvqwqaUj4s1lZ/gmImbcrbQUKnF1dEzBsAYmHVRaAYxUwK2wAhoBlQKsrAMeO0OMqqYAFTeSct6YEy+wX1MMS2Q7kuRUQRAkbtcIb/CPiIfb5z9cICGUO2QqcfwY70AXvO4g2M/xX69PyEYkEYJ+fWX7qQYc/8FNIPaR5Wm3AGovFswT24dUK8F8BERwhDKoQ/wJtb6d9Ng14Ab9dAQlsAuBGbQwEOqOnQe81Aj1hCaxC9ods7VQG9J/XNrHG6QDyM1/BkxWQACo2+oJlkJzj3+8JsDQFpEvMd8J5b8b6z5DHWHsxG3bQ+aQLFjk8Vst88jswhN8z/56BH5wffiXJIEvFITzkj+UFQgUM4PF/MXiBS8nfNqx912EpINmc4+Py0hB+9Z+fWOM9XMr+vAd1wAgwPVSOQ+EyJ0Uf/OEjtgMiry49vA0n3ww4CcCSnWO5xOHPHe1xlPO1/zs/6Bxev9li80gEC8Mya8BuzhFfEJAxl6rA3cB5Kl5wqXMhlLPtwMj/+wvlAGTHAKnlr8WSQb76kwYxbrz+dOgIkLVIXnwi4SXBLAH/VpSds12Cp9f5l1DgRQgMgDRJWYizgXKpwmDt7ayDpGL+164+bUbqwU8ZIwef/7IDy9YgUZ5T3z14hgwBbxRRwpZfiR9MwLAJWP4Xy8O9kWzfc5hj9X94PcB7o8T5JX3H/It+9L7schjQy+QEasTLSY65EeBIcsQegCVVwTqrwfMhhwG1TEGA3Z83CC84+7/RQBgWSz2ckeGQGde7CSxXk1CSXoNmECr/dIMHsJbQOAKVysFnkinTMjjBnkQ44RoqxFudWlqHAPf2gQ7/bbAMWOhEqn4WqCjxyN8ObtPgHrrnDwhY6iwBECjgK875OKxj3yoYc6I92Hrzuq4KhizIBX1YfB9gtmBLbP6ZSzyzb27HSYNvTjgXfkslDP+6eS6QBaYdKPI691GFG/Nz2YEK1bEzzREVSJaA/1SCvmD/MPpya1xX0Pl67YIGGAvZ99kSSECOlFP7XIyZxrHj0fGhV+c+8ITFtrf4CkCeECGV2afxuL77SYcFoM9dgISB9cVlfJ1ZkIqnQZRzv720pcDyzzlRgOQi8tV8/GjMQup8R8K92G8XGPowxNO385GFIClmYqpr9ZOLwGhRSDOQF74E8XaPMPj1ZJwGVOzwtfBK6hLsUQELLmLWC4VKGNdtQPXZCQzYmetxpS0d6j4c8pT3F5PflJGRxQVMh6kXOppdfI6fCuyziZTBxvq/igHCrpRD+MNdeLS0C6kC/Na9E8fPfnCPD1dpafyMUQGjQpWEk8X0Uju4Yh3AxasH5GwDiMQhX2ZdEgHzBt5R1xgAWnETji47vWwhNYAk5zXaCKzJQjJzpft51WcwPkAyKYgGXPSVQ04icAGSobPD7dU43og1090L+jIY06cbs8QyYEjRipajgQRK2XFgXirEPn/XmaCpyVa/fnSjiRitfBAAgGlzcTgnUeMcshSY+zzNmP/9u4cvsoIB8htwAuWhPWR9+80gWZeT/PIQHrrKwYbSEzR1C1j/YfNGHbdkidA7GBXUWqv/HOag5w5wP+S6BWurmWS4iaQUbq9LzIkfcYYDiqV26wBbvEpCwC6rAYdvNocJsvgAdm5RGNF+qaTkbZ4SYGPXCiVcVXLuVRLa2xPUMteP9us5uatJVWgRAzqvdKujgDHJsVOoOZQ9S+EYd91NCn07ibzoZoTgggCgZYMyZ31+gtQw4DNJfpjLcWWSz0wCXQtpCBMbOYNgO0Y+niGRaRP/dZ9/yOfiRQan0sUFzfyfPptkqOMDBnp89ihJ4BixSRjIWuUDRn1+zlS6nMacYgZdqeQxAC4nmenpwUcyIUTsPcb2gKWe1G1bVix9/k355iWOErhvMbzF7gRVTIH6WeBPg7od6rETLNrVIBv1+SVfxyEcWTjhJC5lHUiKwQTTzQq2mS/GADYZ2/7BgoGwapcTDLldL4y56xzxT7sHWA98cTibqIwb0l0dIt7tGgAubVUYOOvzs8Mz1RqDlGxLuJZ8zu5MoKtGckYpm/gwHXv778PWjYvWfX4f3ntVYz4lauxgQshOkgSRgIAx9QKPzrZlToJkfFHWGsoxff674giiwbebd/DuLdob6EqdlmDHHWOD0Z0zHCF1MPYZ79SZ1uwNGMemvhEcl5Q7h41xREccwB0Ya8veQMJcD6DrDzk9W2u4zCM4gkSQT969GdmevQHxxRuhTk3wgmXRFEcg9NwdTKk1ewNJsFo+tcSx/u83xhF10pze4fe2ZW+AnQBqqffwe/rF9OD87byg83dTo7bsDUj1XuofxqqGFbozHCHt03eXju5tb8CcKZ4T3J7mCSIeg3YNVB9GOYSB4uXdNSjva7iXxQGpUhhZ7S0ld5fjtwqPGsd/2Qbq/bgFrReAD8fP5voKigSGh5QJBujYBgKtP2vYePO/CaLIvWkAKz9ppVJRg1f/YtXf7M2ijmBg4+//gF+3XwMkXEuaws7vuVxp0eXML3GGGr1gyKPf/Aw/TRDY708DRk5AMRJBwAPoJraZTYX4X/z4N/gZHi2ADzBM1hAeetnxHs355A34r+P/yyes/xPwf38awOyTQaz32WcRiuv4r9n/dSapHNyHABiiUhHuM5ohAs3EDUwx8XEPAtiBp6KvuHsIs2vL5uG2jCls6H0LQDH327Auyp8Ws/y9qYCpcgE0oCeb/fBMJay0a7O7xSOFzme9aV7ufQuggsLQv8X4N1kXZliMe/SXP8ODKZzpe9cAZh3XOfOXVO3V7HyAlAAfwVb7NcCGiYWskKsc9mb5exF+x+7VtV8DUFw10azHchD2WaC2nRoQJvWND4uqV+/1meLFaFTrtfWcTy5z4zj9y+FZajonkt2UtRqo7PHxX73XZ/IMIlR5lKRNYV5yCOvw4MPu1GEZk/lOCZbsmrrgXAHY/03YXBw72XqXrC81RViPKkUWOTu+x58/mPrl9Kkskc+zPXwCr0drm8UjucDvyr0+k1JB2QVQ1Sn4/D/+4vH0HoWwgmq+c4JDWVjAsKHFIODavT7T1D0STTp1rrbhx1983GD5Kek7PVf+E4KykGm8AvKn/Eav3usz8YmRM+RAUWKdtynBg88fsxVMnUerg8rPty2g4KCPoCop9csFX1fv9Zki82cogXiM4UW6Hz5o1ErUxy6VS0fnV/iQ6TbwWvZ6c4Br9/pMXkjhD2uIFJF8g+xhm2wAU9O+iKzhuLomm0ChO4aMbGYb5zQlShMHPrJzWc9rFv/rqRkPBTI+oWZHzCxndtv0QMq6KfFpizzwAPus/GSsFL9mr2IN43/tjIyxu3mzDWKn4Wyro8PKtCGjx2vrCWLSrWS4HQzYeUygNI3/cnLK+lBEMs1wQICS+bYvQzkC8Tn+87vT0PvSPs2Ci03mMIHRMP7XQ0fG7VLRbD6iygfHvXoOQR9gGG2D3qaM6WYh2VfsB+YRZpvGf/F/1npCVd8l0ASa4g94KpxjGO3r1Aof1tpZMGHVieYQZhrGf1Z+8VUGIVWN4oAMI27DUDwpK7weikQ6hchAjW7xN7W2zZiaxn+Q+4TAo8DAzUbvDxngZuG/LfCCcZJc2f9Td2XNbRxHuGd3jp09AQgACVEED0kWSV3UZSu2pCorUmL5kBTbFeeyK5WkUpXkIWcl+fnp7tkloYgUdncWh6ZKEPmA5U5PT9/9NeE5Wqj4oKRC12EFT/1PMCqowIzluuxWd5CwuUaz/r0NRKpK628RFpXTuQSWIDpo+SS/WiqP5/QouvurE/8+i/IDMgMgXswEl5P6vwI4lea7Yry4uz7PGcBNeP73H+DEv+9BYQbs/Cym/LrM/w/JnegC/uUKjReYKh8KPP/rH7iylf37LbgLyWNqQky5u20hfhXhBR7Bzdv49l0EapIDD9GUwL/+9gqGp7i9v4Nv4co9E+PZiEXYfmX+fxPMH4suUmqHcLTvlZfZ+ue3uOlK/sE2/BceIF1NlAuI5SKEQIUX+IoGBfhzwIvvj8DDAiiefoTnP4Pbm8CnSFXCNggFdN+Ec4oX+B1KgbH/AzfZgGnPAqYA8SZu74Cfp3Q0RRm1ABZw+X/8IwVj53suyxqglcZ6tx9OZg/6go4rNAtDrzDwyZcLMt06QHwoKDhpkW8NtHuveX64DCyVPhiykwJGLZFelpHgByg8cvF5B+qvgA+ogkbg/tNW+5/nh1sa50bX9Zjm+xC7zgE5mcsBknFSlNSvbzYpfztvfQd/QhFiDV7Zdow5zw+PuM1TxcE+82sNmJs5FCDbggrITAq/bZP+/X8O+As8BFdLMoKseTBsrh9uqxemqFiAhvu7gY7qiH8iKF3Z36Cp4b0eorbm+x+NqEencz+8YtmCjOPt4/lQV/OkdXml8JWvwkv/ipKMMmqGZi6S3tpegB9eCi28+9SzagyKA+XToB8FaFdGhACLHNCB/tccuSEOiHH/zQk6zw+v1FbGuWs1H+5urr52ahW16hCNLW9Pk+QxcgB1ZqBjEdd5gchZ3nqIbB00V8RCGyltKDVpENVYAARs/UaehhUX5ToM2SFMnu40CYMWvH1VkNA0+7b5ncMNTAm4z47x5mw4LqxxkD3naUYxEl1LnyPfIOfRMuYWYfAQkuRPmgUitBY0nA+/OGlBfLxrEzDHyDt7tH9KbdZALhL0B5FbY8PXv7UBNEaJLUFnoMYFsUFKJsCtJgWFggd12QzPsVYb1tssQGhWvYAa1bfgozxIbR02CoZkRxEM3CZ4oXxkcFQ1oaV6MwFhv/5lEw4gCiSCS2kmWQsfpGDjm2Mkj+7SfLuQ76Ko880YqRb18BBH7W3pJCRlLzIDQ8JTo7Z8aBRMVhz+1KiHjiBpcxXdrBvCwJGfGXKYwdbRCWhBThxeMDkfPkIAxJAA+CTxkYjBZYObPC+0fP49Dp/r5jIoQ3UbsgN+Bcwdra3Vav4t4NiHQ/oa+IwGxS0TAING20dZrlIT0Ox5igLoxoZt5VAp7jSVNPVRjxpTb+gvJdbBBpR99avfMKQABAPQA/cnDKGObV7lz0lxbN/prreW66WMjrTkWKpECwcyHcdpoUqIrJSH4fjWFZz0JeIHepKW5FfWCEa3zJ8T+OwvOu2uJk405hEF9gYCffLsxCgJYHdEg+BSYzLvuoKyJYlT9pQALQSrsUa8S/lzKy7IhC3HrravKFqgd4yzkSUbRrEdF3pC4omuyA13hF6x5aovsY9CdIhCVIefb3x1q4k7XebPZWRG+LUuQSaEFezU9H7GAmFSAUT+2jyh9HKYBOFk2EFdAfclosDr4fNvG5M/OaQW1SZ+COXPSRNdgkF3MkCzLRUeSeqdQa/q+Onr6ROihNkgDkC1zYXUvnUFVV8itRLT3GGgbTxv4P+e5M/JG+oSddKCCNyJHyFdJ1G8OarsSw3XB67SRuf+dQWlEBjhteIpJFvwwfmDhi+eRQLOn5M1PYAu9+844KYMYVjmJYIoC4qhyunO55pVFvjWFVR9ieXc4T6S8hC+PDeUdRYBXP4cLCmqDgscTo2pEBI7EDZM3TlTMekwhxPZ51lXUPYlEhbjBPWOQvrWA02rEh0UzKxps3SxpGsbZTNZQ30DoNL3BBqn2WQW7GokjEDdIkFT5eEDJOCzfImtJGiimpBCJkK0ueoQcqaOsvOpwHOfcsFWO9lRPlbeG/mAmTRcNAYTj0xYxnoVYf0Dc/o+R59zxI8w5jI7UzoKrGhnv3Me3t7rw6slUiBE3hvDdAqhaOj8On2Pxt5jc8fQr4O8N+pZbduFIss8vHrWgy/gm+XdAK61KjgNoiHVTV6X9P0Yrj/p4x0odk6CNigWbIsysgqHJ8fz/8fy5vCg0u1zoCIKgmayvxQC5hrFqwl4GKV9rDOl3567WdN7LfPwu3j+y5xPnxPrCacpw9rC9wSHgKOoCU0cLXWdbHJ4s3ZAmYe3SIFwiShr5HknkUTru5nRUeEQRDxOZEQGrDgxuloQgJL6kby9zKNv61Phjc/ReBDo5yvfgzolQKj8yueWpzbLFMNmZDoYF3T/9EfC8H1P5hDuAvX8XS6QFTY7I0AIW5/tvgebD21BOvDSMR5/4g+HNsMBE4aiXP+BxBImKjbXWOR/4s2y92eUERVirf8AppxiKaT7Uovvu90hB9z68R6k78EgQoZMSQWrukPv0txTAsToAqTvwVDyCMLjmCdwUEuid8TqIrhMAHric/D412LvOcXq/AovzrQDrLQwD49/5bJvANdJV8+bM9iYAC4FoWAeHv/q1ydc5+tbfHUGB1hQkZ6Lx7/y9YCMHpo64Vl+9xYBIiKomIvHv+o1hk9hB1017wLMMzhABUqbeXj8K18PwdwhJhB+JbhnWVY5Y63PweNf9crYUCMces8i7LOMKyuFmYfHv3oT8F4CGZU6+KKxvLE+po+BA9VZ16XQAVY0N0fb7qXUx6UnHK0vAQp4Dlfpjup3j9hubQoL6qTIzfqe/4/gJb5fxDVbnbPAffaDXQ3Zmq7n8B8Y7Gvc/yJwjy6Sgk0szyVaz7WB5394Q1CFM2TdU+Aiy8ABtyWs6boKgxug0VzT2g+G51wCRGgHJGssA/J9oV2jpuh+LIxzhwtr1nf2ojIaImoe04uAv2NfAO1ro32Bjhbg/ReQaY8+vwbxgIRnnKAnYNeHAhb24C4o2brPrz4BEgL6N75gZ52vPfiCYLja9/nVJoCgupCpslasU0CwwP0fkgHYts+vPgFSyJUyZY3O+lDgBe3/IGzf51fXF+Aq6tB062R14f66sYmt+/zqO0OK2sKNtH6gp10vjQ7glBKhbfv8ahNAER4GxN6wt52rQWlCBUntPj8fd5gWpdrXISoouFNhjLs2ZPguMURFtTGXYPUFEiG651dhh5L/S41Rq2kPKXBl5fu3+A7fwMOvAjyLAIJFk2CmRkgeJEj5lc+fkyk8+L35cCDjdBnD0GYIEMP+dbi5Djfgwx+g5zrRxwu/kqcEQGofff9iDSYQ5seHuO0NkLnNFm+anxIgQGVrvEtu/Ff/XoZ6ue9AWIYLr1eYKZNTrAlW7g0ZeodAZtQ3IZf5Oq5OltChInLClvEHq48MAjLBUp69CZGJuGlk+eKXBDBZxDDxx2yps3/Xn6CLEod0Aw4uGB6dLSO5CoOMWGCIFAip9Gavu+daGznwRRlFdkatV/0JMO47sIrLOfTNIOK5FCsggCXEfu7bjwt42d3lk1aB0kEcB+jeKPvG3eL+BKbC0BwYMkS5ZREF8gqi9KR0RxHPrUVbtLs7YEFrqsGxkftp5soJV6GsUvHoGv3+b/gSciu4vWpZgYkZQ2ibu+QIuGyEvJB3Kl3Ou3IEljSGGybt45nTtDyG2kDRYJdPgBhtgJhAWzbgsYGisxcQOtA6CPEf/a/DGSXg+hNw+yQDUfVvwQPeuWDwjaVzQEwj4IFm4tjQdJgnMW+s2Uvn+hPw2us0UiEHP6GEvV3azT+rcdK9mKHZCNqFpvIZBCUUajoS79JTrn+v2vEUZmkcQZxITnIqxlpaeULq4hlCy7EmmMv4dnGIjLmFLJkzJgbzKhxMkTzJOavq34tVpoIgdBkt59L0GZOZP4abVuHu5TrW55fCqQgKssv6OUrEh3Ad0igs3xapgSbbhXNW1b9XsjGHGWPohxPcf9mLfBj1rt2heesjWMdVjbHVkA6l+ekzc20PGIgGP3vxFc1map4F56yqf4+imaFWIp+opGzsID7aKaD4s3m6PRkRhbJCryUJhCUDZRAgHXYF5F/fQtuwF6U87IsONn5HX1rVv6eEyogETioUYisZaKLiz83r/7V3bisIwzAYbq1dDxZUUIewO+98BfX9X8v+ydQ6dNS7WvrdjsHIki2HJrlQ0KlckLC24uBH0shGDigZWLG/mlsUicdqKp4oK8LMXDnu36N2aIczeAu7diwImIentNuup0J3X+DhXFSgORm5GUeao2wwPP5hZBt6Zrzfq3/vKVCsYeD7oUAHcSYN6OyxyE9AWiZf6RiphuicUmMzzbgxY5xiv5H270VO9NKxGUjAx++Wkq5vfaJt/4X5DVEdKhOp3l3fRi24XKbhby10mXxKgFSBzcRNU2CNRpHcAUQjF1MvlDjuAAAAAElFTkSuQmCC",
      initial_output: "data:image/png;base64,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",
      sheet_url: "resources/edges2shoes-sheet.jpg",
    })

    create_editor({
      name: "edges2handbags",
      weights_url: "resources/edges2handbags_AtoB.pict",
      mode: "lijn",
      clear: "#FFFFFF",
      colors: {
        lijn: "#000000",
        gum: "#ffffff",
      },
      draw: "#000000",
      initial_input: "data:image/png;base64,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",
      initial_output: "data:image/png;base64,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",
      sheet_url: "resources/edges2handbags-sheet.jpg",
    })

    window.requestAnimationFrame(frame)
}

window.onload = main

function render() {
    for (var i = 0; i < editors.length; i++) {
        editors[i].render()
    }
}


// model

var weights_cache = {}

function fetch_weights(path, progress_cb) {
    return new Promise(function (resolve, reject) {
        if (path in weights_cache) {
            resolve(weights_cache[path])
            return
        }

        var xhr = new XMLHttpRequest()
        xhr.open("GET", path, true)
        xhr.responseType = "arraybuffer"

        xhr.onprogress = function (e) {
            progress_cb(e.loaded, e.total)
        }

        xhr.onload = function (e) {
            if (xhr.status != 200) {
                reject("missing model")
                return
            }
            var buf = xhr.response
            if (!buf) {
                reject("invalid arraybuffer")
                return
            }

            var parts = []
            var offset = 0
            while (offset < buf.byteLength) {
                var b = new Uint8Array(buf.slice(offset, offset + 4))
                offset += 4
                var len = (b[0] << 24) + (b[1] << 16) + (b[2] << 8) + b[3]
                parts.push(buf.slice(offset, offset + len))
                offset += len
            }

            var shapes = JSON.parse((new TextDecoder("utf8")).decode(parts[0]))
            var index = new Float32Array(parts[1])
            var encoded = new Uint8Array(parts[2])

            // decode using index
            var arr = new Float32Array(encoded.length)
            for (var i = 0; i < arr.length; i++) {
                arr[i] = index[encoded[i]]
            }

            var weights = {}
            var offset = 0
            for (var i = 0; i < shapes.length; i++) {
                var shape = shapes[i].shape
                var size = shape.reduce((total, num) => total * num)
                var values = arr.slice(offset, offset + size)
                var dlarr = dl.Array1D.new(values, "float32")
                weights[shapes[i].name] = dlarr.reshape(shape)
                offset += size
            }
            weights_cache[path] = weights
            resolve(weights)
        }
        xhr.send(null)
    })
}

function model(input, weights) {
    const math = dl.ENV.math

    function preprocess(input) {
        return math.subtract(math.multiply(input, dl.Scalar.new(2)), dl.Scalar.new(1))
    }

    function deprocess(input) {
        return math.divide(math.add(input, dl.Scalar.new(1)), dl.Scalar.new(2))
    }

    function batchnorm(input, scale, offset) {
        var moments = math.moments(input, [0, 1])
        const varianceEpsilon = 1e-5
        return math.batchNormalization3D(input, moments.mean, moments.variance, varianceEpsilon, scale, offset)
    }

    function conv2d(input, filter, bias) {
        return math.conv2d(input, filter, bias, [2, 2], "same")
    }

    function deconv2d(input, filter, bias) {
        var convolved = math.conv2dTranspose(input, filter, [input.shape[0] * 2, input.shape[1] * 2, filter.shape[2]], [2, 2], "same")
        var biased = math.add(convolved, bias)
        return biased
    }

    var preprocessed_input = preprocess(input)

    var layers = []

    var filter = weights["generator/encoder_1/conv2d/kernel"]
    var bias = weights["generator/encoder_1/conv2d/bias"]
    var convolved = conv2d(preprocessed_input, filter, bias)
    layers.push(convolved)

    for (var i = 2; i <= 8; i++) {
        var scope = "generator/encoder_" + i.toString()
        var filter = weights[scope + "/conv2d/kernel"]
        var bias = weights[scope + "/conv2d/bias"]
        var layer_input = layers[layers.length - 1]
        var rectified = math.leakyRelu(layer_input, 0.2)
        var convolved = conv2d(rectified, filter, bias)
        var scale = weights[scope + "/batch_normalization/gamma"]
        var offset = weights[scope + "/batch_normalization/beta"]
        var normalized = batchnorm(convolved, scale, offset)
        layers.push(normalized)
    }

    for (var i = 8; i >= 2; i--) {
        if (i == 8) {
            var layer_input = layers[layers.length - 1]
        } else {
            var skip_layer = i - 1
            var layer_input = math.concat3D(layers[layers.length - 1], layers[skip_layer], 2)
        }
        var rectified = math.relu(layer_input)
        var scope = "generator/decoder_" + i.toString()
        var filter = weights[scope + "/conv2d_transpose/kernel"]
        var bias = weights[scope + "/conv2d_transpose/bias"]
        var convolved = deconv2d(rectified, filter, bias)
        var scale = weights[scope + "/batch_normalization/gamma"]
        var offset = weights[scope + "/batch_normalization/beta"]
        var normalized = batchnorm(convolved, scale, offset)
        // missing dropout
        layers.push(normalized)
    }

    var layer_input = math.concat3D(layers[layers.length - 1], layers[0], 2)
    var rectified = math.relu(layer_input)
    var filter = weights["generator/decoder_1/conv2d_transpose/kernel"]
    var bias = weights["generator/decoder_1/conv2d_transpose/bias"]
    var convolved = deconv2d(rectified, filter, bias)
    var rectified = math.tanh(convolved)
    layers.push(rectified)

    var output = layers[layers.length - 1]
    var deprocessed_output = deprocess(output)

    return deprocessed_output
}


// editor

function Editor(config) {
    this.config = config
    this.view = new View(this.config.name, 800, 400)

    this.buffers = []

    this.buffer = createContext(SIZE, SIZE, SCALE)
    this.buffer.fillStyle = this.config.clear
    this.buffer.fillRect(0, 0, SIZE, SIZE)

    var image = new Image()
    image.src = this.config.initial_input
    image.onload = () => {
        this.buffer.drawImage(image, 0, 0)
    }

    this.output = createContext(SIZE, SIZE, 1)
    var output = new Image()
    output.src = this.config.initial_output
    output.onload = () => {
        this.output.drawImage(output, 0, 0)
    }

    this.progress = null
    this.last_failure = null

    this.sheet_loaded = false
    this.sheet = new Image()
    this.sheet.src = this.config.sheet_url
    this.sheet.onload = () => {
        this.sheet_loaded = true
        update()
    }
    this.sheet_index = 0
}

Editor.prototype = {
    push_buffer: function () {
        this.buffers.push(this.buffer)
        var buffer = createContext(SIZE, SIZE, SCALE)
        buffer.save()
        buffer.scale(1 / SCALE, 1 / SCALE)
        buffer.drawImage(this.buffer.canvas, 0, 0)
        buffer.restore()
        this.buffer = buffer
    },
    pop_buffer: function () {
        if (this.buffers.length == 0) {
            return
        }
        this.buffer = this.buffers.pop()
    },
    render: function () {
        var v = this.view

        v.ctx.clearRect(0, 0, v.f.width, v.f.height)
        v.ctx.save()
        v.ctx.scale(1 / SCALE, 1 / SCALE)
        v.ctx.drawImage(editor_background, 0, 0)
        v.ctx.restore()

        v.frame("tools", 8, 41, 100, 250, () => {
            var i = 0
            for (var name in this.config.colors) {
                var color = this.config.colors[name]
                v.frame("color_selector", 0, i * 21, v.f.width, 20, () => {
                    if (v.contains(mouse_pos)) {
                        cursor_style = "pointer"
                    }

                    if (mouse_released && v.contains(mouse_pos)) {
                        this.config.draw = color
                        update()
                    }

                    if (this.config.draw == color) {
                        v.ctx.save()
                        var radius = 5
                        v.ctx.beginPath()
                        v.ctx.moveTo(radius, 0)
                        var sides = [v.f.width, v.f.height, v.f.width, v.f.height]
                        for (var i = 0; i < sides.length; i++) {
                            var side = sides[i]
                            v.ctx.lineTo(side - radius, 0)
                            v.ctx.arcTo(side, 0, side, radius, radius)
                            v.ctx.translate(side, 0)
                            v.ctx.rotate(90 / 180 * Math.PI)
                        }
                        v.ctx.fillStyle = rgba([0.5, 0.5, 0.5, 1.0])
                        v.ctx.stroke()
                        v.ctx.restore()
                        v.ctx.font = "bold 8pt Arial"
                    } else {
                        v.ctx.font = "8pt Arial"
                    }

                    v.ctx.fillText(name, v.f.width - v.ctx.measureText(name).width - 26, 10)

                    v.frame("color", v.f.width - 25, 0, 20, 20, () => {
                        v.ctx.beginPath()
                        v.ctx.fillStyle = "#666666"
                        v.ctx.arc(10, 10, 9, 0, 2 * Math.PI, false)
                        v.ctx.fill()
                        v.ctx.beginPath()
                        v.ctx.fillStyle = color
                        v.ctx.arc(10, 10, 8, 0, 2 * Math.PI, false)
                        v.ctx.fill()
                    })
                })
                i++
            }
        })

        v.frame("output", 530, 40, 256, 256, () => {
            v.ctx.drawImage(this.output.canvas, 0, 0)
        })

        v.frame("input", 140, 40, 256, 256 + 40, () => {
            v.frame("image", 0, 0, 256, 256, () => {
                v.ctx.drawImage(this.buffer.canvas, 0, 0, v.f.width, v.f.height)

                if (v.contains(mouse_pos)) {
                    cursor_style = "crosshair"
                    if (this.config.mode == "lijn" && this.config.draw == "#ffffff") {
                        // gum tool
                        cursor_style = "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAzUExURQAAAAAAAAAAAAAAAAAAAAAAAAAAAEdwTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE547f0AAAARdFJOUwIsBZdyeycAZGVdXAtZRUZY4L114wAAAGhJREFUGNNlj0kOwCAMA83qsBX+/9oCqoAKXyJbSuIBSajorHVRYRhSS/B9wAfJI8im8FM1moA8XCoCqMBDQSH5M/ARDmfQreVP9g6ulevo9RbStq+9GLVZVZvJAy5vOD1pO34a+Gniv3rZBpFYM/mvAAAAAElFTkSuQmCC) 8 8, auto"
                    }
                }

                if (this.config.mode == "lijn") {
                    // this is to make undo work with lines, rather than removing only single frame lijn segments
                    var drag_from_outside = mouse_down && v.contains(mouse_pos) && !v.contains(last_mouse_pos)
                    var start_inside = mouse_pressed && v.contains(mouse_pos)
                    if (drag_from_outside || start_inside) {
                        this.push_buffer()
                    }

                    if (mouse_down && v.contains(mouse_pos)) {
                        var last = v.relative(last_mouse_pos)
                        var cur = v.relative(mouse_pos)
                        this.buffer.beginPath()
                        this.buffer.lineCap = "round"
                        this.buffer.strokeStyle = this.config.draw
                        if (this.config.draw == "#ffffff") {
                            // gum mode
                            this.buffer.lineWidth = 15
                        } else {
                            this.buffer.lineWidth = 1
                        }
                        this.buffer.moveTo(last.x, last.y)
                        this.buffer.lineTo(cur.x, cur.y)
                        this.buffer.stroke()
                        this.buffer.closePath()
                    }
                } else {
                    if (v.contains(drag_start)) {
                        var start = v.relative(drag_start)
                        var end = v.relative(mouse_pos)
                        var width = end.x - start.x
                        var height = end.y - start.y
                        if (mouse_down) {
                            v.ctx.save()
                            v.ctx.rect(0, 0, v.f.width, v.f.height)
                            v.ctx.clip()
                            v.ctx.fillStyle = this.config.draw
                            v.ctx.fillRect(start.x, start.y, width, height)
                            v.ctx.restore()
                        } else if (mouse_released) {
                            this.push_buffer()
                            this.buffer.fillStyle = this.config.draw
                            this.buffer.fillRect(start.x, start.y, width, height)
                            v.ctx.drawImage(this.buffer.canvas, 0, 0, v.f.width, v.f.height)
                        }
                    }
                }
            })
        })

        v.frame("process_button", 461 - 32, 148, 32 * 2, 40, () => {
            if (this.progress != null) {
                v.ctx.font = "12px Arial"
                v.ctx.fillStyle = "#000"
                var s = "aan het downloaden"
                v.ctx.fillText(s, (v.f.width - v.ctx.measureText(s).width) / 2, 5)
                s = "van het model"
                v.ctx.fillText(s, (v.f.width - v.ctx.measureText(s).width) / 2, 15)

                v.frame("progress_bar", 0, 25, v.f.width, 15, () => {
                    v.ctx.fillStyle = "#f92672"
                    v.ctx.fillRect(0, 0, v.f.width * this.progress, v.f.height)
                })
            } else if (request_in_progress) {
                do_button(v, "bezig")
            } else {
                if (do_button(v, "start")) {
                    if (request_in_progress) {
                        console.log("request already in progress")
                        return
                    }
                    request_in_progress = true
                    this.last_failure = null

                    this.progress = 0
                    progress_cb = (retrieved, total) => {
                        this.progress = retrieved / total
                        update()
                    }

                    fetch_weights(this.config.weights_url, progress_cb).then((weights) => {
                        this.progress = null
                        update()
                        // delay a short period of time so that UI updates before the model uses all the CPU
                        delay(() => {
                            var convert = createContext(SIZE, SIZE, 1)
                            convert.drawImage(this.buffer.canvas, 0, 0, convert.canvas.width, convert.canvas.height)
                            var input_uint8_data = convert.getImageData(0, 0, SIZE, SIZE).data
                            var input_float32_data = Float32Array.from(input_uint8_data, (x) => x / 255)

                            const math = dl.ENV.math
                            math.startScope()
                            var input_rgba = dl.Array3D.new([SIZE, SIZE, 4], input_float32_data, "float32")
                            var input_rgb = math.slice3D(input_rgba, [0, 0, 0], [SIZE, SIZE, 3])

                            var output_rgb = model(input_rgb, weights)

                            var alpha = dl.Array3D.ones([SIZE, SIZE, 1])
                            var output_rgba = math.concat3D(output_rgb, alpha, 2)

                            output_rgba.getValuesAsync().then((output_float32_data) => {
                                var output_uint8_data = Uint8ClampedArray.from(output_float32_data, (x) => x * 255)
                                this.output.putImageData(new ImageData(output_uint8_data, SIZE, SIZE), 0, 0)
                                math.endScope()
                                request_in_progress = false
                                update()
                            })
                        })
                    }, (e) => {
                        this.last_failure = e
                        this.progress = null
                        request_in_progress = false
                        update()
                    })
                }
            }
        })

        v.frame("undo_button", 192 - 32, 310, 64, 40, () => {
            if (do_button(v, "terug")) {
                this.pop_buffer()
                update()
            }
        })

        v.frame("clear_button", 270 - 32, 310, 64, 40, () => {
            if (do_button(v, "verwijder")) {
                this.buffers = []
                this.buffer.fillStyle = this.config.clear
                this.buffer.fillRect(0, 0, SIZE, SIZE)
                this.output.fillStyle = "#FFFFFF"
                this.output.fillRect(0, 0, SIZE, SIZE)
            }
        })

        if (this.sheet_loaded) {
            v.frame("random_button", 347 - 32, 310, 64, 40, () => {
                if (do_button(v, "random")) {
                    // pick next sheet entry
                    this.buffers = []
                    var y_offset = this.sheet_index * SIZE
                    this.buffer.drawImage(this.sheet, 0, y_offset, SIZE, SIZE, 0, 0, SIZE, SIZE)
                    this.output.drawImage(this.sheet, SIZE, y_offset, SIZE, SIZE, 0, 0, SIZE, SIZE)
                    this.sheet_index = (this.sheet_index + 1) % (this.sheet.height / SIZE)
                    update()
                }
            })
        }

        v.frame("save_button", 655 - 32, 310, 64, 40, () => {
            if (do_button(v, "opslaan")) {
                // create a canvas to hold the part of the canvas that we wish to store
                var x = 125 * SCALE
                var y = 0
                var width = 800 * SCALE - x
                var height = 310 * SCALE - y
                var convert = createContext(width, height, 1)
                convert.drawImage(v.ctx.canvas, x, y, width, height, 0, 0, convert.canvas.width, convert.canvas.height)
                var data_b64 = convert.canvas.toDataURL("image/png").replace(/^data:image\/png;base64,/, "")
                var data = b64_to_bin(data_b64)
                var blob = new Blob([data], {type: "application/octet-stream"})
                var url = window.URL.createObjectURL(blob)
                var a = document.createElement("a")
                a.href = url
                a.download = "pix2pix.png"
                // use createEvent instead of .click() to work in firefox
                // also can"t revoke the object url because firefox breaks
                var event = document.createEvent("MouseEvents")
                event.initEvent("click", true, true)
                a.dispatchEvent(event)
                // safari doesn"t work at all
            }
        })

        if (this.last_failure != null) {
            v.frame("server_error", 50, 350, v.f.width, 50, () => {
                v.ctx.font = "20px Arial"
                v.ctx.fillStyle = "red"
                v.center_text(fmt("error %s", this.last_failure))
            })
        }
    },
}

// utility

function createContext(width, height, scale) {
    var canvas = document.createElement("canvas")
    canvas.width = width * scale
    canvas.height = height * scale
    stylize(canvas, {
        width: fmt("%dpx", width),
        height: fmt("%dpx", height),
        margin: "10px auto 10px auto",
    })
    var ctx = canvas.getContext("2d")
    ctx.scale(scale, scale)
    return ctx
}

function b64_to_bin(str) {
    var binstr = atob(str)
    var bin = new Uint8Array(binstr.length)
    for (var i = 0; i < binstr.length; i++) {
        bin[i] = binstr.charCodeAt(i)
    }
    return bin
}

function delay(fn) {
    setTimeout(fn, 0)
}

function default_format(obj) {
    if (typeof (obj) === "string") {
        return obj
    } else {
        return JSON.stringify(obj)
    }
}

function fmt() {
    if (arguments.length === 0) {
        return "error"
    }

    var format = arguments[0]
    var output = ""

    var arg_index = 1
    var i = 0

    while (i < format.length) {
        var c = format[i]
        i++

        if (c != "%") {
            output += c
            continue
        }

        if (i === format.length) {
            output += "%!(NOVERB)"
            break
        }

        var flag = format[i]
        i++

        var pad_char = " "

        if (flag == "0") {
            pad_char = "0"
        } else {
            // not a flag
            i--
        }

        var width = 0
        while (format[i] >= "0" && format[i] <= "9") {
            width *= 10
            width += parseInt(format[i], 10)
            i++
        }

        var f = format[i]
        i++

        if (f === "%") {
            output += "%"
            continue
        }

        if (arg_index === arguments.length) {
            output += "%!" + f + "(MISSING)"
            continue
        }

        var arg = arguments[arg_index]
        arg_index++

        var o = null

        if (f === "v") {
            o = default_format(arg)
        } else if (f === "s" && typeof (arg) === "string") {
            o = arg
        } else if (f === "T") {
            o = typeof (arg)
        } else if (f === "d" && typeof (arg) === "number") {
            o = arg.toFixed(0)
        } else if (f === "f" && typeof (arg) === "number") {
            o = arg.toString()
        } else if (f === "x" && typeof (arg) === "number") {
            o = Math.round(arg).toString(16)
        } else if (f === "t" && typeof (arg) === "boolean") {
            if (arg) {
                o = "true"
            } else {
                o = "false"
            }
        } else {
            output += "%!" + f + "(" + typeof (arg) + "=" + default_format(arg) + ")"
        }

        if (o !== null) {
            if (o.length < width) {
                output += Array(width - o.length + 1).join(pad_char)
            }
            output += o
        }
    }

    if (arg_index < arguments.length) {
        output += "%!(EXTRA "
        while (arg_index < arguments.length) {
            var arg = arguments[arg_index]
            output += typeof (arg) + "=" + default_format(arg)
            if (arg_index < arguments.length - 1) {
                output += ", "
            }
            arg_index++
        }
        output += ")"
    }

    return output
}


// immediate mode UI

var SCALE = 2

var updated = true
var frame_rate = 0
var now = new Date()
var last_frame = new Date()
var animations = {}
var values = {}

var cursor_style = null
var mouse_pos = [0, 0]
var last_mouse_pos = [0, 0]
var drag_start = [0, 0]
var mouse_down = false
var mouse_pressed = false
var mouse_released = false

if (DEBUG) {
    var fps_elem = document.createElement("div")
    stylize(fps_elem, {
        width: "300px",
        height: "20px",
        margin: "5px",
        fontFamily: "Monaco",
        fontSize: "12px",
        position: "absolute",
        top: fmt("%dpx", 10),
        right: fmt("%dpx", 10),
    })
    document.body.insertBefore(fps_elem, document.body.firstChild)

    var status_elem = document.createElement("div")
    stylize(status_elem, {
        width: "10px",
        height: "10px",
        margin: "5px",
        position: "absolute",
        top: fmt("%dpx", 10),
        left: fmt("%dpx", 10),
    })
    document.body.insertBefore(status_elem, document.body.firstChild)
}

function View(name, width, height) {
    this.ctx = createContext(width, height, SCALE)
    // https://developer.apple.com/library/safari/documentation/AudioVideo/Conceptual/HTML-canvas-guide/AddingText/AddingText.html
    this.ctx.textBaseline = "middle"
    this.frames = [{name: name, offset_x: 0, offset_y: 0, width: width, height: height}]
    this.f = this.frames[0]
}

View.prototype = {
    push_frame: function (name, x, y, width, height) {
        this.ctx.save()
        this.ctx.translate(x, y)
        var current = this.frames[this.frames.length - 1]
        var next = {
            name: name,
            offset_x: current.offset_x + x,
            offset_y: current.offset_y + y,
            width: width,
            height: height
        }
        this.frames.push(next)
        this.f = next
    },
    pop_frame: function () {
        this.ctx.restore()
        this.frames.pop()
        this.f = this.frames[this.frames.length - 1]
    },
    frame: function (name, x, y, width, height, func) {
        this.push_frame(name, x, y, width, height)
        func()
        this.pop_frame()
    },
    frame_path: function () {
        var parts = []
        for (var i = 0; i < this.frames.length; i++) {
            parts.push(this.frames[i].name)
        }
        return parts.join(".")
    },
    relative: function (pos) {
        // adjust x and y relative to the top left corner of the canvas
        // then adjust relative to the current frame
        var rect = this.ctx.canvas.getBoundingClientRect()
        return {x: pos.x - rect.left - this.f.offset_x, y: pos.y - rect.top - this.f.offset_y}
    },
    contains: function (pos) {
        // first check that position is inside canvas container
        var rect = this.ctx.canvas.getBoundingClientRect()
        if (pos.x < rect.left || pos.x > rect.left + rect.width || pos.y < rect.top || pos.y > rect.top + rect.height) {
            return false
        }
        // translate coordinates to the current frame
        var rel = this.relative(pos)
        return 0 < rel.x && rel.x < this.f.width && 0 < rel.y && rel.y < this.f.height
    },
    put_image_data: function (d, x, y) {
        this.ctx.putImageData(d, (x + this.f.offset_x) * SCALE, (y + this.f.offset_y) * SCALE)
    },
    center_text: function (s) {
        this.ctx.fillText(s, (this.f.width - this.ctx.measureText(s).width) / 2, this.f.height / 2)
    },
}

function do_button(v, text) {
    name = v.frame_path()

    if (v.contains(mouse_pos)) {
        cursor_style = "pointer"
    }

    if (request_in_progress) {
        animate(name, parse_color("#aaaaaaFF"), 100)
    } else if (mouse_down && v.contains(mouse_pos)) {
        animate(name, parse_color("#FF0000FF"), 50)
    } else {
        if (v.contains(mouse_pos)) {
            animate(name, parse_color("#f477a5FF"), 100)
        } else {
            animate(name, parse_color("#f92672FF"), 100)
        }
    }

    v.ctx.save()
    var radius = 5
    v.ctx.beginPath()
    v.ctx.moveTo(radius, 0)
    var sides = [v.f.width, v.f.height, v.f.width, v.f.height]
    for (var i = 0; i < sides.length; i++) {
        var side = sides[i]
        v.ctx.lineTo(side - radius, 0)
        v.ctx.arcTo(side, 0, side, radius, radius)
        v.ctx.translate(side, 0)
        v.ctx.rotate(90 / 180 * Math.PI)
    }
    v.ctx.fillStyle = rgba(calculate(name))
    v.ctx.fill()
    v.ctx.restore()

    v.ctx.font = "16px Arial"
    v.ctx.fillStyle = "#f8f8f8"
    v.center_text(text)

    if (request_in_progress) {
        return false
    }

    return mouse_released && v.contains(mouse_pos) && v.contains(drag_start)
}

function stylize(elem, style) {
    for (var key in style) {
        elem.style[key] = style[key]
    }
}

function update() {
    updated = true
}

function frame() {
    var raf = window.requestAnimationFrame(frame)

    if (!updated && Object.keys(animations).length == 0) {
        if (DEBUG) {
            status_elem.style.backgroundColor = "black"
        }
        return
    }
    if (DEBUG) {
        status_elem.style.backgroundColor = "red"
    }

    now = new Date()
    cursor_style = null
    updated = false

    try {
        render()
    } catch (e) {
        window.cancelAnimationFrame(raf)
        throw e
    }

    if (cursor_style == null) {
        document.body.style.cursor = "default"
    } else {
        document.body.style.cursor = cursor_style
    }

    if (DEBUG) {
        var decay = 0.9
        var current_frame_rate = 1 / ((now - last_frame) / 1000)
        frame_rate = frame_rate * decay + current_frame_rate * (1 - decay)
        fps_elem.textContent = fmt("fps: %d", frame_rate)
    }

    last_frame = now
    last_mouse_pos = mouse_pos
    mouse_pressed = false
    mouse_released = false
}

function array_equal(a, b) {
    if (a.length != b.length) {
        return false
    }

    for (var i = 0; i < a.length; i++) {
        if (a[i] != b[i]) {
            return false
        }
    }
    return true
}

function animate(name, end, duration) {
    if (values[name] == undefined) {
        // no value has been set for this element, set it immediately
        values[name] = end
        return
    }

    var v = calculate(name)
    if (array_equal(v, end)) {
        return
    }
    if (duration == 0) {
        delete animations[name]
        values[name] = end
        return
    }
    var a = animations[name]
    if (a != undefined && array_equal(a.end, end)) {
        return
    }
    animations[name] = {time: now, start: v, end: end, duration: duration}
}

function calculate(name) {
    if (values[name] == undefined) {
        throw "calculate used before calling animate"
    }

    var a = animations[name]
    if (a != undefined) {
        // update value
        var t = Math.min((now - a.time) / a.duration, 1.0)
        t = t * t * t * (t * (t * 6 - 15) + 10) // smootherstep
        var result = []
        for (var i = 0; i < a.start.length; i++) {
            result[i] = a.start[i] + (a.end[i] - a.start[i]) * t
        }
        if (t == 1.0) {
            delete animations[name]
        }
        values[name] = result
    }
    return values[name]
}

function rgba(v) {
    return fmt("rgba(%d, %d, %d, %f)", v[0] * 255, v[1] * 255, v[2] * 255, v[3])
}

var parse_color = function (c) {
    return [
        parseInt(c.substr(1, 2), 16) / 255,
        parseInt(c.substr(3, 2), 16) / 255,
        parseInt(c.substr(5, 2), 16) / 255,
        parseInt(c.substr(7, 2), 16) / 255,
    ]
}

document.addEventListener("mousemove", function (e) {
    mouse_pos = {x: e.clientX, y: e.clientY}
    update()
})

document.addEventListener("mousedown", function (e) {
    drag_start = {x: e.clientX, y: e.clientY}
    mouse_down = true
    mouse_pressed = true
    update()
})

document.addEventListener("mouseup", function (e) {
    mouse_down = false
    mouse_released = true
    update()
})

